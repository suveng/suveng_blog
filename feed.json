{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "苏文广的博客",
  "home_page_url": "https://suveng.github.io/suveng_blog/",
  "feed_url": "https://suveng.github.io/suveng_blog/feed.json",
  "description": "苏文广的博客",
  "items": [
    {
      "title": "MySQL索引B+树高度计算",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E7%B4%A2%E5%BC%95B_%E6%A0%91%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E7%B4%A2%E5%BC%95B_%E6%A0%91%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97.html",
      "summary": "1. 总记录数 N 2. 记录大小 k Byte 3. 索引大小 x Byte 4. 数据库指针大小 6 Byte 5. 数据库页大小 16KB 从底往上计算高度 叶子节点存放数据 一个叶子节点存放数据量 c = 16 * 1024 / k 一个非叶子节点存放叶子节点数量 b = 16 * 1024 / (x + 6) 总页数 p = N / c 索引...",
      "content_html": "<h1> MySQL索引B+树高度计算</h1>\n<ol>\n<li>总记录数 N</li>\n<li>记录大小 k Byte</li>\n<li>索引大小 x Byte</li>\n<li>数据库指针大小 6 Byte</li>\n<li>数据库页大小  16KB</li>\n</ol>\n<p>从底往上计算高度</p>\n<p>叶子节点存放数据</p>\n<p>一个叶子节点存放数据量 c = 16 * 1024 / k</p>\n<p>一个非叶子节点存放叶子节点数量 b = 16 * 1024 / (x + 6)</p>\n<p>总页数 p = N / c</p>\n<p>索引的高度 h = log(p,b)</p>\n<p>树高 = h + 1</p>\n<h2> 聚簇索引例子计算</h2>\n<p>总记录N = 20,000,000</p>\n<p>记录大小k = 1024</p>\n<p>索引大小x = 8</p>\n<p>总页数p = 1250000</p>\n<p>索引数b = 1170</p>\n<p>索引树高log(p,b) = 2</p>\n<p>树高 = 3</p>\n<p>总结, 2千万的数据,B+树的高度为3</p>\n<h2> 辅助索引例子计算</h2>\n<p>辅助索引的叶子节点存放的事主键值, 辅助索引找到主键, 通过主键去聚簇索引查找记录</p>\n<p>辅助索引最大是256Byte</p>\n<p>总记录N = 20,000,000</p>\n<p>记录大小k = 8</p>\n<p>索引大小x = 256</p>\n<p>总页数p = 9765</p>\n<p>索引数b = 62</p>\n<p>索引树高log(p,b) = 3</p>\n<p>树高 = 4</p>\n<p>总结, 2千万的数据,辅助索引B+树的高度为4</p>\n",
      "date_published": "2024-01-13T02:57:27.000Z",
      "date_modified": "2024-01-13T03:15:06.000Z",
      "authors": [],
      "tags": [
        "MySQL"
      ]
    },
    {
      "title": "高并发设计",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E6%9E%B6%E6%9E%84/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E6%9E%B6%E6%9E%84/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1.html",
      "summary": "高并发定义 高并发是指在一定时间内，大量的请求同时访问应用程序或系统，导致系统出现性能瓶颈，如响应时间变慢、服务不可用等问题。 高并发通常出现在促销活动、秒杀场景、网站流量高峰期等情况下。 衡量高并发的指标 响应时间(RT); 并发数(QPS); 请求成功率(成功数/总数); 资源利用率; CPU; 内存; IO; JVM GC; 影响并发的因素 硬件...",
      "content_html": "<h1> 高并发设计</h1>\n<h2> 高并发定义</h2>\n<p>高并发是指在一定时间内，大量的请求同时访问应用程序或系统，导致系统出现性能瓶颈，如响应时间变慢、服务不可用等问题。</p>\n<p>高并发通常出现在促销活动、秒杀场景、网站流量高峰期等情况下。</p>\n<h2> 衡量高并发的指标</h2>\n<ul>\n<li>响应时间(RT)</li>\n<li>并发数(QPS)</li>\n<li>请求成功率(成功数/总数)</li>\n<li>资源利用率\n<ul>\n<li>CPU</li>\n<li>内存</li>\n<li>IO</li>\n<li>JVM GC</li>\n</ul>\n</li>\n</ul>\n<h2> 影响并发的因素</h2>\n<ul>\n<li>硬件\n<ul>\n<li>CPU</li>\n<li>内存</li>\n<li>磁盘</li>\n</ul>\n</li>\n<li>软件架构\n<ul>\n<li>单体架构</li>\n<li>分布式架构</li>\n</ul>\n</li>\n<li>数据库\n<ul>\n<li>MySQL</li>\n<li>Redis</li>\n</ul>\n</li>\n<li>网络\n<ul>\n<li>带宽, 上行速率/下行速率</li>\n</ul>\n</li>\n<li>程序代码</li>\n</ul>\n<h2> 高并发设计</h2>\n<p>如果设计一个高并发的系统, 考虑的因素比较多, 这里用控制变量法去控制其他因素保持不变, 只看程序代码的方式, 设计一个高并发的程序</p>\n<ul>\n<li>\n<p>硬件固定</p>\n<p>4c8G的硬件</p>\n</li>\n<li>\n<p>软件架构固定</p>\n<p>使用单体架构, 测试单体的并发性能可以粗略估算水平扩容的分布式架构的性能; 当然, 具体分布式架构下的并发性能还是需要测试, 但是这里为了测试方便才使用单体架构</p>\n</li>\n<li>\n<p>数据库固定</p>\n<p>固定使用MySQL和Redis</p>\n</li>\n<li>\n<p>网络固定</p>\n<p>本地网络, 家庭网络的路由大概是千兆网, 这里网络不会成为卡点</p>\n</li>\n<li>\n<p>编程语言固定</p>\n<p>Java</p>\n</li>\n<li>\n<p>改变程序代码(库存接口)</p>\n<ol>\n<li>\n<p>仅使用MySQL 无缓存 (MySQL的缓存忽略不计)</p>\n</li>\n<li>\n<p>MySQL + Redis 2级缓存</p>\n</li>\n<li>\n<p>MySQL + Redis + 内存 3级缓存</p>\n<p>以上三种迭代的方式, 测试并发性能</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3> 测试无缓存</h3>\n<h3> 测试2级缓存</h3>\n<h3> 测试3级缓存</h3>\n",
      "date_published": "2024-01-13T02:57:27.000Z",
      "date_modified": "2024-01-13T02:57:27.000Z",
      "authors": [],
      "tags": [
        "架构"
      ]
    },
    {
      "title": "MySQL慢查询优化",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.html",
      "summary": "优化原则 1. 最左前缀匹配原则 2. 选择区分度高的列作为索引 3. 索引列不参与计算 4. 尽量扩展索引 排查慢查询过程 1. 找到耗时较长的SQL语句 2. 使用explain语句解析SQL执行计划 3. 排查执行计划中是否有全表扫描的情况 4. 排查执行计划中扫描行数较多的查询语句 5. 制定方案优化SQL 如果实在无法优化, 看看是否折中的方...",
      "content_html": "<h1> MySQL慢查询优化</h1>\n<h2> 优化原则</h2>\n<ol>\n<li>最左前缀匹配原则</li>\n<li>选择区分度高的列作为索引</li>\n<li>索引列不参与计算</li>\n<li>尽量扩展索引</li>\n</ol>\n<h2> 排查慢查询过程</h2>\n<ol>\n<li>\n<p>找到耗时较长的SQL语句</p>\n</li>\n<li>\n<p>使用explain语句解析SQL执行计划</p>\n</li>\n<li>\n<p>排查执行计划中是否有全表扫描的情况</p>\n</li>\n<li>\n<p>排查执行计划中扫描行数较多的查询语句</p>\n</li>\n<li>\n<p>制定方案优化SQL</p>\n<p>如果实在无法优化, 看看是否折中的方案实现业务</p>\n</li>\n</ol>\n",
      "date_published": "2024-01-11T07:49:51.000Z",
      "date_modified": "2024-01-11T07:49:51.000Z",
      "authors": [],
      "tags": [
        "MySQL"
      ]
    },
    {
      "title": "MySQL的语法解析器",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8.html",
      "summary": "SQL本身是一种程序语言, 语言最终会被编译成指令在程序中运行; 那么语言本身是可以被解析, 对应的解析器有哪些实现 1. MySQL源码的解析器 由专门的公司维护 SQL Parser, https://www.sqlparser.com/ 2. 开源的SQL解析器 美团开源的SQL Advisor https://github.com/Meitua...",
      "content_html": "<h1> MySQL的语法解析器</h1>\n<p>SQL本身是一种程序语言, 语言最终会被编译成指令在程序中运行;</p>\n<p>那么语言本身是可以被解析, 对应的解析器有哪些实现</p>\n<ol>\n<li>\n<p>MySQL源码的解析器</p>\n<p>由专门的公司维护 SQL Parser, https://www.sqlparser.com/</p>\n</li>\n<li>\n<p>开源的SQL解析器</p>\n<ul>\n<li>美团开源的SQL Advisor https://github.com/Meituan-Dianping/SQLAdvisor</li>\n</ul>\n</li>\n</ol>\n<h2> 语法解析器应用场景</h2>\n<ul>\n<li>SQL分析监控</li>\n</ul>\n<h2> 语法解析原理</h2>\n<ul>\n<li></li>\n<li>构建语法树</li>\n</ul>\n",
      "date_published": "2024-01-11T07:31:13.000Z",
      "date_modified": "2024-01-11T07:31:13.000Z",
      "authors": [],
      "tags": [
        "MySQL"
      ]
    },
    {
      "title": "MySQL的SQL执行过程",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E7%9A%84SQL%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E7%9A%84SQL%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.html",
      "summary": "这是MySQL架构组件执行流程, 最后交给存储引擎执行SQL; startuml skin rose node Driver database MySQL { component SQL接口 component SQL解析器 component SQL优化器 component SQL执行器 component SQL存储引擎 } Driver -->...",
      "content_html": "<h1> MySQL的SQL执行过程</h1>\n<p>这是MySQL架构组件执行流程, 最后交给存储引擎执行SQL;</p>\n<img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpinJACelJbNWuihBJqbLS2dAB4ijuaf9B4bCIWGA-rO61_eeL7Cf045oVcv1VbvgNea2KEnPtzAd_OinnLyiN_niteIdCrTWIZtPC-DfppIiKiywbxzOs8DLwkdQ6K-RLZpTC_NPv3wkMYukY0iLT7Nje8wpKZ3KKtYwUzVprTqlziy3kWjP2TobG6L6UWeGUu22N0W9g3Aumu4gZVKK85oeIeGSL37SAq359de84IuKEPW3O9u3AZRLGuXmeSX15IDx5wZU3CtDADBe7ZG7Edl_bAUpvpsRkk5PxpeqFq93nKh10cXctz9dKxP1bJcavgK04mC0\" alt=\"uml diagram\" loading=\"lazy\">\n<p>InnoDB存储引擎执行过程</p>\n<p>这是InnoDB的写入操作流程<br>\n其中 redo log 时 InnoDB 特有的组件<br>\nbinlog 时 MySQL 本身的组件</p>\n<img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpinJACelJkNY0ejnMJthM_fiohRWG1zh87l-qcUT-u3ivxDQdatTyAnt7KWGp7YwTiRJrgLEfMbfgKK1-VavG8cd6zeWSa_spmL9TsmepKl9LyZ9JmVfchtbsRGD2FKe9eBbaCqjIeLhVBAh-sdNmkUx9p-REnze0qn60QBm-UB6vxDdO2fxDhdtoTuvBzPjUBftAaGbq3b9GBz238Moe8OyNTVph6F2qmbzEWh8DZnRq0uquCcENSdvkRcP9TR04Celu798pKi1XXm0\" alt=\"uml diagram\" loading=\"lazy\">\n<p>redo log 的 作用</p>\n<ol>\n<li>\n<p>实现持久性和一致性</p>\n<p>由于数据的更新操作都是在内存发生的, 那么如果断电后, 如何保证内存的数据和磁盘的数据一致性, 那么redo log 的作用就是用来保证磁盘和内存数据的一致性;<br>\n假设数据在提交事务后, redo log 只存在内存, 还没有落入磁盘中, 这个时候发生了断电, 磁盘的数据是落后于内存的数据的, 那么断电恢复后, InnoDB会从redo log 中恢复BufferPool的环境, 这个时候再将差异的数据写入磁盘中, 保证了持久性和一致性</p>\n</li>\n</ol>\n",
      "date_published": "2024-01-11T07:19:46.000Z",
      "date_modified": "2024-01-11T07:19:46.000Z",
      "authors": [],
      "tags": [
        "MySQL"
      ]
    },
    {
      "title": "MySQL同步数据ES",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/ElasticSearch/MySQL%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AEES%E6%96%B9%E6%A1%88.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/ElasticSearch/MySQL%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AEES%E6%96%B9%E6%A1%88.html",
      "summary": "1. 同步双写 2. 异步双写 3. 定时任务 4. 数据订阅 同步双写 startuml skin rose node 商品服务 database MySQL storage ElasticSearch interface --> 商品服务 : 1. 更新商品请求 商品服务 --> MySQL : 2.同步更新数据 商品服务 --> ElasticS...",
      "content_html": "<h1> MySQL同步数据ES</h1>\n<ol>\n<li>同步双写</li>\n<li>异步双写</li>\n<li>定时任务</li>\n<li>数据订阅</li>\n</ol>\n<h2> 同步双写</h2>\n<img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpinJACelJkNAoqz9LNWwjUtfvCPdStgVTYtaIaaiIKnAB4vLyAqC3lJXAYx9BqfCJrLmpKaiBibC3avDB4hEuChCAqajIajCJbNGrRL3qQzWfM2ef_1izfPdqpP0n5-it_viOnCNYYAGBh3vGEL6Uaydz3nRknIYvzdK3Szwrs6gHh4VgCiOcow7rBmKeFy0\" alt=\"uml diagram\" loading=\"lazy\">\n<h3> 优点</h3>\n<ol>\n<li>\n<p>简单</p>\n<p>仅需要在需要同步数据的逻辑上增加往ElasticSearch写</p>\n</li>\n<li>\n<p>保证实时性</p>\n</li>\n</ol>\n<h3> 缺点</h3>\n<ol>\n<li>\n<p>商品业务和搜索业务强耦合</p>\n</li>\n<li>\n<p>扩展性差</p>\n<p>需要定制搜索需求需求时, 还需要改动商品代码</p>\n</li>\n<li>\n<p>ElasticSearch 和 MySQL 需要额外保证一致性</p>\n<p>MySQL事务提交之后, 写入ElasticSearch出现网络异常, 那么ElasticSearch和MySQL的数据无法保证一致</p>\n</li>\n</ol>\n<h2> 异步双写</h2>\n<img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpinJACelJkNAoqz9LNWwjUtfvCPdStgVTYs4Y3oRCEVvbaLGaSBIrD9KXUp4jEn4hfJ4aiIanE9K1T_Au40V1DSr9x6u93CvE3MnA3c3YoiphoIrA2qnELL1LzSEnNm5AmL3lMUpjpoRjW4Y_6BzzcSRcxXGr80qWIq0gZP2KVriwePdlUkUxfgCgG7iGA06OxtdK-O_sRKSqvBdirgURUjurhYU2w8Mf0lPfq3D9df05I-sxCId6KLBNHs6_qpra5MysD3yVCgAP_ENlbY_2AgmR-dJ_iMene2SWXA6G7FCz1HUDCvwEg43wka9VK_RPZvjNOeQrWwfUId0E0K0\" alt=\"uml diagram\" loading=\"lazy\">\n<p>与同步双写相比分析优缺点</p>\n<h3> 优点</h3>\n<ul>\n<li>解耦合; 商品本身无需关注同步ElasticSearch的逻辑</li>\n</ul>\n<h3> 缺点</h3>\n<ul>\n<li>准实时, 存在MQ延迟</li>\n<li>需要考虑额外组件的可靠性, Kafka, 搜索服务</li>\n</ul>\n<h2> 定时任务</h2>\n<img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpinJACelJkNAoqz9LNWwjUtfvCPdStgVTYs4Y3oRCEVvbaLGaPJ4aiIanE9K1T_Au40V1DSr9x6u93CvE3MnA3c3YoiphoIrA2qnELL1LzSEnKm5AmL3lMUpjpoRjW4Y_6BzzcSRcxXGr80qWIq0gZP2KVriwePdlUkUxfhCXUmiXRew35kCzP1LF5qtwzdqRIysD3-VikBP_AKlrYzwEcS5nE2NqxUyd3NbHK_pqzbRdhQrFf_L0Z7fQSVq5mjNeDe3SXYALu4McUWfl6YSzNH21zHj4_gUjirysheKDKWSKlDIWC4D0000\" alt=\"uml diagram\" loading=\"lazy\">\n<h3> 优点</h3>\n<ol>\n<li>简单</li>\n</ol>\n<h3> 缺点</h3>\n<ol>\n<li>\n<p>无法保证实时性</p>\n<p>保证实时性主要依赖于搜索服务的定时间隔</p>\n</li>\n</ol>\n<h2> 数据订阅</h2>\n<img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpinJACelJkNAoqz9LNWwjUtfvCPdStgVTYtaAYnDBKrLI4xCIyo1o3wRCEVvbaLGsPJ4aiIanE9K1T_Au40V1DSr9x6u93CvE3MnA3c3YoiphoIrA2qnELL1LzSEnNm5AmL3lMUpjpoRjW4Y_6BzzcSRcxXGr80qWIq0gZP2KVriwePdlUkUxfhC1P47gGIx5QZIM0_CUh5kqSiPhKcPUJdvwLmGEP0gP6y05PleFTlMyMBBJaodF9_L0fHwrhYU2qLBNHs6Hqpra5MysD3yVCgAP_ENlbY_2AgmR-dJ_iMene2SWX9OG7FCz1HUDCvwEg43whi9VK_RPZvjNOeQg0wfUId0o0C0\" alt=\"uml diagram\" loading=\"lazy\">\n<h3> 优点</h3>\n<ol>\n<li>\n<p>解耦合</p>\n<p>利用canal订阅MySQL的binlog做到解耦合</p>\n</li>\n<li>\n<p>无业务侵入</p>\n<p>利用canal组件即可无需在商品代码上做改动</p>\n</li>\n<li>\n<p>准实时</p>\n<p>只存在binlog和业务回查的延迟</p>\n</li>\n<li>\n<p>良好的扩展行</p>\n<p>canal组件还支持各种数据库/客户端的写入适配器, 可以实现不同的数据写入需求, 例如 HBase</p>\n</li>\n</ol>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T04:00:35.000Z",
      "authors": [],
      "tags": [
        "ElasticSearch"
      ]
    },
    {
      "title": "Gossip一致性算法",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/Gossip%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/Gossip%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html",
      "content_html": "<h1> Gossip一致性算法</h1>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "Paxos一致性算法",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/Paxos%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/Paxos%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html",
      "content_html": "<h1> Paxos一致性算法</h1>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "Raft一致性算法",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/Raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/Raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html",
      "content_html": "<h1> Raft一致性算法</h1>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "ZAB一致性算法",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/ZAB%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/ZAB%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95.html",
      "content_html": "<h1> ZAB一致性算法</h1>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "冒泡排序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html",
      "summary": "冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 算法描述 1. 从数列中挑出最小（大）元素，依次放到数列的起始位置； 2. 再从剩下的元素中挑出最小（大）元素，放到已排序序列的末尾； 3....",
      "content_html": "<h1> 冒泡排序</h1>\n<p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>\n<h2> 算法描述</h2>\n<ol>\n<li>从数列中挑出最小（大）元素，依次放到数列的起始位置；</li>\n<li>再从剩下的元素中挑出最小（大）元素，放到已排序序列的末尾；</li>\n<li>重复步骤2，直到所有元素排序完成。</li>\n</ol>\n<h2> 示例</h2>\n<p>对数列 {5, 3, 8, 6, 4} 进行冒泡排序：</p>\n<p>第一轮：</p>\n<ul>\n<li>比较5和3，发现5&gt;3，交换位置，数列变成 {3, 5, 8, 6, 4}；</li>\n<li>比较5和8，发现5&lt;8，位置不变，数列还是 {3, 5, 8, 6, 4}；</li>\n<li>比较8和6，发现8&gt;6，交换位置，数列变成 {3, 5, 6, 8, 4}；</li>\n<li>比较8和4，发现8&gt;4，交换位置，数列变成 {3, 5, 6, 4, 8}；<br>\n第一轮结束，此时最大元素8已经排好序，接下来对剩下的数列 {3, 5, 6, 4} 进行冒泡排序。</li>\n</ul>\n<p>第二轮：</p>\n<ul>\n<li>比较3和5，发现3&lt;5，位置不变，数列还是 {3, 5, 6, 4}；</li>\n<li>比较5和6，发现5&lt;6，位置不变，数列还是 {3, 5, 6, 4}；</li>\n<li>比较6和4，发现6&gt;4，交换位置，数列变成 {3, 5, 4, 6}；<br>\n第二轮结束，此时次大元素6已经排好序，剩下的数列 {3, 5, 4} 继续冒泡排序。</li>\n</ul>\n<p>第三轮：</p>\n<ul>\n<li>比较3和5，发现3&lt;5，位置不变，数列还是 {3, 5, 4}；</li>\n<li>比较5和4，发现5&gt;4，交换位置，数列变成 {3, 4, 5}；<br>\n第三轮结束，此时第三大元素5已经排好序，剩下的数列 {3, 4} 继续冒泡排序。</li>\n</ul>\n<p>第四轮：</p>\n<ul>\n<li>比较3和4，发现3&lt;4，位置不变，数列还是 {3, 4}；<br>\n第四轮结束，此时最小元素3已经排好序，整个数列排序完成。</li>\n</ul>\n<h2> 复杂度分析</h2>\n<ul>\n<li>最好情况：当数组已经按照排序需求排好时，只需进行一次遍历，时间复杂度为O(n)；</li>\n<li>最坏情况：当数组是逆序排列时，需要进行n-1次遍历，时间复杂度为O(n^2)；</li>\n<li>平均情况：需要进行n-1次遍历，时间复杂度为O(n^2)。</li>\n</ul>\n<p>冒泡排序是一种稳定的排序算法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "双指针",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88.html",
      "summary": "双指针算法（Two-Pointers Algorithm）是一种常见的算法思想，通常用于解决数组或链表相关的问题。该算法通过使用两个指针，分别从数组或链表的两端向中间移动，从而解决问题。 双指针算法通常可以分为两种情况： 1. 从数组的两端向中间移动的双指针算法： 这种情况下，我们通常使用两个指针从数组的两端同时开始遍历，然后根据具体的问题来决定两个指...",
      "content_html": "<h1> 双指针</h1>\n<p>双指针算法（Two-Pointers Algorithm）是一种常见的算法思想，通常用于解决数组或链表相关的问题。该算法通过使用两个指针，分别从数组或链表的两端向中间移动，从而解决问题。<br>\n双指针算法通常可以分为两种情况：</p>\n<ol>\n<li>\n<p>从数组的两端向中间移动的双指针算法：<br>\n这种情况下，我们通常使用两个指针从数组的两端同时开始遍历，然后根据具体的问题来决定两个指针的移动方式。这种算法通常用于解决一些查找或筛选的问题，例如查找两个数的和等于目标值、查找数组中的环形子数组等。</p>\n</li>\n<li>\n<p>从数组的一端向另一端移动的双指针算法：<br>\n这种情况下，我们通常使用两个指针，一个指向数组的起始位置，另一个从起始位置开始向后遍历。这种算法通常用于解决一些排序或统计的问题，例如验证只包含相同字符的最长子串、统计数组中元素出现次数等。</p>\n</li>\n</ol>\n<p>使用双指针算法可以有效地提高解决数组或链表相关问题的效率，因为双指针同时进行遍历，可以将时间复杂度从O(n^2)降低到O(n)。</p>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "基数排序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html",
      "summary": "基本原理 基数排序是一种非比较性的排序算法。基数排序的基本思想是：将整数按位数划分为不同的桶，然后按每个位数分别对桶中的元素进行排序，最终将所有位数上的排序结果合并在一起，得到最终的排序结果。 基数排序的时间复杂度为O(dn)，其中d是数字的最大位数，n是待排序元素个数。 实现步骤 基数排序的实现步骤如下： 1. 获取待排序数组中的最大值，确定最大位数...",
      "content_html": "<h1> 基数排序</h1>\n<h2> 基本原理</h2>\n<p>基数排序是一种非比较性的排序算法。基数排序的基本思想是：将整数按位数划分为不同的桶，然后按每个位数分别对桶中的元素进行排序，最终将所有位数上的排序结果合并在一起，得到最终的排序结果。</p>\n<p>基数排序的时间复杂度为O(dn)，其中d是数字的最大位数，n是待排序元素个数。</p>\n<h2> 实现步骤</h2>\n<p>基数排序的实现步骤如下：</p>\n<ol>\n<li>获取待排序数组中的最大值，确定最大位数d。</li>\n<li>对最末位进行排序，使用计数排序算法对每个数字出现的次数进行统计。</li>\n<li>基于计数排序的结果，依次确定每个数字在有序数组中的位置。</li>\n<li>将有序数组重新赋值给原数组。</li>\n<li>依次对每一位进行排序，直到最高位。</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "堆排序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F.html",
      "summary": "堆排序（Heap Sort）是利用堆（Heap）这种数据结构进行选择排序的一种算法。堆是一个可以推导具有最大或最小值的树形结构，堆排序利用堆的特性进行排序。 堆排序分为两个步骤： 1. 建堆（Build Heap）：将一个无序的数组构建成一个大顶堆（Max Heap）。大顶堆的特点是父节点的值大于或等于其子节点的值。建堆的过程从数组的最后一个非叶子节点...",
      "content_html": "<h1> 堆排序</h1>\n<p>堆排序（Heap Sort）是利用堆（Heap）这种数据结构进行选择排序的一种算法。堆是一个可以推导具有最大或最小值的树形结构，堆排序利用堆的特性进行排序。</p>\n<p>堆排序分为两个步骤：</p>\n<ol>\n<li>\n<p>建堆（Build Heap）：将一个无序的数组构建成一个大顶堆（Max Heap）。大顶堆的特点是父节点的值大于或等于其子节点的值。建堆的过程从数组的最后一个非叶子节点开始，依次向上调整每个节点，使其满足大顶堆的特性。</p>\n</li>\n<li>\n<p>排序（Sort）：重复执行以下步骤，直到堆的大小为1：</p>\n<ul>\n<li>将堆中的最大元素（根节点）与堆的最后一个元素交换。</li>\n<li>将堆的大小减1。</li>\n<li>对堆进行调整，使其重新成为一个大顶堆。</li>\n</ul>\n</li>\n</ol>\n<p>重复上述步骤，每次取出的都是当前堆中的最大元素，最终得到的数组就是一个有序的数组。</p>\n<p>堆排序的时间复杂度为O(nlogn)，空间复杂度为O(1)。由于堆排序是一种不稳定的排序算法，因此在需要保持相同元素的原始顺序时应谨慎使用。</p>\n<p>以下是堆排序的示例代码：</p>\n<h2> Java实现</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "希尔排序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html",
      "content_html": "<h1> 希尔排序</h1>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "归并排序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html",
      "content_html": "<h1> 归并排序</h1>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "快速排序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html",
      "summary": "快速排序是一种常用的排序算法，采用分治法（Divide and Conquer）的思想。它的基本步骤如下： 1. 从数列中挑出一个元素，称为“基准”（pivot）。 2. 将所有比基准值小的元素都放在基准前面，比基准值大的元素都放在基准的后面（相同的数可以放在任一边）。在这个分区退出之后，该基准就处于数列的中间位置。 3. 对基准的左右两个分区重复步骤...",
      "content_html": "<h1> 快速排序</h1>\n<p>快速排序是一种常用的排序算法，采用分治法（Divide and Conquer）的思想。它的基本步骤如下：</p>\n<ol>\n<li>从数列中挑出一个元素，称为“基准”（pivot）。</li>\n<li>将所有比基准值小的元素都放在基准前面，比基准值大的元素都放在基准的后面（相同的数可以放在任一边）。在这个分区退出之后，该基准就处于数列的中间位置。</li>\n<li>对基准的左右两个分区重复步骤1和步骤2。<br>\n快速排序的关键步骤是基准的选取，不同的选取方法会影响排序的效率。通常有以下几种选取方法：\n<ul>\n<li>选取第一个元素作为基准</li>\n<li>选取最后一个元素作为基准</li>\n<li>选取中间元素作为基准</li>\n<li>从数列中随机选取一个元素作为基准</li>\n</ul>\n</li>\n</ol>\n<p>快速排序的时间复杂度为O(nlogn)，但在最坏情况下时间复杂度为O(n^2)。为了避免最坏情况的发生，可以采用随机选取基准、三数中值法选取基准等优化方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "插入排序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html",
      "summary": "插入排序是一种简单直观的排序算法。它的基本思想是通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 时间复杂度 在最坏的情况下，插入排序需要O(n^2)的时间复杂度和O(1)的空间复杂度。 空间复杂度 在最好情况下，插入排序需要O(n)的时间复杂度和O(1)的空间复杂度。 Java代码实现",
      "content_html": "<h1> 插入排序</h1>\n<p>插入排序是一种简单直观的排序算法。它的基本思想是通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>\n<h2> 时间复杂度</h2>\n<p>在最坏的情况下，插入排序需要O(n^2)的时间复杂度和O(1)的空间复杂度。</p>\n<h2> 空间复杂度</h2>\n<p>在最好情况下，插入排序需要O(n)的时间复杂度和O(1)的空间复杂度。</p>\n<h2> Java代码实现</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "斐波那契数列问题",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98.html",
      "summary": "数学公式如下: $$ \\begin{align} f(n) = \\left\\{ \\begin{matrix} 0 & n=0 \\\\ 1 & n=1 \\\\ f(n-1)+f(n-2) & n>=1 \\end{matrix} \\right. \\end{align} $$",
      "content_html": "<h1> 斐波那契数列问题</h1>\n<p>数学公式如下:</p>\n<p v-pre=\"\" class=\"katex-block\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right\" columnspacing=\"\"><mtr><mtd class=\"mtr-glue\"></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mi>n</mi><mo>&gt;</mo><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd><mtd class=\"mtr-glue\"></mtd><mtd class=\"mml-eqn-num\"></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\n\\begin{align}\nf(n)  = \n\n\\left\\{\n    \\begin{matrix}\n        0   &amp; n=0  \\\\\n        1   &amp; n=1  \\\\  \n        f(n-1)+f(n-2)  &amp; n&gt;=1\n    \\end{matrix}\n\\right.\n\n\\end{align}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3.9em;vertical-align:-1.7em;\"></span><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.2em;\"><span style=\"top:-4.2em;\"><span class=\"pstrut\" style=\"height:4.05em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-2.5em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎩</span></span></span><span style=\"top:-2.492em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.016em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.016em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 16\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V16 H384z M384 0 H504 V16 H384z\"></path></svg></span></span><span style=\"top:-3.15em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎨</span></span></span><span style=\"top:-4.292em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span style=\"height:0.016em;width:0.8889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"0.8889em\" height=\"0.016em\" style=\"width:0.8889em\" viewBox=\"0 0 888.89 16\" preserveAspectRatio=\"xMinYMin\"><path d=\"M384 0 H504 V16 H384z M384 0 H504 V16 H384z\"></path></svg></span></span><span style=\"top:-4.3em;\"><span class=\"pstrut\" style=\"height:3.15em;\"></span><span class=\"delimsizinginner delim-size4\"><span>⎧</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">0</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.7em;\"><span></span></span></span></span></span></span></span><span class=\"tag\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.2em;\"><span style=\"top:-4.2em;\"><span class=\"pstrut\" style=\"height:4.05em;\"></span><span class=\"eqn-num\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.7em;\"><span></span></span></span></span></span></span></span></span></p>\n<hr>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "桶排序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E6%A1%B6%E6%8E%92%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E6%A1%B6%E6%8E%92%E5%BA%8F.html",
      "content_html": "<h1> 桶排序</h1>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "计数排序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html",
      "content_html": "<h1> 计数排序</h1>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "选择排序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html",
      "summary": "选择排序是一种简单直观的排序算法。它的基本思想是：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 步骤 选择排序的算法步骤如下： 1. 在待排序的元素中，找到最小（大）的元素，将其与第一个元素交换位置。 2. 在剩下的元素中，找到最小（大）的元素，将其与第二个元素交换位置。 3. 重复上述步骤...",
      "content_html": "<h1> 选择排序</h1>\n<p>选择排序是一种简单直观的排序算法。它的基本思想是：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>\n<h2> 步骤</h2>\n<p>选择排序的算法步骤如下：</p>\n<ol>\n<li>在待排序的元素中，找到最小（大）的元素，将其与第一个元素交换位置。</li>\n<li>在剩下的元素中，找到最小（大）的元素，将其与第二个元素交换位置。</li>\n<li>重复上述步骤，直到所有元素均排序完毕。</li>\n</ol>\n<h2> 示例</h2>\n<p>给定数组 [3, 4, 2, 1, 5]，按升序排序。</p>\n<ol>\n<li>第一次遍历，找到最小元素 1，与第一个元素 3 交换位置，数组变为 [1, 4, 2, 3, 5]。</li>\n<li>第二次遍历，忽略第一个元素，找到最小元素 2，与第二个元素 4 交换位置，数组变为 [1, 2, 4, 3, 5]。</li>\n<li>第三次遍历，忽略前两个元素，找到最小元素 3，与第三个元素 4 交换位置，数组变为 [1, 2, 3, 4, 5]。</li>\n<li>第四次遍历，忽略前三个元素，找到最小元素 4，与第四个元素 4 交换位置，数组保持不变 [1, 2, 3, 4, 5]。</li>\n<li>第五次遍历，忽略前四个元素，找到最小元素 5，与第五个元素 5 交换位置，数组保持不变 [1, 2, 3, 4, 5]。</li>\n</ol>\n<p>最终得到的数组为 [1, 2, 3, 4, 5]，即为按升序排序后的结果。</p>\n<h2> 时间复杂度</h2>\n<p>选择排序的时间复杂度为 O(n^2)，其中 n 是待排序数组的长度。</p>\n<h2> 代码实现</h2>\n<p>下面是使用 Java 实现选择排序的示例代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上代码实现了选择排序的排序算法和排序结果的输出。</p>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "线程",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B.html",
      "summary": "Java的线程是程序执行的最小单位，是操作系统进行调度的基本单元。Java中的线程由Thread类和Runnable接口实现。Thread类是一个实现了Runnable接口的类，它包含线程的控制方法和线程的生命周期方法。Runnable接口定义了一个run()方法，该方法包含线程要执行的代码。 Java中的线程有以下几种状态： 1. 初始(NEW)：新...",
      "content_html": "<h1> 线程</h1>\n<p>Java的线程是程序执行的最小单位，是操作系统进行调度的基本单元。Java中的线程由Thread类和Runnable接口实现。Thread类是一个实现了Runnable接口的类，它包含线程的控制方法和线程的生命周期方法。Runnable接口定义了一个run()方法，该方法包含线程要执行的代码。</p>\n<p>Java中的线程有以下几种状态：</p>\n<ol>\n<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>\n<li>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>\n线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>\n<li>阻塞(BLOCKED)：表示线程阻塞于锁。</li>\n<li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>\n<li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>\n<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>\n</ol>\n<img src=\"https://www.plantuml.com/plantuml/svg/ZPA_JiCm4CPtFuN75YcmCw0-11j2o6skYObphXn7KK1CB20oC362M62haDYenDEGje_HS_uZTMWMA_v-zztdioU95SQciM99994RdG1dxEBeadk-pj0xumWPF-NbylNlzwaiNfZxRpMJ8egf0WBEGmF2FwxiHcFMAPwHGMY9jJA6gqn82_u0Lm2BqVZ4xTDohINIiX0c8ezXXQTWRlztH6tbF2SynQQWRzhGKwLdKTKloN4M6eto1hYpPAtKvHiu1s2vasaIlMLpP5SiCI1gR-PMFZngusl1n195FPtru-VslIYNnVhXcGqKukXg60tPGkz_opXzRfvvsxTEkFbURLPlsw_xykUZPXh9KHNUNKGkGVcKwuwn2Q1F3s87\" alt=\"uml diagram\" loading=\"lazy\">\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "线程池",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/Java/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",
      "summary": "线程池设计思想 Java线程池的设计思想是为了提高线程的使用效率和响应能力，以及降低资源消耗和线程管理的复杂度。 Java线程池主要具有以下设计思想： 1. 重复使用线程：Java线程池中的线程可以被重复使用，而不是为每个任务创建一个新的线程。这样可以避免线程的创建和销毁带来的开销，提高程序的性能。 2. 控制资源消耗：Java线程池可以控制线程的数量...",
      "content_html": "<h1> 线程池</h1>\n<h2> 线程池设计思想</h2>\n<p>Java线程池的设计思想是为了提高线程的使用效率和响应能力，以及降低资源消耗和线程管理的复杂度。<br>\nJava线程池主要具有以下设计思想：</p>\n<ol>\n<li>重复使用线程：Java线程池中的线程可以被重复使用，而不是为每个任务创建一个新的线程。这样可以避免线程的创建和销毁带来的开销，提高程序的性能。</li>\n<li>控制资源消耗：Java线程池可以控制线程的数量，从而控制程序对系统资源的消耗。当线程数量过多时，可以避免过多的线程同时占用资源，导致资源浪费和系统负载过高。</li>\n<li>提高响应能力：Java线程池可以快速响应任务的提交和执行，从而提高程序的响应能力。当有新的任务提交时，线程池可以立即分配线程执行任务，而不用等待新的线程创建和就绪。</li>\n<li>任务执行管理：Java线程池可以对任务的执行进行管理，例如控制任务的执行顺序、限制任务的执行时间、处理任务的异常等。这样可以保证任务的执行质量，并提高程序的可靠性。</li>\n</ol>\n<p>Java线程池通过ThreadPoolExecutor类来实现，该类提供了可重用的线程池，并提供了丰富的配置选项，可以根据实际需要来配置线程池的参数，以达到最佳的性能和效果。<br>\nJava线程池的设计思想是基于生产者-消费者模式，通过工作线程来执行任务，从而实现高效的并发处理。</p>\n<h2> 如何停止线程池中的线程</h2>\n<p>在Java中，线程池中的线程是并发执行的，不支持直接停止某一个线程。但是可以通过以下几种方式中断线程的执行：</p>\n<ol>\n<li>使用线程的interrupt方法中断线程</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li>使用线程的interrupted方法检查中断标志位</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"3\">\n<li>使用线程的isInterrupted方法检查中断状态</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 线程池的核心参数</h2>\n<p>线程池的核心参数如下：</p>\n<ul>\n<li><code>corePoolSize</code>：核心线程数，即线程池维护的最低线程数。</li>\n<li><code>maximumPoolSize</code>：最大线程数，即线程池维护的最大线程数。</li>\n<li><code>keepAliveTime</code>：线程空闲 timeout，即线程空闲 timeout 时间。</li>\n<li><code>unit</code>：时间单位。</li>\n<li><code>workQueue</code>：任务队列，用于保存等待线程执行的任务。</li>\n<li><code>threadFactory</code>：线程工厂，用于创建新线程。</li>\n<li><code>handler</code>：拒绝执行策略，当任务队列和线程池都达到最大容量时，将执行任务的续行策略。</li>\n</ul>\n",
      "date_published": "2024-01-11T02:25:57.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "MySQL主从复制",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html",
      "content_html": "<h1> MySQL主从复制</h1>\n",
      "date_published": "2024-01-08T15:24:42.000Z",
      "date_modified": "2024-01-08T15:24:42.000Z",
      "authors": [],
      "tags": [
        "MySQL"
      ]
    },
    {
      "title": "MySQL事务",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E4%BA%8B%E5%8A%A1.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E4%BA%8B%E5%8A%A1.html",
      "content_html": "<h1> MySQL事务</h1>\n",
      "date_published": "2024-01-08T15:24:42.000Z",
      "date_modified": "2024-01-08T15:24:42.000Z",
      "authors": [],
      "tags": [
        "MySQL"
      ]
    },
    {
      "title": "MySQL分库分表",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html",
      "summary": "为什么要分库分表 需要分库分表的情况无非是数据库性能无法满足业务要求; 1. 读慢 数据量过大,导致InnoDB的存储文件.ibd过大, MySQL需要先将ibd文件读取到内存中进行查找,然后将数据返回给客户端 磁盘IO可能成为瓶颈, 读取文件; CPU内存查找可能成为瓶颈, 查找; 网络传输可能成为瓶颈; 2. 写慢 数据量过大,导致InnoDB的存...",
      "content_html": "<h1> MySQL分库分表</h1>\n<h2> 为什么要分库分表</h2>\n<p>需要分库分表的情况无非是数据库性能无法满足业务要求;</p>\n<ol>\n<li>\n<p>读慢</p>\n<p>数据量过大,导致InnoDB的存储文件<code>&lt;表名&gt;.ibd</code>过大, MySQL需要先将ibd文件读取到内存中进行查找,然后将数据返回给客户端</p>\n<ul>\n<li>磁盘IO可能成为瓶颈, 读取文件</li>\n<li>CPU内存查找可能成为瓶颈, 查找</li>\n<li>网络传输可能成为瓶颈</li>\n</ul>\n</li>\n<li>\n<p>写慢</p>\n<p>数据量过大,导致InnoDB的存储文件<code>&lt;表名&gt;.ibd</code>过大, MySQL需要先将ibd文件读取到内存中进行查找写入位置, 然后将数据写入, 如果写不会导致B+树结构变化, 那么是用乐观锁写入, 如果写入数据会导致B+树的索引结构变化(新增页),那么是分段悲观锁写入的方式, 这种方式是串行的;</p>\n<ul>\n<li>磁盘IO可能成为瓶颈, 读取文件, 写入文件(新增页)</li>\n<li>CPU内存查找</li>\n<li>网络传输可能成为瓶颈</li>\n<li>读写锁机制更新索引B+树<br>\n总结下来, 其实更多是写锁导致的并发性能问题</li>\n</ul>\n</li>\n<li>\n<p>并发慢</p>\n<p>但数据库的连接数却是有限的，在高并发场景下多个业务同时对一个数据库操作，很容易将连接数耗尽导致too many connections报错，导致后续数据库无法正常访问。</p>\n</li>\n</ol>\n",
      "date_published": "2024-01-08T15:24:42.000Z",
      "date_modified": "2024-01-13T08:29:49.000Z",
      "authors": [],
      "tags": [
        "MySQL"
      ]
    },
    {
      "title": "电商售后设计方案",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E5%94%AE%E5%90%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E5%94%AE%E5%90%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "summary": "电商业务流程时序.md (%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.md)",
      "content_html": "<h1> 电商售后设计方案</h1>\n<p><a href=\"/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.html\" target=\"blank\">电商业务流程时序.md</a></p>\n<img src=\"https://www.plantuml.com/plantuml/svg/XPFVJi8m5CRl-nIz9xm05uPNcReBeenaRDuZOAO8mm3-IJ24HON4i968BBg8BxDsvIqSdexiB29NQt-dt_Vrj5snQYYwOPPFIVMaf56zKbKfKKoZefdbGrKdH3aoAZfTZrVCTJQJqfbYgCcSm9VcymTKk4_2g_6EnH_hD9UZ1Hez1EnhaEP4LmrJrsI5MrrsDK8cR731UhLONg3ytHOJ2m2pxiHucgWHIwjvTnWj70Y7CIpTAzp6ReIZvsZO0YAy5rvlOhbak7M7jGUowTSMQx-9nIpyc1DPsAo9-bDk-Ti8uJbW47wFUSrB8X1BgJCRZDL0i1gnb9htlJ2u1xNe-Co-1OBLVxFbkhTazXoVSyeFnaIYx6a0bXUDSlvXoTP_tSAWnywduCRi6x6OR1_Hx9Ajcf8HkIwx0IZZCCJIVQMpejagRdwNBLInxLwswya8hn46Ff3iMsi8ztEdaBdNiJKMmWmgX1HLxJZ-kNy0\" alt=\"uml diagram\" loading=\"lazy\">\n",
      "date_published": "2024-01-07T09:14:51.000Z",
      "date_modified": "2024-01-08T10:00:41.000Z",
      "authors": [],
      "tags": [
        "电商"
      ]
    },
    {
      "title": "电商商品设计方案",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E5%95%86%E5%93%81%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "summary": "电商业务流程时序.md (%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.md) 商品的职责有哪些? 商品来源; 企业生产(自产自销) : 一般是有自己的供应链,公司内部记录和管理; 企业采购(B2B) : 从外部企业渠道采购到公司内部, 并由公司内部记录...",
      "content_html": "<h1> 电商商品设计方案</h1>\n<p><a href=\"/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.html\" target=\"blank\">电商业务流程时序.md</a></p>\n<img src=\"https://www.plantuml.com/plantuml/svg/XPFVJi8m5CRl-nIz9xm05uPNcReBeenaRDuZOAO8mm3-IJ24HON4i968BBg8BxDsvIqSdexiB29NQt-dt_Vrj5snQYYwOPPFIVMaf56zKbKfKKoZefdbGrKdH3aoAZfTZrVCTJQJqfbYgCcSm9VcymTKk4_2g_6EnH_hD9UZ1Hez1EnhaEP4LmrJrsI5MrrsDK8cR731UhLONg3ytHOJ2m2pxiHucgWHIwjvTnWj70Y7CIpTAzp6ReIZvsZO0YAy5rvlOhbak7M7jGUowTSMQx-9nIpyc1DPsAo9-bDk-Ti8uJbW47wFUSrB8X1BgJCRZDL0i1gnb9htlJ2u1xNe-Co-1OBLVxFbkhTazXoVSyeFnaIYx6a0bXUDSlvXoTP_tSAWnywduCRi6x6OR1_Hx9Ajcf8HkIwx0IZZCCJIVQMpejagRdwNBLInxLwswya8hn46Ff3iMsi8ztEdaBdNiJKMmWmgX1HLxJZ-kNy0\" alt=\"uml diagram\" loading=\"lazy\">\n<h2> 商品的职责有哪些?</h2>\n<ul>\n<li>商品来源\n<ul>\n<li>企业生产(自产自销) : 一般是有自己的供应链,公司内部记录和管理</li>\n<li>企业采购(B2B) : 从外部企业渠道采购到公司内部, 并由公司内部记录和管理</li>\n<li>企业回收(C2B) : 从个人手中回收商品, 并有公司内部记录和管理</li>\n</ul>\n</li>\n<li>商品规格</li>\n<li>商品描述</li>\n<li>商品定价</li>\n</ul>\n<h2> 商品上下游模块依赖</h2>\n<ul>\n<li>供应链模块(商品来源)</li>\n<li>订单模块(商品售卖)</li>\n<li>物流模块(商品物流)</li>\n</ul>\n<img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpinJACelJbNWuihBJqbLU3grxUdaHYZdnRf5JtkdGZdFErS-smgKuO8eKR3HrOKgKB1IUBAZ6yXuDdsR3aJeQUlc5urJO8P1bG5rs46D0MfvsZ_nnPRbI5eczK3adi_UyMJN98W9N5nGzI2jK8kje6OWs_5a_y9dZUkvk1nIyrA0_W80\" alt=\"uml diagram\" loading=\"lazy\">\n<h2> 商品核心功能</h2>\n<ul>\n<li>录入商品</li>\n<li>搜索商品列表</li>\n<li>查询商品详情</li>\n<li>更新库存</li>\n</ul>\n<h2> 商品模型</h2>\n<img src=\"https://www.plantuml.com/plantuml/svg/ZLJDJW8n4BxtANhMy0wyX_50X0CHCQ5m8YOIZIu7ioIiPeqUW0iNOV5aT8cy36tXBUWwTNUwxQuUlw_V_7mparPPjzRfzYvQX9qtsxHpoHgK4FvunyU3xMOg1X4zgbGe4BlvhPYiWIxIoFTOlYpBDM9oBnVVVsY2Q1k7ukcJhtrYfwPA29ZOEPD7mCHktE7dPXzS6zsKw-EF_1HAzVnhp1UXrfEpLeqnQfZk4qgFDTMi8o27ddXzGuGojP-5YE33oEA4x-ysAqpWKMOqRlha59T5SpOUy8pLmzMl6mZGFW1e7m3uw47ELvdUiKx73D94QHpKrre0MWl0NSUu34UTD54kpbZg_tS4OOO6A6ilZdEojuDkC_ze79QxUPJRi60qARoHig2qFqZLuy4oGSwKk6XnIb1Pcq27wDm4FjI2RMJpAAuEAaLnxpd9Kssqw-gBEm00\" alt=\"uml diagram\" loading=\"lazy\">\n<h2> 搜索商品列表高性能低延时方案</h2>\n<p>使用ElasticSearch作为搜索引擎</p>\n<p>搜索相关度排序</p>\n<ol>\n<li>商品类目</li>\n<li>商品标签</li>\n<li>商品标题</li>\n<li>商品副标题</li>\n<li>商品描述</li>\n<li>规格描述</li>\n<li>热卖商品</li>\n</ol>\n<h3> ES数据映射</h3>\n<p>ES需要对以下数据做映射</p>\n<ul>\n<li>商品\n<ul>\n<li>商品类目</li>\n<li>商品标签</li>\n<li>商品规格</li>\n</ul>\n</li>\n<li>订单</li>\n</ul>\n<h3> ES数据同步方案</h3>\n<p><a href=\"/suveng_blog/zh/posts/ElasticSearch/MySQL%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AEES%E6%96%B9%E6%A1%88.html\" target=\"blank\">MySQL同步数据ES.md</a></p>\n<p>通过上面文章的方案比较, 最终选用数据订阅方式,进行ES数据同步</p>\n",
      "date_published": "2024-01-07T09:14:51.000Z",
      "date_modified": "2024-01-11T02:25:57.000Z",
      "authors": [],
      "tags": [
        "电商"
      ]
    },
    {
      "title": "电商搜索设计方案",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E6%90%9C%E7%B4%A2%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E6%90%9C%E7%B4%A2%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "summary": "电商业务流程时序.md (%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.md) https://zq99299.github.io/note-book/back-end-storage/",
      "content_html": "<h1> 电商搜索设计方案</h1>\n<p><a href=\"/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.html\" target=\"blank\">电商业务流程时序.md</a></p>\n<img src=\"https://www.plantuml.com/plantuml/svg/XPFVJi8m5CRl-nIz9xm05uPNcReBeenaRDuZOAO8mm3-IJ24HON4i968BBg8BxDsvIqSdexiB29NQt-dt_Vrj5snQYYwOPPFIVMaf56zKbKfKKoZefdbGrKdH3aoAZfTZrVCTJQJqfbYgCcSm9VcymTKk4_2g_6EnH_hD9UZ1Hez1EnhaEP4LmrJrsI5MrrsDK8cR731UhLONg3ytHOJ2m2pxiHucgWHIwjvTnWj70Y7CIpTAzp6ReIZvsZO0YAy5rvlOhbak7M7jGUowTSMQx-9nIpyc1DPsAo9-bDk-Ti8uJbW47wFUSrB8X1BgJCRZDL0i1gnb9htlJ2u1xNe-Co-1OBLVxFbkhTazXoVSyeFnaIYx6a0bXUDSlvXoTP_tSAWnywduCRi6x6OR1_Hx9Ajcf8HkIwx0IZZCCJIVQMpejagRdwNBLInxLwswya8hn46Ff3iMsi8ztEdaBdNiJKMmWmgX1HLxJZ-kNy0\" alt=\"uml diagram\" loading=\"lazy\">\n<p>https://zq99299.github.io/note-book/back-end-storage/</p>\n",
      "date_published": "2024-01-07T09:14:51.000Z",
      "date_modified": "2024-01-08T10:00:41.000Z",
      "authors": [],
      "tags": [
        "电商"
      ]
    },
    {
      "title": "电商支付设计方案",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E6%94%AF%E4%BB%98%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E6%94%AF%E4%BB%98%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "summary": "电商业务流程时序.md (%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.md)",
      "content_html": "<h1> 电商支付设计方案</h1>\n<p><a href=\"/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.html\" target=\"blank\">电商业务流程时序.md</a></p>\n<img src=\"https://www.plantuml.com/plantuml/svg/XPFVJi8m5CRl-nIz9xm05uPNcReBeenaRDuZOAO8mm3-IJ24HON4i968BBg8BxDsvIqSdexiB29NQt-dt_Vrj5snQYYwOPPFIVMaf56zKbKfKKoZefdbGrKdH3aoAZfTZrVCTJQJqfbYgCcSm9VcymTKk4_2g_6EnH_hD9UZ1Hez1EnhaEP4LmrJrsI5MrrsDK8cR731UhLONg3ytHOJ2m2pxiHucgWHIwjvTnWj70Y7CIpTAzp6ReIZvsZO0YAy5rvlOhbak7M7jGUowTSMQx-9nIpyc1DPsAo9-bDk-Ti8uJbW47wFUSrB8X1BgJCRZDL0i1gnb9htlJ2u1xNe-Co-1OBLVxFbkhTazXoVSyeFnaIYx6a0bXUDSlvXoTP_tSAWnywduCRi6x6OR1_Hx9Ajcf8HkIwx0IZZCCJIVQMpejagRdwNBLInxLwswya8hn46Ff3iMsi8ztEdaBdNiJKMmWmgX1HLxJZ-kNy0\" alt=\"uml diagram\" loading=\"lazy\">\n",
      "date_published": "2024-01-07T09:14:51.000Z",
      "date_modified": "2024-01-08T10:00:41.000Z",
      "authors": [],
      "tags": [
        "电商"
      ]
    },
    {
      "title": "电商购物车方案",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E8%B4%AD%E7%89%A9%E8%BD%A6%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E8%B4%AD%E7%89%A9%E8%BD%A6%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "summary": "电商业务流程时序.md (%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.md)",
      "content_html": "<h1> 电商购物车方案</h1>\n<p><a href=\"/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.html\" target=\"blank\">电商业务流程时序.md</a></p>\n<img src=\"https://www.plantuml.com/plantuml/svg/XPFVJi8m5CRl-nIz9xm05uPNcReBeenaRDuZOAO8mm3-IJ24HON4i968BBg8BxDsvIqSdexiB29NQt-dt_Vrj5snQYYwOPPFIVMaf56zKbKfKKoZefdbGrKdH3aoAZfTZrVCTJQJqfbYgCcSm9VcymTKk4_2g_6EnH_hD9UZ1Hez1EnhaEP4LmrJrsI5MrrsDK8cR731UhLONg3ytHOJ2m2pxiHucgWHIwjvTnWj70Y7CIpTAzp6ReIZvsZO0YAy5rvlOhbak7M7jGUowTSMQx-9nIpyc1DPsAo9-bDk-Ti8uJbW47wFUSrB8X1BgJCRZDL0i1gnb9htlJ2u1xNe-Co-1OBLVxFbkhTazXoVSyeFnaIYx6a0bXUDSlvXoTP_tSAWnywduCRi6x6OR1_Hx9Ajcf8HkIwx0IZZCCJIVQMpejagRdwNBLInxLwswya8hn46Ff3iMsi8ztEdaBdNiJKMmWmgX1HLxJZ-kNy0\" alt=\"uml diagram\" loading=\"lazy\">\n",
      "date_published": "2024-01-07T09:14:51.000Z",
      "date_modified": "2024-01-08T10:00:41.000Z",
      "authors": [],
      "tags": [
        "电商"
      ]
    },
    {
      "title": "电商业务流程时序",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.html",
      "summary": "startuml skin rose autonumber actor 顾客 activate 顾客 顾客 --> 认证授权 ++ : 登录认证授权 return 登录成功 顾客 --> 商品 ++: 浏览商品列表 return 商品列表 顾客 --> 搜索 ++ : 搜索商品 return 商品列表 顾客 --> 商品 ++ : 查看商品详情 ret...",
      "content_html": "<h1> 电商业务流程时序</h1>\n<!-- #region uml -->\n<img src=\"https://www.plantuml.com/plantuml/svg/XPFVJi8m5CRl-nIz9xm05uPNcReBeenaRDuZOAO8mm3-IJ24HON4i968BBg8BxDsvIqSdexiB29NQt-dt_Vrj5snQYYwOPPFIVMaf56zKbKfKKoZefdbGrKdH3aoAZfTZrVCTJQJqfbYgCcSm9VcymTKk4_2g_6EnH_hD9UZ1Hez1EnhaEP4LmrJrsI5MrrsDK8cR731UhLONg3ytHOJ2m2pxiHucgWHIwjvTnWj70Y7CIpTAzp6ReIZvsZO0YAy5rvlOhbak7M7jGUowTSMQx-9nIpyc1DPsAo9-bDk-Ti8uJbW47wFUSrB8X1BgJCRZDL0i1gnb9htlJ2u1xNe-Co-1OBLVxFbkhTazXoVSyeFnaIYx6a0bXUDSlvXoTP_tSAWnywduCRi6x6OR1_Hx9Ajcf8HkIwx0IZZCCJIVQMpejagRdwNBLInxLwswya8hn46Ff3iMsi8ztEdaBdNiJKMmWmgX1HLxJZ-kNy0\" alt=\"uml diagram\" loading=\"lazy\">\n<!-- #endregion uml -->\n",
      "date_published": "2024-01-07T07:44:20.000Z",
      "date_modified": "2024-01-07T09:14:51.000Z",
      "authors": [],
      "tags": [
        "电商"
      ]
    },
    {
      "title": "电商订单设计方案",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88.html",
      "summary": "电商业务流程时序.md (%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.md) 电商订单的职责 1. 电商订单是记录电商平台上的交易信息的重要数据实体，包括订单号、商品信息、收货地址、支付信息等。 2. 电商订单具有以下职责： 记录并管理交易信息：电商订...",
      "content_html": "<h1> 电商订单设计方案</h1>\n<p><a href=\"/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F.html\" target=\"blank\">电商业务流程时序.md</a></p>\n<img src=\"https://www.plantuml.com/plantuml/svg/XPFVJi8m5CRl-nIz9xm05uPNcReBeenaRDuZOAO8mm3-IJ24HON4i968BBg8BxDsvIqSdexiB29NQt-dt_Vrj5snQYYwOPPFIVMaf56zKbKfKKoZefdbGrKdH3aoAZfTZrVCTJQJqfbYgCcSm9VcymTKk4_2g_6EnH_hD9UZ1Hez1EnhaEP4LmrJrsI5MrrsDK8cR731UhLONg3ytHOJ2m2pxiHucgWHIwjvTnWj70Y7CIpTAzp6ReIZvsZO0YAy5rvlOhbak7M7jGUowTSMQx-9nIpyc1DPsAo9-bDk-Ti8uJbW47wFUSrB8X1BgJCRZDL0i1gnb9htlJ2u1xNe-Co-1OBLVxFbkhTazXoVSyeFnaIYx6a0bXUDSlvXoTP_tSAWnywduCRi6x6OR1_Hx9Ajcf8HkIwx0IZZCCJIVQMpejagRdwNBLInxLwswya8hn46Ff3iMsi8ztEdaBdNiJKMmWmgX1HLxJZ-kNy0\" alt=\"uml diagram\" loading=\"lazy\">\n<h2> 电商订单的职责</h2>\n<ol>\n<li>电商订单是记录电商平台上的交易信息的重要数据实体，包括订单号、商品信息、收货地址、支付信息等。</li>\n<li>电商订单具有以下职责：\n<ul>\n<li>记录并管理交易信息：电商订单负责记录和管理商品信息、支付信息、物流信息等交易相关数据。</li>\n<li>控制交易流程：电商订单可以根据订单状态控制交易流程，如待支付、已支付、待发货、已发货、已完成等。</li>\n<li>支持订单查询和统计：电商订单可以提供订单查询和统计功能，以便用户和商家进行订单管理、交易分析等操作。</li>\n<li>支持订单修改和取消：电商订单可以支持用户和商家对订单进行修改和取消操作，以满足不同业务场景的需求。</li>\n<li>保证订单安全和隐私：电商订单需要采取相应的安全措施，确保订单信息的安全性和隐私性。</li>\n</ul>\n</li>\n<li>电商订单的实现可以采用数据库存储、API接口调用等方式，具体的实现方式根据业务需求和系统架构进行选择。</li>\n</ol>\n<hr>\n<img src=\"https://www.plantuml.com/plantuml/svg/PPDDJi905CVtSuek_GWdSCCzZ0iYB8Y82SMLCQ6HQ2KQ9GoW8X6w8IviIIo5K5Ckqvcsjt26UQKpTDV_xts_DotgpLAZUNrPG_f5jQurhlGAEg-LT5sBROiyzyFDb1gETeEqOo3LSlOTTJpQChWcveZuQphqag7BDHsvT33FT38DY6s9R5l__Ztf6KAVdcqZi1FwRwa79n7-ekPhMlNWy2Gh962ANWRKCnKaakrvTMDt1YBw2IZsGCHEE_INgPlzn8foSOjW4tAlV1ExzlagUFoiJIT_8CWQyp7y9KDRaE0MmRO4miqTO-cWl9d7Rxg0_5bLsGsg2WI5X62rYVcUHSbxXYY188fDpRP0FkTaBBSG6pZwzVTRa4y2oGJQ9UE2hYQ9qPD0yj1DhB5eSlL1EbFcliif3miv0GKZjZksM8c9GEKb7XKAwcFAMULpvQtACqD8kIstAzV9MPLJeMAbNcQ_pZy0\" alt=\"uml diagram\" loading=\"lazy\">\n<hr>\n<h2> 核心API</h2>\n<ul>\n<li>生成订单id();</li>\n<li>创建订单();</li>\n<li>取消订单();</li>\n<li>支付订单();</li>\n<li>发货();</li>\n<li>签收();</li>\n<li>评价();</li>\n<li>完成();</li>\n</ul>\n<h2> 订单状态机设计</h2>\n<hr>\n<img src=\"https://www.plantuml.com/plantuml/svg/XLFBIiD05DtFLmJSwA985hv22VML_n3iJbret4Ty46ZL5c8HMbsuQA5eMgHMiTAlwOpnBxntPZ8pINniaiCvPyxSd9bKZloTG_zuVuy0yAiM3UzehqRhBMlEyppRjbF-zPbUjzWuH7uxmxDeC9lS8h-LypUJKG_vpGp_-JHbqHZvZQm_hhEmWVowmNy4E4yKqyOLIck6n4awEAFjUvHMCsbVGG2xiquV07kSec4vRv3yIY5JJRA4ajHuKrQvpD-kAzdgmIvmy0I624kfv1ezEe3RTFAUn0_qycP-WMY96rMnOEJWTwDish44q4ObgKHUFIOYA5hCLY4kR2RT4r488NgzJ9C7vbW2Y3JJya-QN9_E9ig5sJWGQQRbppHJv6xp4ZXwsX-SwiWXjDCNyo-gBm5Ah6Idv_JYPVPMKtkQM-YapEroB02WfviN7VaHPBgcZAzH3S5muJ0PTUMXy6k2FhnqH7SfAP9Pdf8LUC3__Gq0\" alt=\"uml diagram\" loading=\"lazy\">\n<hr>\n<h2> 注意的场景</h2>\n<h3> 如何避免重复下单?</h3>\n<p>首先,生成订单ID; 然后,使用订单ID作为幂等标识下单;</p>\n<h3> 如何解决ABA问题? (网络异常情况下, 请求顺序不一致导致数据错乱)</h3>\n<p>版本号的乐观锁机制</p>\n<ol>\n<li>查询接口将版本返回给调用方</li>\n<li>调用方将版本号作为参数给接口, 当版本一致的时候更新数据, 不一致不更新, 提示用户刷新页面</li>\n</ol>\n",
      "date_published": "2024-01-07T07:44:20.000Z",
      "date_modified": "2024-01-08T10:00:41.000Z",
      "authors": [],
      "tags": [
        "电商"
      ]
    },
    {
      "title": "数组",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84.html",
      "summary": "数组是一种线性数据结构，它由一组连续的内存空间组成，用于存储同一类型的数据元素。 数组的主要优点包括： 1. 直接访问 可以通过索引直接访问数组中的元素，时间复杂度为O(1)。 2. 灵活操作 可以通过索引对数组中的元素进行增加、删除、修改等操作。 3. 空间有效利用 在创建数组时，会预分配足够的内存空间用于存储元素，可以有效利用内存空间。 数组的主要...",
      "content_html": "<h1> 数组</h1>\n<p>数组是一种线性数据结构，它由一组连续的内存空间组成，用于存储同一类型的数据元素。</p>\n<h2> 数组的主要优点包括：</h2>\n<h3> 1. 直接访问</h3>\n<p>可以通过索引直接访问数组中的元素，时间复杂度为O(1)。</p>\n<h3> 2. 灵活操作</h3>\n<p>可以通过索引对数组中的元素进行增加、删除、修改等操作。</p>\n<h3> 3. 空间有效利用</h3>\n<p>在创建数组时，会预分配足够的内存空间用于存储元素，可以有效利用内存空间。</p>\n<h2> 数组的主要缺点包括：</h2>\n<h3> 1. 大小固定</h3>\n<p>数组的大小在创建时就需要确定，并且不能动态改变，如果需要存储更多的元素，需要重新创建一个更大的数组。</p>\n<h3> 2. 无法插入中间元素</h3>\n<p>如果需要在数组的中间插入元素，需要将后面的元素都向后移动一位，时间复杂度为O(n)。</p>\n<h3> 3. 无法删除中间元素</h3>\n<p>如果需要删除数组中的中间元素，需要将后面的元素都向前移动一位，时间复杂度为O(n)。</p>\n<h2> 总结</h2>\n<p>综上所述，数组适用于元素数量固定且需要直接访问的场景，但是不适用于需要动态增加或删除元素的场景。</p>\n",
      "date_published": "2024-01-05T11:15:57.000Z",
      "date_modified": "2024-01-05T11:18:48.000Z",
      "authors": [],
      "tags": [
        "数据结构"
      ]
    },
    {
      "title": "记录搭建VuePress博客",
      "url": "https://suveng.github.io/suveng_blog/zh/posts/%E8%AE%B0%E5%BD%95/%E8%AE%B0%E5%BD%95%E6%90%AD%E5%BB%BAVuePress%E5%8D%9A%E5%AE%A2.html",
      "id": "https://suveng.github.io/suveng_blog/zh/posts/%E8%AE%B0%E5%BD%95/%E8%AE%B0%E5%BD%95%E6%90%AD%E5%BB%BAVuePress%E5%8D%9A%E5%AE%A2.html",
      "summary": "VuePress (https://theme-hope.vuejs.press/zh/guide/blog/article.html)",
      "content_html": "<h1> 记录搭建VuePress博客</h1>\n<p><a href=\"https://theme-hope.vuejs.press/zh/guide/blog/article.html\" target=\"_blank\" rel=\"noopener noreferrer\">VuePress</a></p>\n",
      "date_published": "2024-01-04T09:45:47.000Z",
      "date_modified": "2024-01-05T02:25:32.000Z",
      "authors": [],
      "tags": [
        "博客"
      ]
    },
    {
      "title": "介绍页",
      "url": "https://suveng.github.io/suveng_blog/zh/intro.html",
      "id": "https://suveng.github.io/suveng_blog/zh/intro.html",
      "summary": "这是我的个人简历 个人信息 姓名: 苏文广 性别: 男 出生年月: 1996-12 大学: 韩山师范学院-软件工程专业(2015.9~2019.6/全日制统招本科) 手机号: 18320664028 邮箱: suveng@163.com 开发技能 4年工作经验; 熟悉 Java 语言, IO,反射,SPI,jvm, java agent; 精通业务关系...",
      "content_html": "<h1> 介绍页</h1>\n<p>这是我的个人简历</p>\n<h2> 个人信息</h2>\n<p>姓名: 苏文广<br>\n性别: 男<br>\n出生年月: 1996-12<br>\n大学: 韩山师范学院-软件工程专业(2015.9~2019.6/全日制统招本科)<br>\n手机号: 18320664028<br>\n邮箱: suveng@163.com</p>\n<h2> 开发技能</h2>\n<ul>\n<li>4年工作经验</li>\n<li>熟悉 Java 语言, IO,反射,SPI,jvm, java agent</li>\n<li>精通业务关系建模;能够独立设计大型复杂系统, 绘制系统架构图, UML 设计图, 精通 OKR 工作法</li>\n<li>精通 MySQL,掌握复杂 SQL 查询, 熟悉读写分离策略,主从复制策略, 熟悉常见 MySQL HA 代理方案, 熟练使用 sharding-sphere 对 MySQL 分库分表, 了解 ACID 实现原理,了解 MVCC 实现原理, 了解索引实现机制, 了解 XA 分布式事务管理</li>\n<li>熟悉 Linux 系统, 熟悉线上运维命令, 熟练 shell 脚本</li>\n<li>熟悉 Spring 全家桶, 熟悉 SpringCloud 微服务分布式架构实现,SpringBlade 脚手架</li>\n<li>掌握分布式存储设计; 熟悉 Hadoop 存储系统, 熟悉 HBase 数仓</li>\n<li>掌握分布式缓存设计; 掌握基于 Redis 的分布式缓存策略;</li>\n<li>掌握分布式调度设计; 熟练使用常见的分布式调度平台, xxl-job, schedulex</li>\n<li>掌握常见分布式事务设计, TCC 策略, Seata 架构</li>\n<li>掌握数据仓库设计, 熟练编写 Clickhouse sql 离线计算任务, Flink sql 实时计算任务</li>\n<li>掌握常见监控告警设计,熟练使用 Prometheus 系统生态</li>\n<li>了解 Vue,React 框架, 编写过数据大屏以及后台管理界面</li>\n</ul>\n",
      "date_published": "2024-01-04T08:10:21.000Z",
      "date_modified": "2024-01-05T02:25:32.000Z",
      "authors": [],
      "tags": [
        "博主"
      ]
    }
  ]
}