import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as l,c as e,b as o}from"./app-ho35QjFc.js";const t={},a=o('<h1 id="mysql分库分表" tabindex="-1"><a class="header-anchor" href="#mysql分库分表" aria-hidden="true">#</a> MySQL分库分表</h1><h2 id="为什么要分库分表" tabindex="-1"><a class="header-anchor" href="#为什么要分库分表" aria-hidden="true">#</a> 为什么要分库分表</h2><p>需要分库分表的情况无非是数据库性能无法满足业务要求;</p><ol><li><p>读慢</p><p>数据量过大,导致InnoDB的存储文件<code>&lt;表名&gt;.ibd</code>过大, MySQL需要先将ibd文件读取到内存中进行查找,然后将数据返回给客户端</p><ul><li>磁盘IO可能成为瓶颈, 读取文件</li><li>CPU内存查找可能成为瓶颈, 查找</li><li>网络传输可能成为瓶颈</li></ul></li><li><p>写慢</p><p>数据量过大,导致InnoDB的存储文件<code>&lt;表名&gt;.ibd</code>过大, MySQL需要先将ibd文件读取到内存中进行查找写入位置, 然后将数据写入, 如果写不会导致B+树结构变化, 那么是用乐观锁写入, 如果写入数据会导致B+树的索引结构变化(新增页),那么是分段悲观锁写入的方式, 这种方式是串行的;</p><ul><li>磁盘IO可能成为瓶颈, 读取文件, 写入文件(新增页)</li><li>CPU内存查找</li><li>网络传输可能成为瓶颈</li><li>读写锁机制更新索引B+树<br> 总结下来, 其实更多是写锁导致的并发性能问题</li></ul></li><li><p>并发慢</p><p>但数据库的连接数却是有限的，在高并发场景下多个业务同时对一个数据库操作，很容易将连接数耗尽导致too many connections报错，导致后续数据库无法正常访问。</p></li></ol>',4),c=[a];function n(d,r){return l(),e("div",null,c)}const p=i(t,[["render",n],["__file","MySQL分库分表.html.vue"]]);export{p as default};
