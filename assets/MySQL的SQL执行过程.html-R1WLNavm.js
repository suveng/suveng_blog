import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c as l,b as t}from"./app-YdghVm9r.js";const n={},a=t('<h1 id="mysql的sql执行过程" tabindex="-1"><a class="header-anchor" href="#mysql的sql执行过程" aria-hidden="true">#</a> MySQL的SQL执行过程</h1><p>这是MySQL架构组件执行流程, 最后交给存储引擎执行SQL;</p><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpinJACelJbNWuihBJqbLS2dAB4ijuaf9B4bCIWGA-rO61_eeL7Cf045oVcv1VbvgNea2KEnPtzAd_OinnLyiN_niteIdCrTWIZtPC-DfppIiKiywbxzOs8DLwkdQ6K-RLZpTC_NPv3wkMYukY0iLT7Nje8wpKZ3KKtYwUzVprTqlziy3kWjP2TobG6L6UWeGUu22N0W9g3Aumu4gZVKK85oeIeGSL37SAq359de84IuKEPW3O9u3AZRLGuXmeSX15IDx5wZU3CtDADBe7ZG7Edl_bAUpvpsRkk5PxpeqFq93nKh10cXctz9dKxP1bJcavgK04mC0" alt="uml diagram" loading="lazy"><p>InnoDB存储引擎执行过程</p><p>这是InnoDB的写入操作流程<br> 其中 redo log 时 InnoDB 特有的组件<br> binlog 时 MySQL 本身的组件</p><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIhEpinJACelJkNY0ejnMJthM_fiohRWG1zh87l-qcUT-u3ivxDQdatTyAnt7KWGp7YwTiRJrgLEfMbfgKK1-VavG8cd6zeWSa_spmL9TsmepKl9LyZ9JmVfchtbsRGD2FKe9eBbaCqjIeLhVBAh-sdNmkUx9p-REnze0qn60QBm-UB6vxDdO2fxDhdtoTuvBzPjUBftAaGbq3b9GBz238Moe8OyNTVph6F2qmbzEWh8DZnRq0uquCcENSdvkRcP9TR04Celu798pKi1XXm0" alt="uml diagram" loading="lazy"><p>redo log 的 作用</p><ol><li><p>实现持久性和一致性</p><p>由于数据的更新操作都是在内存发生的, 那么如果断电后, 如何保证内存的数据和磁盘的数据一致性, 那么redo log 的作用就是用来保证磁盘和内存数据的一致性;<br> 假设数据在提交事务后, redo log 只存在内存, 还没有落入磁盘中, 这个时候发生了断电, 磁盘的数据是落后于内存的数据的, 那么断电恢复后, InnoDB会从redo log 中恢复BufferPool的环境, 这个时候再将差异的数据写入磁盘中, 保证了持久性和一致性</p></li></ol>',8),p=[a];function i(r,d){return o(),l("div",null,p)}const s=e(n,[["render",i],["__file","MySQL的SQL执行过程.html.vue"]]);export{s as default};
