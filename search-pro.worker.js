const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":236,\"nextId\":236,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-858cfdd6\",\"2\":\"v-858cfdd6#个人信息\",\"3\":\"v-858cfdd6#开发技能\",\"4\":\"v-858cfdd6@0\",\"5\":\"v-858cfdd6@1\",\"6\":\"v-3ea5b5a5\",\"7\":\"v-3ea5b5a5#同步双写\",\"8\":\"v-3ea5b5a5#优点\",\"9\":\"v-3ea5b5a5#缺点\",\"10\":\"v-3ea5b5a5#异步双写\",\"11\":\"v-3ea5b5a5#优点-1\",\"12\":\"v-3ea5b5a5#缺点-1\",\"13\":\"v-3ea5b5a5#定时任务\",\"14\":\"v-3ea5b5a5#优点-2\",\"15\":\"v-3ea5b5a5#缺点-2\",\"16\":\"v-3ea5b5a5#数据订阅\",\"17\":\"v-3ea5b5a5#优点-3\",\"18\":\"v-3ea5b5a5@0\",\"19\":\"v-3ea5b5a5@1\",\"20\":\"v-6347236c\",\"21\":\"v-6347236c@0\",\"22\":\"v-6347236c@1\",\"23\":\"v-4d829fab\",\"24\":\"v-4d829fab@0\",\"25\":\"v-4d829fab@1\",\"26\":\"v-787d25bf\",\"27\":\"v-787d25bf#为什么要分库分表\",\"28\":\"v-787d25bf@0\",\"29\":\"v-787d25bf@1\",\"30\":\"v-09671a78\",\"31\":\"v-09671a78#优化原则\",\"32\":\"v-09671a78#排查慢查询过程\",\"33\":\"v-09671a78@0\",\"34\":\"v-09671a78@1\",\"35\":\"v-2b68b366\",\"36\":\"v-2b68b366@0\",\"37\":\"v-2b68b366@1\",\"38\":\"v-042d9c5f\",\"39\":\"v-042d9c5f#语法解析器应用场景\",\"40\":\"v-042d9c5f#语法解析原理\",\"41\":\"v-042d9c5f@0\",\"42\":\"v-042d9c5f@1\",\"43\":\"v-7276c2e1\",\"44\":\"v-7276c2e1#聚簇索引例子计算\",\"45\":\"v-7276c2e1#辅助索引例子计算\",\"46\":\"v-7276c2e1@0\",\"47\":\"v-7276c2e1@1\",\"48\":\"v-5119e92b\",\"49\":\"v-966f2e04\",\"50\":\"v-966f2e04#数组的主要优点包括\",\"51\":\"v-966f2e04#_1-直接访问\",\"52\":\"v-966f2e04#_2-灵活操作\",\"53\":\"v-966f2e04#_3-空间有效利用\",\"54\":\"v-966f2e04#数组的主要缺点包括\",\"55\":\"v-966f2e04#_1-大小固定\",\"56\":\"v-966f2e04#_2-无法插入中间元素\",\"57\":\"v-966f2e04#_3-无法删除中间元素\",\"58\":\"v-966f2e04#总结\",\"59\":\"v-966f2e04@0\",\"60\":\"v-966f2e04@1\",\"61\":\"v-1dff10ea\",\"62\":\"v-1dff10ea#旅游地点\",\"63\":\"v-1dff10ea#住宿\",\"64\":\"v-1dff10ea#出行必备\",\"65\":\"v-1dff10ea#出发前准备\",\"66\":\"v-1dff10ea#拍照点\",\"67\":\"v-1dff10ea#计划图\",\"68\":\"v-1dff10ea@0\",\"69\":\"v-1dff10ea@1\",\"70\":\"v-68c6cd2b\",\"71\":\"v-68c6cd2b#高并发定义\",\"72\":\"v-68c6cd2b#衡量高并发的指标\",\"73\":\"v-68c6cd2b#影响并发的因素\",\"74\":\"v-68c6cd2b#高并发设计-1\",\"75\":\"v-68c6cd2b#测试无缓存\",\"76\":\"v-68c6cd2b#测试2级缓存\",\"77\":\"v-68c6cd2b#测试3级缓存\",\"78\":\"v-68c6cd2b@0\",\"79\":\"v-68c6cd2b@1\",\"80\":\"v-6e83e7f2\",\"81\":\"v-6e83e7f2@0\",\"82\":\"v-6e83e7f2@1\",\"83\":\"v-07deb444\",\"84\":\"v-07deb444@0\",\"85\":\"v-07deb444@1\",\"86\":\"v-7f3bcc24\",\"87\":\"v-7f3bcc24#商品的职责有哪些\",\"88\":\"v-7f3bcc24#商品上下游模块依赖\",\"89\":\"v-7f3bcc24#商品核心功能\",\"90\":\"v-7f3bcc24#商品模型\",\"91\":\"v-7f3bcc24#搜索商品列表高性能低延时方案\",\"92\":\"v-7f3bcc24#es数据映射\",\"93\":\"v-7f3bcc24#es数据同步方案\",\"94\":\"v-7f3bcc24@0\",\"95\":\"v-7f3bcc24@1\",\"96\":\"v-ad1c3c84\",\"97\":\"v-ad1c3c84@0\",\"98\":\"v-ad1c3c84@1\",\"99\":\"v-15048e98\",\"100\":\"v-15048e98@0\",\"101\":\"v-15048e98@1\",\"102\":\"v-39f55f6b\",\"103\":\"v-39f55f6b#电商订单的职责\",\"104\":\"v-39f55f6b#核心api\",\"105\":\"v-39f55f6b#订单状态机设计\",\"106\":\"v-39f55f6b#注意的场景\",\"107\":\"v-39f55f6b#如何避免重复下单\",\"108\":\"v-39f55f6b#如何解决aba问题-网络异常情况下-请求顺序不一致导致数据错乱\",\"109\":\"v-39f55f6b@0\",\"110\":\"v-39f55f6b@1\",\"111\":\"v-3b3d9a8a\",\"112\":\"v-3b3d9a8a@0\",\"113\":\"v-3b3d9a8a@1\",\"114\":\"v-64eca334\",\"115\":\"v-64eca334@0\",\"116\":\"v-64eca334@1\",\"117\":\"v-62166cba\",\"118\":\"v-62166cba@0\",\"119\":\"v-62166cba@1\",\"120\":\"v-5b0e557c\",\"121\":\"v-5b0e557c@0\",\"122\":\"v-5b0e557c@1\",\"123\":\"v-1f90216c\",\"124\":\"v-1f90216c@0\",\"125\":\"v-1f90216c@1\",\"126\":\"v-61d2c517\",\"127\":\"v-61d2c517#算法描述\",\"128\":\"v-61d2c517#示例\",\"129\":\"v-61d2c517#复杂度分析\",\"130\":\"v-61d2c517@0\",\"131\":\"v-61d2c517@1\",\"132\":\"v-1465db28\",\"133\":\"v-1465db28@0\",\"134\":\"v-1465db28@1\",\"135\":\"v-7ab0b60a\",\"136\":\"v-7ab0b60a#基本原理\",\"137\":\"v-7ab0b60a#实现步骤\",\"138\":\"v-7ab0b60a@0\",\"139\":\"v-7ab0b60a@1\",\"140\":\"v-c5881fe4\",\"141\":\"v-c5881fe4#java实现\",\"142\":\"v-c5881fe4@0\",\"143\":\"v-c5881fe4@1\",\"144\":\"v-52f59784\",\"145\":\"v-52f59784@0\",\"146\":\"v-52f59784@1\",\"147\":\"v-4947ed96\",\"148\":\"v-4947ed96@0\",\"149\":\"v-4947ed96@1\",\"150\":\"v-ad557380\",\"151\":\"v-ad557380@0\",\"152\":\"v-ad557380@1\",\"153\":\"v-6898a9f1\",\"154\":\"v-6898a9f1#时间复杂度\",\"155\":\"v-6898a9f1#空间复杂度\",\"156\":\"v-6898a9f1#java代码实现\",\"157\":\"v-6898a9f1@0\",\"158\":\"v-6898a9f1@1\",\"159\":\"v-b8452806\",\"160\":\"v-b8452806@0\",\"161\":\"v-b8452806@1\",\"162\":\"v-011cae78\",\"163\":\"v-011cae78@0\",\"164\":\"v-011cae78@1\",\"165\":\"v-2c0e6a38\",\"166\":\"v-2c0e6a38@0\",\"167\":\"v-2c0e6a38@1\",\"168\":\"v-58784f4c\",\"169\":\"v-58784f4c#步骤\",\"170\":\"v-58784f4c#示例\",\"171\":\"v-58784f4c#时间复杂度\",\"172\":\"v-58784f4c#代码实现\",\"173\":\"v-58784f4c@0\",\"174\":\"v-58784f4c@1\",\"175\":\"v-041bbbb6\",\"176\":\"v-041bbbb6#即时模式\",\"177\":\"v-041bbbb6#保留模式\",\"178\":\"v-041bbbb6#资料\",\"179\":\"v-041bbbb6@0\",\"180\":\"v-041bbbb6@1\",\"181\":\"v-6505100f\",\"182\":\"v-6505100f@0\",\"183\":\"v-6505100f@1\",\"184\":\"v-6d027e4e\",\"185\":\"v-6d027e4e@0\",\"186\":\"v-6d027e4e@1\",\"187\":\"v-3350b3e4\",\"188\":\"v-3350b3e4@0\",\"189\":\"v-3350b3e4@1\",\"190\":\"v-b23baaca\",\"191\":\"v-b23baaca@0\",\"192\":\"v-b23baaca@1\",\"193\":\"v-500ece24\",\"194\":\"v-500ece24@0\",\"195\":\"v-500ece24@1\",\"196\":\"v-1efa0bee\",\"197\":\"v-1efa0bee@0\",\"198\":\"v-1efa0bee@1\",\"199\":\"v-486affa7\",\"200\":\"v-486affa7@0\",\"201\":\"v-486affa7@1\",\"202\":\"v-3a8a2c5c\",\"203\":\"v-3a8a2c5c@0\",\"204\":\"v-3a8a2c5c@1\",\"205\":\"v-03fa5ba6\",\"206\":\"v-03fa5ba6@0\",\"207\":\"v-03fa5ba6@1\",\"208\":\"v-fb60badc\",\"209\":\"v-fb60badc@0\",\"210\":\"v-fb60badc@1\",\"211\":\"v-3ba9eaaa\",\"212\":\"v-3ba9eaaa#线程池设计思想\",\"213\":\"v-3ba9eaaa#如何停止线程池中的线程\",\"214\":\"v-3ba9eaaa#线程池的核心参数\",\"215\":\"v-3ba9eaaa@0\",\"216\":\"v-3ba9eaaa@1\",\"217\":\"v-48ed9da9\",\"218\":\"v-48ed9da9@0\",\"219\":\"v-48ed9da9@1\",\"220\":\"v-f5756414\",\"221\":\"v-564155e4\",\"222\":\"v-0b20da1e\",\"223\":\"v-02123efe\",\"224\":\"v-2d9b4560\",\"225\":\"v-7e8da32a\",\"226\":\"v-a8417f7a\",\"227\":\"v-01b1397a\",\"228\":\"v-d0fc7660\",\"229\":\"v-29684d1b\",\"230\":\"v-461e7ade\",\"231\":\"v-595ecdf7\",\"232\":\"v-00c53a6e\",\"233\":\"v-0ef3f779\",\"234\":\"v-e7a82ed0\",\"235\":\"v-5b89fbea\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,5],\"1\":[1,1],\"2\":[1,20],\"3\":[1,84],\"4\":[null,null,1],\"5\":[null,null,1],\"6\":[1,4],\"7\":[1],\"8\":[1,3],\"9\":[1,11],\"10\":[1,1],\"11\":[1,2],\"12\":[1,5],\"13\":[1],\"14\":[1,1],\"15\":[1,2],\"16\":[1],\"17\":[1,12],\"18\":[null,null,1],\"19\":[null,null,4],\"20\":[1],\"21\":[null,null,1],\"22\":[null,null,2],\"23\":[1],\"24\":[null,null,1],\"25\":[null,null,2],\"26\":[1],\"27\":[1,34],\"28\":[null,null,1],\"29\":[null,null,2],\"30\":[1],\"31\":[1,4],\"32\":[1,7],\"33\":[null,null,1],\"34\":[null,null,2],\"35\":[1,31],\"36\":[null,null,1],\"37\":[null,null,2],\"38\":[1,19],\"39\":[1,1],\"40\":[1,1],\"41\":[null,null,1],\"42\":[null,null,2],\"43\":[1,28],\"44\":[1,21],\"45\":[1,25],\"46\":[null,null,1],\"47\":[null,null,2],\"48\":[1,42],\"49\":[1,4],\"50\":[2],\"51\":[2,4],\"52\":[2,4],\"53\":[2,4],\"54\":[2],\"55\":[2,5],\"56\":[2,5],\"57\":[2,5],\"58\":[1,4],\"59\":[null,null,1],\"60\":[null,null,2],\"61\":[1],\"62\":[1,20],\"63\":[1,2],\"64\":[1,25],\"65\":[1,32],\"66\":[1,6],\"67\":[1],\"68\":[null,null,1],\"69\":[null,null,1],\"70\":[1],\"71\":[1,9],\"72\":[1,13],\"73\":[1,15],\"74\":[1,34],\"75\":[1],\"76\":[1],\"77\":[1],\"78\":[null,null,1],\"79\":[null,null,2],\"80\":[1],\"81\":[null,null,1],\"82\":[null,null,1],\"83\":[1,2],\"84\":[null,null,1],\"85\":[null,null,3],\"86\":[1,2],\"87\":[2,16],\"88\":[1,7],\"89\":[1,4],\"90\":[1],\"91\":[1,9],\"92\":[1,6],\"93\":[1,5],\"94\":[null,null,1],\"95\":[null,null,3],\"96\":[1,12],\"97\":[null,null,1],\"98\":[null,null,3],\"99\":[1,2],\"100\":[null,null,1],\"101\":[null,null,3],\"102\":[1,2],\"103\":[1,31],\"104\":[1,9],\"105\":[1],\"106\":[1],\"107\":[2,5],\"108\":[4,6],\"109\":[null,null,1],\"110\":[null,null,3],\"111\":[1,2],\"112\":[null,null,1],\"113\":[null,null,3],\"114\":[1],\"115\":[null,null,1],\"116\":[null,null,2],\"117\":[1],\"118\":[null,null,1],\"119\":[null,null,2],\"120\":[1],\"121\":[null,null,1],\"122\":[null,null,2],\"123\":[1],\"124\":[null,null,1],\"125\":[null,null,2],\"126\":[1,10],\"127\":[1,9],\"128\":[1,46],\"129\":[1,36],\"130\":[null,null,1],\"131\":[null,null,2],\"132\":[1,31],\"133\":[null,null,1],\"134\":[null,null,4],\"135\":[1],\"136\":[1,11],\"137\":[1,52],\"138\":[null,null,1],\"139\":[null,null,2],\"140\":[1,36],\"141\":[1,63],\"142\":[null,null,1],\"143\":[null,null,2],\"144\":[1],\"145\":[null,null,1],\"146\":[null,null,2],\"147\":[1],\"148\":[null,null,1],\"149\":[null,null,2],\"150\":[1,88],\"151\":[null,null,1],\"152\":[null,null,2],\"153\":[1,6],\"154\":[1,7],\"155\":[1,7],\"156\":[1,58],\"157\":[null,null,1],\"158\":[null,null,2],\"159\":[1,8],\"160\":[null,null,1],\"161\":[null,null,2],\"162\":[1],\"163\":[null,null,1],\"164\":[null,null,2],\"165\":[1],\"166\":[null,null,1],\"167\":[null,null,2],\"168\":[1,8],\"169\":[1,11],\"170\":[1,28],\"171\":[1,7],\"172\":[1,44],\"173\":[null,null,1],\"174\":[null,null,2],\"175\":[1],\"176\":[1,8],\"177\":[1,4],\"178\":[1,17],\"179\":[null,null,1],\"180\":[null,null,1],\"181\":[1,15],\"182\":[null,null,1],\"183\":[null,null,2],\"184\":[1,1],\"185\":[null,null,1],\"186\":[null,null,2],\"187\":[1],\"188\":[null,null,1],\"189\":[null,null,2],\"190\":[1],\"191\":[null,null,1],\"192\":[null,null,2],\"193\":[1],\"194\":[null,null,1],\"195\":[null,null,2],\"196\":[1],\"197\":[null,null,1],\"198\":[null,null,3],\"199\":[1],\"200\":[null,null,1],\"201\":[null,null,3],\"202\":[1],\"203\":[null,null,1],\"204\":[null,null,3],\"205\":[1],\"206\":[null,null,1],\"207\":[null,null,2],\"208\":[1,44],\"209\":[null,null,1],\"210\":[null,null,2],\"211\":[1],\"212\":[1,37],\"213\":[1,70],\"214\":[1,25],\"215\":[null,null,1],\"216\":[null,null,2],\"217\":[1],\"218\":[null,null,1],\"219\":[null,null,1],\"220\":[2],\"221\":[1],\"222\":[4],\"223\":[1],\"224\":[1],\"225\":[1],\"226\":[1],\"227\":[1],\"228\":[1],\"229\":[1],\"230\":[1],\"231\":[1],\"232\":[1],\"233\":[1],\"234\":[1],\"235\":[1]},\"averageFieldLength\":[1.1099106976638005,15.73801001021931,1.2019651111482874],\"storedFields\":{\"0\":{\"h\":\"主页\",\"t\":[\"todo: https://java.ist`ure.com\"]},\"1\":{\"h\":\"介绍页\",\"t\":[\"这是我的个人简历\"]},\"2\":{\"h\":\"个人信息\",\"t\":[\"姓名: 苏文广 性别: 男 出生年月: 1996-12 大学: 韩山师范学院-软件工程专业(2015.9~2019.6/全日制统招本科) 手机号: 18320664028 邮箱: suveng@163.com\"]},\"3\":{\"h\":\"开发技能\",\"t\":[\"4年工作经验\",\"熟悉 Java 语言, IO,反射,SPI,jvm, java agent\",\"精通业务关系建模;能够独立设计大型复杂系统, 绘制系统架构图, UML 设计图, 精通 OKR 工作法\",\"精通 MySQL,掌握复杂 SQL 查询, 熟悉读写分离策略,主从复制策略, 熟悉常见 MySQL HA 代理方案, 熟练使用 sharding-sphere 对 MySQL 分库分表, 了解 ACID 实现原理,了解 MVCC 实现原理, 了解索引实现机制, 了解 XA 分布式事务管理\",\"熟悉 Linux 系统, 熟悉线上运维命令, 熟练 shell 脚本\",\"熟悉 Spring 全家桶, 熟悉 SpringCloud 微服务分布式架构实现,SpringBlade 脚手架\",\"掌握分布式存储设计; 熟悉 Hadoop 存储系统, 熟悉 HBase 数仓\",\"掌握分布式缓存设计; 掌握基于 Redis 的分布式缓存策略;\",\"掌握分布式调度设计; 熟练使用常见的分布式调度平台, xxl-job, schedulex\",\"掌握常见分布式事务设计, TCC 策略, Seata 架构\",\"掌握数据仓库设计, 熟练编写 Clickhouse sql 离线计算任务, Flink sql 实时计算任务\",\"掌握常见监控告警设计,熟练使用 Prometheus 系统生态\",\"了解 Vue,React 框架, 编写过数据大屏以及后台管理界面\"]},\"4\":{\"c\":[\"博主\"]},\"5\":{\"c\":[\"博主\"]},\"6\":{\"h\":\"MySQL同步数据ES\",\"t\":[\"同步双写\",\"异步双写\",\"定时任务\",\"数据订阅\"]},\"7\":{\"h\":\"同步双写\"},\"8\":{\"h\":\"优点\",\"t\":[\"简单\",\"仅需要在需要同步数据的逻辑上增加往ElasticSearch写\",\"保证实时性\"]},\"9\":{\"h\":\"缺点\",\"t\":[\"商品业务和搜索业务强耦合\",\"扩展性差\",\"需要定制搜索需求需求时, 还需要改动商品代码\",\"ElasticSearch 和 MySQL 需要额外保证一致性\",\"MySQL事务提交之后, 写入ElasticSearch出现网络异常, 那么ElasticSearch和MySQL的数据无法保证一致\"]},\"10\":{\"h\":\"异步双写\",\"t\":[\"与同步双写相比分析优缺点\"]},\"11\":{\"h\":\"优点\",\"t\":[\"解耦合; 商品本身无需关注同步ElasticSearch的逻辑\"]},\"12\":{\"h\":\"缺点\",\"t\":[\"准实时, 存在MQ延迟\",\"需要考虑额外组件的可靠性, Kafka, 搜索服务\"]},\"13\":{\"h\":\"定时任务\"},\"14\":{\"h\":\"优点\",\"t\":[\"简单\"]},\"15\":{\"h\":\"缺点\",\"t\":[\"无法保证实时性\",\"保证实时性主要依赖于搜索服务的定时间隔\"]},\"16\":{\"h\":\"数据订阅\"},\"17\":{\"h\":\"优点\",\"t\":[\"解耦合\",\"利用canal订阅MySQL的binlog做到解耦合\",\"无业务侵入\",\"利用canal组件即可无需在商品代码上做改动\",\"准实时\",\"只存在binlog和业务回查的延迟\",\"良好的扩展行\",\"canal组件还支持各种数据库/客户端的写入适配器, 可以实现不同的数据写入需求, 例如 HBase\"]},\"18\":{\"c\":[\"ElasticSearch\"]},\"19\":{\"c\":[\"ElasticSearch\",\"MySQL\",\"Java\",\"方案\"]},\"20\":{\"h\":\"MySQL主从复制\"},\"21\":{\"c\":[\"MySQL\"]},\"22\":{\"c\":[\"MySQL\",\"Java\"]},\"23\":{\"h\":\"MySQL事务\"},\"24\":{\"c\":[\"MySQL\"]},\"25\":{\"c\":[\"MySQL\",\"Java\"]},\"26\":{\"h\":\"MySQL分库分表\"},\"27\":{\"h\":\"为什么要分库分表\",\"t\":[\"需要分库分表的情况无非是数据库性能无法满足业务要求;\",\"读慢\",\"数据量过大,导致InnoDB的存储文件<表名>.ibd过大, MySQL需要先将ibd文件读取到内存中进行查找,然后将数据返回给客户端\",\"磁盘IO可能成为瓶颈, 读取文件\",\"CPU内存查找可能成为瓶颈, 查找\",\"网络传输可能成为瓶颈\",\"写慢\",\"数据量过大,导致InnoDB的存储文件<表名>.ibd过大, MySQL需要先将ibd文件读取到内存中进行查找写入位置, 然后将数据写入, 如果写不会导致B+树结构变化, 那么是用乐观锁写入, 如果写入数据会导致B+树的索引结构变化(新增页),那么是分段悲观锁写入的方式, 这种方式是串行的;\",\"磁盘IO可能成为瓶颈, 读取文件, 写入文件(新增页)\",\"CPU内存查找\",\"网络传输可能成为瓶颈\",\"读写锁机制更新索引B+树 总结下来, 其实更多是写锁导致的并发性能问题\",\"并发慢\",\"但数据库的连接数却是有限的，在高并发场景下多个业务同时对一个数据库操作，很容易将连接数耗尽导致too many connections报错，导致后续数据库无法正常访问。\"]},\"28\":{\"c\":[\"MySQL\"]},\"29\":{\"c\":[\"MySQL\",\"Java\"]},\"30\":{\"h\":\"MySQL慢查询优化\"},\"31\":{\"h\":\"优化原则\",\"t\":[\"最左前缀匹配原则\",\"选择区分度高的列作为索引\",\"索引列不参与计算\",\"尽量扩展索引\"]},\"32\":{\"h\":\"排查慢查询过程\",\"t\":[\"找到耗时较长的SQL语句\",\"使用explain语句解析SQL执行计划\",\"排查执行计划中是否有全表扫描的情况\",\"排查执行计划中扫描行数较多的查询语句\",\"制定方案优化SQL\",\"如果实在无法优化, 看看是否折中的方案实现业务\"]},\"33\":{\"c\":[\"MySQL\"]},\"34\":{\"c\":[\"MySQL\",\"Java\"]},\"35\":{\"h\":\"MySQL的SQL执行过程\",\"t\":[\"这是MySQL架构组件执行流程, 最后交给存储引擎执行SQL;\",\"InnoDB存储引擎执行过程\",\"这是InnoDB的写入操作流程 其中 redo log 时 InnoDB 特有的组件 binlog 时 MySQL 本身的组件\",\"redo log 的 作用\",\"实现持久性和一致性\",\"由于数据的更新操作都是在内存发生的, 那么如果断电后, 如何保证内存的数据和磁盘的数据一致性, 那么redo log 的作用就是用来保证磁盘和内存数据的一致性;\\n假设数据在提交事务后, redo log 只存在内存, 还没有落入磁盘中, 这个时候发生了断电, 磁盘的数据是落后于内存的数据的, 那么断电恢复后, InnoDB会从redo log 中恢复BufferPool的环境, 这个时候再将差异的数据写入磁盘中, 保证了持久性和一致性\"]},\"36\":{\"c\":[\"MySQL\"]},\"37\":{\"c\":[\"MySQL\",\"Java\"]},\"38\":{\"h\":\"MySQL的语法解析器\",\"t\":[\"SQL本身是一种程序语言, 语言最终会被编译成指令在程序中运行;\",\"那么语言本身是可以被解析, 对应的解析器有哪些实现\",\"MySQL源码的解析器\",\"由专门的公司维护 SQL Parser, https://www.sqlparser.com/\",\"开源的SQL解析器\",\"美团开源的SQL Advisor https://github.com/Meituan-Dianping/SQLAdvisor\"]},\"39\":{\"h\":\"语法解析器应用场景\",\"t\":[\"SQL分析监控\"]},\"40\":{\"h\":\"语法解析原理\",\"t\":[\"构建语法树\"]},\"41\":{\"c\":[\"MySQL\"]},\"42\":{\"c\":[\"MySQL\",\"Java\"]},\"43\":{\"h\":\"MySQL索引B+树高度计算\",\"t\":[\"总记录数 N\",\"记录大小 k Byte\",\"索引大小 x Byte\",\"数据库指针大小 6 Byte\",\"数据库页大小 16KB\",\"从底往上计算高度\",\"叶子节点存放数据\",\"一个叶子节点存放数据量 c = 16 * 1024 / k\",\"一个非叶子节点存放叶子节点数量 b = 16 * 1024 / (x + 6)\",\"总页数 p = N / c\",\"索引的高度 h = log(p,b)\",\"树高 = h + 1\"]},\"44\":{\"h\":\"聚簇索引例子计算\",\"t\":[\"总记录N = 20,000,000\",\"记录大小k = 1024\",\"索引大小x = 8\",\"总页数p = 1250000\",\"索引数b = 1170\",\"索引树高log(p,b) = 2\",\"树高 = 3\",\"总结, 2千万的数据,B+树的高度为3\"]},\"45\":{\"h\":\"辅助索引例子计算\",\"t\":[\"辅助索引的叶子节点存放的事主键值, 辅助索引找到主键, 通过主键去聚簇索引查找记录\",\"辅助索引最大是256Byte\",\"总记录N = 20,000,000\",\"记录大小k = 8\",\"索引大小x = 256\",\"总页数p = 9765\",\"索引数b = 62\",\"索引树高log(p,b) = 3\",\"树高 = 4\",\"总结, 2千万的数据,辅助索引B+树的高度为4\"]},\"46\":{\"c\":[\"MySQL\"]},\"47\":{\"c\":[\"MySQL\",\"Java\"]},\"48\":{\"h\":\"函数\",\"t\":[\"setup\",\"初始化组件函数, 暴露数据和方法\",\"ref\",\"响应式操作数据,修改数据, 视图改变, 推荐用来操作基础数据\",\"reactive\",\"响应式操作数据,修改数据, 视图改变, 只能操作复杂数据对象\",\"toRef\",\"响应式操作数据,修改数据, 视图不改变, 源数据改变\",\"toRefs\",\"暴露对象里面的字段\",\"computed计算属性\",\"监听器 watch\",\"watchEffect\",\"shallowRef shallowReactive\",\"组件传值\",\"provide 传\",\"inject 接\",\"vuex\",\"生命周期\",\"https://www.javalc.com/post/24.html\\nhttps://blog.csdn.net/supming1/article/details/121267418\"]},\"49\":{\"h\":\"数组\",\"t\":[\"数组是一种线性数据结构，它由一组连续的内存空间组成，用于存储同一类型的数据元素。\"]},\"50\":{\"h\":\"数组的主要优点包括：\"},\"51\":{\"h\":\"1. 直接访问\",\"t\":[\"可以通过索引直接访问数组中的元素，时间复杂度为O(1)。\"]},\"52\":{\"h\":\"2. 灵活操作\",\"t\":[\"可以通过索引对数组中的元素进行增加、删除、修改等操作。\"]},\"53\":{\"h\":\"3. 空间有效利用\",\"t\":[\"在创建数组时，会预分配足够的内存空间用于存储元素，可以有效利用内存空间。\"]},\"54\":{\"h\":\"数组的主要缺点包括：\"},\"55\":{\"h\":\"1. 大小固定\",\"t\":[\"数组的大小在创建时就需要确定，并且不能动态改变，如果需要存储更多的元素，需要重新创建一个更大的数组。\"]},\"56\":{\"h\":\"2. 无法插入中间元素\",\"t\":[\"如果需要在数组的中间插入元素，需要将后面的元素都向后移动一位，时间复杂度为O(n)。\"]},\"57\":{\"h\":\"3. 无法删除中间元素\",\"t\":[\"如果需要删除数组中的中间元素，需要将后面的元素都向前移动一位，时间复杂度为O(n)。\"]},\"58\":{\"h\":\"总结\",\"t\":[\"综上所述，数组适用于元素数量固定且需要直接访问的场景，但是不适用于需要动态增加或删除元素的场景。\"]},\"59\":{\"c\":[\"数据结构\"]},\"60\":{\"c\":[\"数据结构\",\"数组\"]},\"61\":{\"h\":\"长沙旅游\"},\"62\":{\"h\":\"旅游地点\",\"t\":[\"橘子洲\",\"五一广场\",\"黄兴步行街\",\"坡子街\",\"岳麓山\",\"爱晚亭\",\"岳麓书院\",\"湖南大学\",\"开福寺\",\"杜甫江阁\",\"太平街\",\"苏家巷\",\"东瓜山\",\"潮宗街\",\"IFS国金中心\",\"丰盈西里\",\"四方坪夜市\",\"文和友\",\"后湖\",\"杨帆夜市\"]},\"63\":{\"h\":\"住宿\",\"t\":[\"长沙雅士亚豪生酒店\",\"湖南省查杀是雨花区韶山北路258号\"]},\"64\":{\"h\":\"出行必备\",\"t\":[\"1、乘车码：下载“长沙地铁”，公交地铁都需要。\",\"2、证件：身份证、学生证等优惠证件\",\"3、必备物：晴雨伞(必备)、口罩(多带)、纸巾、创口贴、充电宝、驱蚊液、相机、自拍杆、薄外套、便携小风扇、防晒霜、鞋子\"]},\"65\":{\"h\":\"出发前准备\",\"t\":[\"预约景点\",\"景点\",\"门票\",\"开放时间\",\"预约\",\"交通\",\"橘子洲\",\"免费\",\"7:00 ~ 22:00\",\"提前三天预约,岳麓山橘子洲旅游区公众号\",\"地铁2号线橘子洲\",\"岳麓山\",\"免费\",\"6:00 ~ 23:00\",\"提前三天预约,岳麓山橘子洲旅游区公众号\",\"地铁2/4号线荣湾镇\",\"杜甫江阁\",\"11块\",\"9:00 ~ 21:30\",\"提前三天预约,杜甫江阁公众号\",\"地铁2号线湘江中路\",\"岳麓书院\",\"40块\",\"7:30 ~ 18:00\",\"提前三天预约,岳麓书院公众号\",\"地铁4号线湖南大学\"]},\"66\":{\"h\":\"拍照点\",\"t\":[\"拍照点\",\"梅溪湖中国结桥\",\"梅溪湖文化艺术中心\",\"碧沙湖地铁站5号口\",\"解放西路和福胜路正路口太平街牌牌坊的斜对面华远云玺前坪\",\"碧沙湖地铁站5号口\",\"望江亭\"]},\"67\":{\"h\":\"计划图\"},\"68\":{\"c\":[\"旅游\"]},\"69\":{\"c\":[\"旅游\"]},\"70\":{\"h\":\"高并发设计\"},\"71\":{\"h\":\"高并发定义\",\"t\":[\"高并发是指在一定时间内，大量的请求同时访问应用程序或系统，导致系统出现性能瓶颈，如响应时间变慢、服务不可用等问题。\",\"高并发通常出现在促销活动、秒杀场景、网站流量高峰期等情况下。\"]},\"72\":{\"h\":\"衡量高并发的指标\",\"t\":[\"响应时间(RT)\",\"并发数(QPS)\",\"请求成功率(成功数/总数)\",\"资源利用率 \",\"CPU\",\"内存\",\"IO\",\"JVM GC\"]},\"73\":{\"h\":\"影响并发的因素\",\"t\":[\"硬件 \",\"CPU\",\"内存\",\"磁盘\",\"软件架构 \",\"单体架构\",\"分布式架构\",\"数据库 \",\"MySQL\",\"Redis\",\"网络 \",\"带宽, 上行速率/下行速率\",\"程序代码\"]},\"74\":{\"h\":\"高并发设计\",\"t\":[\"如果设计一个高并发的系统, 考虑的因素比较多, 这里用控制变量法去控制其他因素保持不变, 只看程序代码的方式, 设计一个高并发的程序\",\"硬件固定\",\"4c8G的硬件\",\"软件架构固定\",\"使用单体架构, 测试单体的并发性能可以粗略估算水平扩容的分布式架构的性能; 当然, 具体分布式架构下的并发性能还是需要测试, 但是这里为了测试方便才使用单体架构\",\"数据库固定\",\"固定使用MySQL和Redis\",\"网络固定\",\"本地网络, 家庭网络的路由大概是千兆网, 这里网络不会成为卡点\",\"编程语言固定\",\"Java\",\"改变程序代码(库存接口)\",\"仅使用MySQL 无缓存 (MySQL的缓存忽略不计)\",\"MySQL + Redis 2级缓存\",\"MySQL + Redis + 内存 3级缓存\",\"以上三种迭代的方式, 测试并发性能\"]},\"75\":{\"h\":\"测试无缓存\"},\"76\":{\"h\":\"测试2级缓存\"},\"77\":{\"h\":\"测试3级缓存\"},\"78\":{\"c\":[\"架构\"]},\"79\":{\"c\":[\"架构\",\"并发\"]},\"80\":{\"h\":\"电商业务流程时序\"},\"81\":{\"c\":[\"电商\"]},\"82\":{\"c\":[\"电商\"]},\"83\":{\"h\":\"电商售后设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"84\":{\"c\":[\"电商\"]},\"85\":{\"c\":[\"电商\",\"方案\",\"Java\"]},\"86\":{\"h\":\"电商商品设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"87\":{\"h\":\"商品的职责有哪些?\",\"t\":[\"商品来源 \",\"企业生产(自产自销) : 一般是有自己的供应链,公司内部记录和管理\",\"企业采购(B2B) : 从外部企业渠道采购到公司内部, 并由公司内部记录和管理\",\"企业回收(C2B) : 从个人手中回收商品, 并有公司内部记录和管理\",\"商品规格\",\"商品描述\",\"商品定价\"]},\"88\":{\"h\":\"商品上下游模块依赖\",\"t\":[\"供应链模块(商品来源)\",\"订单模块(商品售卖)\",\"物流模块(商品物流)\"]},\"89\":{\"h\":\"商品核心功能\",\"t\":[\"录入商品\",\"搜索商品列表\",\"查询商品详情\",\"更新库存\"]},\"90\":{\"h\":\"商品模型\"},\"91\":{\"h\":\"搜索商品列表高性能低延时方案\",\"t\":[\"使用ElasticSearch作为搜索引擎\",\"搜索相关度排序\",\"商品类目\",\"商品标签\",\"商品标题\",\"商品副标题\",\"商品描述\",\"规格描述\",\"热卖商品\"]},\"92\":{\"h\":\"ES数据映射\",\"t\":[\"ES需要对以下数据做映射\",\"商品 \",\"商品类目\",\"商品标签\",\"商品规格\",\"订单\"]},\"93\":{\"h\":\"ES数据同步方案\",\"t\":[\"MySQL同步数据ES.md\",\"通过上面文章的方案比较, 最终选用数据订阅方式,进行ES数据同步\"]},\"94\":{\"c\":[\"电商\"]},\"95\":{\"c\":[\"电商\",\"Java\",\"方案\"]},\"96\":{\"h\":\"电商搜索设计方案\",\"t\":[\"电商业务流程时序.md\",\"https://zq99299.github.io/note-book/back-end-storage/\"]},\"97\":{\"c\":[\"电商\"]},\"98\":{\"c\":[\"电商\",\"Java\",\"方案\"]},\"99\":{\"h\":\"电商支付设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"100\":{\"c\":[\"电商\"]},\"101\":{\"c\":[\"电商\",\"Java\",\"方案\"]},\"102\":{\"h\":\"电商订单设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"103\":{\"h\":\"电商订单的职责\",\"t\":[\"电商订单是记录电商平台上的交易信息的重要数据实体，包括订单号、商品信息、收货地址、支付信息等。\",\"电商订单具有以下职责： \",\"记录并管理交易信息：电商订单负责记录和管理商品信息、支付信息、物流信息等交易相关数据。\",\"控制交易流程：电商订单可以根据订单状态控制交易流程，如待支付、已支付、待发货、已发货、已完成等。\",\"支持订单查询和统计：电商订单可以提供订单查询和统计功能，以便用户和商家进行订单管理、交易分析等操作。\",\"支持订单修改和取消：电商订单可以支持用户和商家对订单进行修改和取消操作，以满足不同业务场景的需求。\",\"保证订单安全和隐私：电商订单需要采取相应的安全措施，确保订单信息的安全性和隐私性。\",\"电商订单的实现可以采用数据库存储、API接口调用等方式，具体的实现方式根据业务需求和系统架构进行选择。\"]},\"104\":{\"h\":\"核心API\",\"t\":[\"生成订单id();\",\"创建订单();\",\"取消订单();\",\"支付订单();\",\"发货();\",\"签收();\",\"评价();\",\"完成();\"]},\"105\":{\"h\":\"订单状态机设计\"},\"106\":{\"h\":\"注意的场景\"},\"107\":{\"h\":\"如何避免重复下单?\",\"t\":[\"首先,生成订单ID; 然后,使用订单ID作为幂等标识下单;\"]},\"108\":{\"h\":\"如何解决ABA问题? (网络异常情况下, 请求顺序不一致导致数据错乱)\",\"t\":[\"版本号的乐观锁机制\",\"查询接口将版本返回给调用方\",\"调用方将版本号作为参数给接口, 当版本一致的时候更新数据, 不一致不更新, 提示用户刷新页面\"]},\"109\":{\"c\":[\"电商\"]},\"110\":{\"c\":[\"电商\",\"Java\",\"方案\"]},\"111\":{\"h\":\"电商购物车方案\",\"t\":[\"电商业务流程时序.md\"]},\"112\":{\"c\":[\"电商\"]},\"113\":{\"c\":[\"电商\",\"Java\",\"方案\"]},\"114\":{\"h\":\"Gossip一致性算法\"},\"115\":{\"c\":[\"算法\"]},\"116\":{\"c\":[\"算法\",\"一致性\"]},\"117\":{\"h\":\"Paxos一致性算法\"},\"118\":{\"c\":[\"算法\"]},\"119\":{\"c\":[\"算法\",\"一致性\"]},\"120\":{\"h\":\"Raft一致性算法\"},\"121\":{\"c\":[\"算法\"]},\"122\":{\"c\":[\"算法\",\"一致性\"]},\"123\":{\"h\":\"ZAB一致性算法\"},\"124\":{\"c\":[\"算法\"]},\"125\":{\"c\":[\"算法\",\"一致性\"]},\"126\":{\"h\":\"冒泡排序\",\"t\":[\"冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\"]},\"127\":{\"h\":\"算法描述\",\"t\":[\"从数列中挑出最小（大）元素，依次放到数列的起始位置；\",\"再从剩下的元素中挑出最小（大）元素，放到已排序序列的末尾；\",\"重复步骤2，直到所有元素排序完成。\"]},\"128\":{\"h\":\"示例\",\"t\":[\"对数列 {5, 3, 8, 6, 4} 进行冒泡排序：\",\"第一轮：\",\"比较5和3，发现5>3，交换位置，数列变成 {3, 5, 8, 6, 4}；\",\"比较5和8，发现5<8，位置不变，数列还是 {3, 5, 8, 6, 4}；\",\"比较8和6，发现8>6，交换位置，数列变成 {3, 5, 6, 8, 4}；\",\"比较8和4，发现8>4，交换位置，数列变成 {3, 5, 6, 4, 8}； 第一轮结束，此时最大元素8已经排好序，接下来对剩下的数列 {3, 5, 6, 4} 进行冒泡排序。\",\"第二轮：\",\"比较3和5，发现3<5，位置不变，数列还是 {3, 5, 6, 4}；\",\"比较5和6，发现5<6，位置不变，数列还是 {3, 5, 6, 4}；\",\"比较6和4，发现6>4，交换位置，数列变成 {3, 5, 4, 6}； 第二轮结束，此时次大元素6已经排好序，剩下的数列 {3, 5, 4} 继续冒泡排序。\",\"第三轮：\",\"比较3和5，发现3<5，位置不变，数列还是 {3, 5, 4}；\",\"比较5和4，发现5>4，交换位置，数列变成 {3, 4, 5}； 第三轮结束，此时第三大元素5已经排好序，剩下的数列 {3, 4} 继续冒泡排序。\",\"第四轮：\",\"比较3和4，发现3<4，位置不变，数列还是 {3, 4}； 第四轮结束，此时最小元素3已经排好序，整个数列排序完成。\"]},\"129\":{\"h\":\"复杂度分析\",\"t\":[\"最好情况：当数组已经按照排序需求排好时，只需进行一次遍历，时间复杂度为O(n)；\",\"最坏情况：当数组是逆序排列时，需要进行n-1次遍历，时间复杂度为O(n^2)；\",\"平均情况：需要进行n-1次遍历，时间复杂度为O(n^2)。\",\"冒泡排序是一种稳定的排序算法。\",\"public class bubbleSort { public static void bubbleSort(int[] arr) { int n = arr.length; for (int i = 0; i < n-1; i++) { for (int j = 0; j < n-i-1; j++) { if (arr[j] > arr[j+1]) { // 交换arr[j]和arr[j+1] int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } } } \"]},\"130\":{\"c\":[\"算法\"]},\"131\":{\"c\":[\"算法\",\"排序\"]},\"132\":{\"h\":\"双指针\",\"t\":[\"双指针算法（Two-Pointers Algorithm）是一种常见的算法思想，通常用于解决数组或链表相关的问题。该算法通过使用两个指针，分别从数组或链表的两端向中间移动，从而解决问题。 双指针算法通常可以分为两种情况：\",\"从数组的两端向中间移动的双指针算法： 这种情况下，我们通常使用两个指针从数组的两端同时开始遍历，然后根据具体的问题来决定两个指针的移动方式。这种算法通常用于解决一些查找或筛选的问题，例如查找两个数的和等于目标值、查找数组中的环形子数组等。\",\"从数组的一端向另一端移动的双指针算法： 这种情况下，我们通常使用两个指针，一个指向数组的起始位置，另一个从起始位置开始向后遍历。这种算法通常用于解决一些排序或统计的问题，例如验证只包含相同字符的最长子串、统计数组中元素出现次数等。\",\"使用双指针算法可以有效地提高解决数组或链表相关问题的效率，因为双指针同时进行遍历，可以将时间复杂度从O(n^2)降低到O(n)。\"]},\"133\":{\"c\":[\"算法\"]},\"134\":{\"c\":[\"算法\",\"双指针\",\"数组\",\"链表\"]},\"135\":{\"h\":\"基数排序\"},\"136\":{\"h\":\"基本原理\",\"t\":[\"基数排序是一种非比较性的排序算法。基数排序的基本思想是：将整数按位数划分为不同的桶，然后按每个位数分别对桶中的元素进行排序，最终将所有位数上的排序结果合并在一起，得到最终的排序结果。\",\"基数排序的时间复杂度为O(dn)，其中d是数字的最大位数，n是待排序元素个数。\"]},\"137\":{\"h\":\"实现步骤\",\"t\":[\"基数排序的实现步骤如下：\",\"获取待排序数组中的最大值，确定最大位数d。\",\"对最末位进行排序，使用计数排序算法对每个数字出现的次数进行统计。\",\"基于计数排序的结果，依次确定每个数字在有序数组中的位置。\",\"将有序数组重新赋值给原数组。\",\"依次对每一位进行排序，直到最高位。\",\"public class radixSort { public static void radixSort(int[] arr) { if (arr == null || arr.length <= 1) { return; } // 获取最大值的位数 int maxNum = arr[0]; for (int i = 1; i < arr.length; i++) { if (arr[i] > maxNum) { maxNum = arr[i]; } } int placeValue = 1; // 当前位的权值 while (maxNum / placeValue > 0) { countingSort(arr, placeValue); placeValue *= 10; } } private static void countingSort(int[] arr, int placeValue) { int[] count = new int[10]; int radix = 10; for (int i = 0; i < arr.length; i++) { int digit = (arr[i] / radix) % 10; count[digit]++; } for (int i = 1; i < count.length; i++) { count[i] += count[i - 1]; } int[] output = new int[arr.length]; for (int i = arr.length - 1; i >= 0; i--) { int digit = (arr[i] / radix) % 10; int index = count[digit] - 1; output[index] = arr[i]; count[digit]--; } System.arraycopy(output, 0, arr, 0, arr.length); } } \"]},\"138\":{\"c\":[\"算法\"]},\"139\":{\"c\":[\"算法\",\"排序\"]},\"140\":{\"h\":\"堆排序\",\"t\":[\"堆排序（Heap Sort）是利用堆（Heap）这种数据结构进行选择排序的一种算法。堆是一个可以推导具有最大或最小值的树形结构，堆排序利用堆的特性进行排序。\",\"堆排序分为两个步骤：\",\"建堆（Build Heap）：将一个无序的数组构建成一个大顶堆（Max Heap）。大顶堆的特点是父节点的值大于或等于其子节点的值。建堆的过程从数组的最后一个非叶子节点开始，依次向上调整每个节点，使其满足大顶堆的特性。\",\"排序（Sort）：重复执行以下步骤，直到堆的大小为1：\",\"将堆中的最大元素（根节点）与堆的最后一个元素交换。\",\"将堆的大小减1。\",\"对堆进行调整，使其重新成为一个大顶堆。\",\"重复上述步骤，每次取出的都是当前堆中的最大元素，最终得到的数组就是一个有序的数组。\",\"堆排序的时间复杂度为O(nlogn)，空间复杂度为O(1)。由于堆排序是一种不稳定的排序算法，因此在需要保持相同元素的原始顺序时应谨慎使用。\",\"以下是堆排序的示例代码：\"]},\"141\":{\"h\":\"Java实现\",\"t\":[\"public class HeapSort { public static void sort(int[] arr) { int n = arr.length; // 构建大顶堆 for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i); // 排序 for (int i = n - 1; i >= 0; i--) { // 将当前堆中的最大元素与堆的最后一个元素交换 swap(arr, 0, i); // 对交换后的元素进行调整，重新成为一个大顶堆 heapify(arr, i, 0); } } // 调整堆，使其重新成为一个大顶堆 static void heapify(int[] arr, int n, int i) { int largest = i; // 初始化largest为当前节点 int left = 2 * i + 1; // 左子节点 int right = 2 * i + 2; // 右子节点 // 如果左子节点比当前节点大，则更新largest为左子节点 if (left < n && arr[left] > arr[largest]) largest = left; // 如果右子节点比当前节点大，则更新largest为右子节点 if (right < n && arr[right] > arr[largest]) largest = right; // 如果largest不是当前节点，则将largest与当前节点交换，并递归调整堆 if (largest != i) { swap(arr, i, largest); heapify(arr, n, largest); } } // 交换数组中的两个元素 static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } // 测试 public static void main(String[] args) { int[] arr = { 12, 11, 13, 5, 6, 7 }; sort(arr); System.out.println(\\\"排序后的数组：\\\"); for (int num : arr) System.out.print(num + \\\" \\\"); } } \"]},\"142\":{\"c\":[\"算法\"]},\"143\":{\"c\":[\"算法\",\"排序\"]},\"144\":{\"h\":\"希尔排序\"},\"145\":{\"c\":[\"算法\"]},\"146\":{\"c\":[\"算法\",\"排序\"]},\"147\":{\"h\":\"归并排序\"},\"148\":{\"c\":[\"算法\"]},\"149\":{\"c\":[\"算法\",\"排序\"]},\"150\":{\"h\":\"快速排序\",\"t\":[\"快速排序是一种常用的排序算法，采用分治法（Divide and Conquer）的思想。它的基本步骤如下：\",\"从数列中挑出一个元素，称为“基准”（pivot）。\",\"将所有比基准值小的元素都放在基准前面，比基准值大的元素都放在基准的后面（相同的数可以放在任一边）。在这个分区退出之后，该基准就处于数列的中间位置。\",\"对基准的左右两个分区重复步骤1和步骤2。 快速排序的关键步骤是基准的选取，不同的选取方法会影响排序的效率。通常有以下几种选取方法： \",\"选取第一个元素作为基准\",\"选取最后一个元素作为基准\",\"选取中间元素作为基准\",\"从数列中随机选取一个元素作为基准\",\"快速排序的时间复杂度为O(nlogn)，但在最坏情况下时间复杂度为O(n^2)。为了避免最坏情况的发生，可以采用随机选取基准、三数中值法选取基准等优化方法。\",\"public class QuickSort { /* * 快速排序 * * 参数说明： * a -- 待排序的数组 * l -- 数组的左边界(例如，从起始位置开始排序，则l=0) * r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1) */ public static void quickSort(int[] a, int l, int r) { if (l < r) { int i,j,x; i = l; j = r; x = a[i]; while (i < j) { while(i < j && a[j] > x) j--; // 从右向左找第一个小于x的数 if(i < j) a[i++] = a[j]; while(i < j && a[i] < x) i++; // 从左向右找第一个大于x的数 if(i < j) a[j--] = a[i]; } a[i] = x; quickSort(a, l, i-1); /* 递归调用 */ quickSort(a, i+1, r); /* 递归调用 */ } } public static void main(String[] args) { int i; int a[] = {30,40,60,10,20,50}; System.out.printf(\\\"before sort:\\\"); for (i=0; i<a.length; i++) System.out.printf(\\\"%d \\\", a[i]); System.out.printf(\\\"\\\\n\\\"); quickSort(a, 0, a.length-1); System.out.printf(\\\"after sort:\\\"); for (i=0; i<a.length; i++) System.out.printf(\\\"%d \\\", a[i]); System.out.printf(\\\"\\\\n\\\"); } } \"]},\"151\":{\"c\":[\"算法\"]},\"152\":{\"c\":[\"算法\",\"排序\"]},\"153\":{\"h\":\"插入排序\",\"t\":[\"插入排序是一种简单直观的排序算法。它的基本思想是通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\"]},\"154\":{\"h\":\"时间复杂度\",\"t\":[\"在最坏的情况下，插入排序需要O(n^2)的时间复杂度和O(1)的空间复杂度。\"]},\"155\":{\"h\":\"空间复杂度\",\"t\":[\"在最好情况下，插入排序需要O(n)的时间复杂度和O(1)的空间复杂度。\"]},\"156\":{\"h\":\"Java代码实现\",\"t\":[\"/** * 插入排序(Insertion Sort)是一种简单直观的排序算法。 * 插入排序的工作原理是：通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 * * 在最好情况下，插入排序的效率为O(n)，对应的序列是已排序的； * 在最坏情况下，插入排序的时间复杂度为O(n^2)，对应的序列是逆序的。 * * 代码的执行步骤： * 1. 从第一个元素开始，该元素可以认为已经被排序； * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描； * 3. 如果该元素（已排序）大于新元素，将该元素移动到下一位置； * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； * 5. 将新元素插入到该位置后； * 6. 重复步骤2~5。 */ public class InsertionSort { public static void sort(int[] array) { int n = array.length; for (int i = 1; i < n; i++) { int key = array[i]; int j = i - 1; while (j >= 0 && array[j] > key) { array[j + 1] = array[j]; j--; } array[j + 1] = key; } } } \"]},\"157\":{\"c\":[\"算法\"]},\"158\":{\"c\":[\"算法\",\"排序\"]},\"159\":{\"h\":\"斐波那契数列问题\",\"t\":[\"数学公式如下:\",\"f(n)=⎩⎨⎧​01f(n−1)+f(n−2)​n=0n=1n>=1​​​\"]},\"160\":{\"c\":[\"算法\"]},\"161\":{\"c\":[\"算法\",\"斐波那契数列\"]},\"162\":{\"h\":\"桶排序\"},\"163\":{\"c\":[\"算法\"]},\"164\":{\"c\":[\"算法\",\"排序\"]},\"165\":{\"h\":\"计数排序\"},\"166\":{\"c\":[\"算法\"]},\"167\":{\"c\":[\"算法\",\"排序\"]},\"168\":{\"h\":\"选择排序\",\"t\":[\"选择排序是一种简单直观的排序算法。它的基本思想是：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\"]},\"169\":{\"h\":\"步骤\",\"t\":[\"选择排序的算法步骤如下：\",\"在待排序的元素中，找到最小（大）的元素，将其与第一个元素交换位置。\",\"在剩下的元素中，找到最小（大）的元素，将其与第二个元素交换位置。\",\"重复上述步骤，直到所有元素均排序完毕。\"]},\"170\":{\"h\":\"示例\",\"t\":[\"给定数组 [3, 4, 2, 1, 5]，按升序排序。\",\"第一次遍历，找到最小元素 1，与第一个元素 3 交换位置，数组变为 [1, 4, 2, 3, 5]。\",\"第二次遍历，忽略第一个元素，找到最小元素 2，与第二个元素 4 交换位置，数组变为 [1, 2, 4, 3, 5]。\",\"第三次遍历，忽略前两个元素，找到最小元素 3，与第三个元素 4 交换位置，数组变为 [1, 2, 3, 4, 5]。\",\"第四次遍历，忽略前三个元素，找到最小元素 4，与第四个元素 4 交换位置，数组保持不变 [1, 2, 3, 4, 5]。\",\"第五次遍历，忽略前四个元素，找到最小元素 5，与第五个元素 5 交换位置，数组保持不变 [1, 2, 3, 4, 5]。\",\"最终得到的数组为 [1, 2, 3, 4, 5]，即为按升序排序后的结果。\"]},\"171\":{\"h\":\"时间复杂度\",\"t\":[\"选择排序的时间复杂度为 O(n^2)，其中 n 是待排序数组的长度。\"]},\"172\":{\"h\":\"代码实现\",\"t\":[\"下面是使用 Java 实现选择排序的示例代码：\",\"public class SelectionSort { public static void main(String[] args) { int[] arr = {3, 4, 2, 1, 5}; selectionSort(arr); System.out.println(Arrays.toString(arr)); // 输出：[1, 2, 3, 4, 5] } public static void selectionSort(int[] arr) { int n = arr.length; // 遍历数组 for (int i = 0; i < n-1; i++) { int minIndex = i; // 寻找最小元素的索引 for (int j = i+1; j < n; j++) { if (arr[j] < arr[minIndex]) { minIndex = j; } } // 交换最小元素与当前元素的位置 int temp = arr[minIndex]; arr[minIndex] = arr[i]; arr[i] = temp; } } } \",\"以上代码实现了选择排序的排序算法和排序结果的输出。\"]},\"173\":{\"c\":[\"算法\"]},\"174\":{\"c\":[\"算法\",\"排序\"]},\"175\":{\"h\":\"GUI渲染模式\"},\"176\":{\"h\":\"即时模式\",\"t\":[\"每次渲染都立即重新绘制, 每一帧都会消耗CPU和GPU资源\",\"适用于动态元素渲染, 比如 实时图表，动画，特效，游戏等\"]},\"177\":{\"h\":\"保留模式\",\"t\":[\"每次渲染的是需要改变的元素, 不会重新绘制, 但是需要记录状态, 所以消耗内存\"]},\"178\":{\"h\":\"资料\",\"t\":[\"https://learn.microsoft.com/zh-cn/windows/win32/learnwin32/retained-mode-versus-immediate-mode\",\"https://zhuanlan.zhihu.com/p/534695668\"]},\"179\":{\"c\":[\"记录\"]},\"180\":{\"c\":[\"GUI\"]},\"181\":{\"h\":\"免费中文字体文件下载\",\"t\":[\"以下是收录免费中问字体的github仓库\",\"https://github.com/zenozeng/Free-Chinese-Fonts?tab=readme-ov-file\",\"https://drxie.github.io/OSFCC/\"]},\"182\":{\"c\":[\"记录\"]},\"183\":{\"c\":[\"字体\",\"ttf\"]},\"184\":{\"h\":\"记录搭建VuePress博客\",\"t\":[\"VuePress\"]},\"185\":{\"c\":[\"博客\"]},\"186\":{\"c\":[\"VuePress\",\"博客\"]},\"187\":{\"h\":\"JVM内存模型\"},\"188\":{\"c\":[\"Java\"]},\"189\":{\"c\":[\"Java\",\"jvm\"]},\"190\":{\"h\":\"JVM参数调优\"},\"191\":{\"c\":[\"Java\"]},\"192\":{\"c\":[\"Java\",\"jvm\"]},\"193\":{\"h\":\"JVM垃圾回收\"},\"194\":{\"c\":[\"Java\"]},\"195\":{\"c\":[\"Java\",\"jvm\"]},\"196\":{\"h\":\"CountDownLatch锁\"},\"197\":{\"c\":[\"Java\"]},\"198\":{\"c\":[\"Java\",\"juc\",\"锁\"]},\"199\":{\"h\":\"CyclicBarrier锁\"},\"200\":{\"c\":[\"Java\"]},\"201\":{\"c\":[\"Java\",\"juc\",\"锁\"]},\"202\":{\"h\":\"Phaser锁\"},\"203\":{\"c\":[\"Java\"]},\"204\":{\"c\":[\"Java\",\"juc\",\"锁\"]},\"205\":{\"h\":\"\"},\"206\":{\"c\":[\"Java\"]},\"207\":{\"c\":[\"Java\",\"锁\"]},\"208\":{\"h\":\"线程\",\"t\":[\"Java的线程是程序执行的最小单位，是操作系统进行调度的基本单元。Java中的线程由Thread类和Runnable接口实现。Thread类是一个实现了Runnable接口的类，它包含线程的控制方法和线程的生命周期方法。Runnable接口定义了一个run()方法，该方法包含线程要执行的代码。\",\"Java中的线程有以下几种状态：\",\"初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。\",\"运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。\",\"阻塞(BLOCKED)：表示线程阻塞于锁。\",\"等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。\",\"超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。\",\"终止(TERMINATED)：表示该线程已经执行完毕。\"]},\"209\":{\"c\":[\"Java\"]},\"210\":{\"c\":[\"Java\",\"并发\"]},\"211\":{\"h\":\"线程池\"},\"212\":{\"h\":\"线程池设计思想\",\"t\":[\"Java线程池的设计思想是为了提高线程的使用效率和响应能力，以及降低资源消耗和线程管理的复杂度。 Java线程池主要具有以下设计思想：\",\"重复使用线程：Java线程池中的线程可以被重复使用，而不是为每个任务创建一个新的线程。这样可以避免线程的创建和销毁带来的开销，提高程序的性能。\",\"控制资源消耗：Java线程池可以控制线程的数量，从而控制程序对系统资源的消耗。当线程数量过多时，可以避免过多的线程同时占用资源，导致资源浪费和系统负载过高。\",\"提高响应能力：Java线程池可以快速响应任务的提交和执行，从而提高程序的响应能力。当有新的任务提交时，线程池可以立即分配线程执行任务，而不用等待新的线程创建和就绪。\",\"任务执行管理：Java线程池可以对任务的执行进行管理，例如控制任务的执行顺序、限制任务的执行时间、处理任务的异常等。这样可以保证任务的执行质量，并提高程序的可靠性。\",\"Java线程池通过ThreadPoolExecutor类来实现，该类提供了可重用的线程池，并提供了丰富的配置选项，可以根据实际需要来配置线程池的参数，以达到最佳的性能和效果。 Java线程池的设计思想是基于生产者-消费者模式，通过工作线程来执行任务，从而实现高效的并发处理。\"]},\"213\":{\"h\":\"如何停止线程池中的线程\",\"t\":[\"在Java中，线程池中的线程是并发执行的，不支持直接停止某一个线程。但是可以通过以下几种方式中断线程的执行：\",\"使用线程的interrupt方法中断线程\",\"ExecutorService executor = Executors.newFixedThreadPool(5); Future future = executor.submit(() -> { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } }); // 停止某个线程 executor.shutdownNow(); future.cancel(true); \",\"使用线程的interrupted方法检查中断标志位\",\"ExecutorService executor = Executors.newFixedThreadPool(5); Future future = executor.submit(() -> { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } }); // 停止某个线程 executor.shutdownNow(); if (Thread.interrupted()) { // 中断标志位为true表示被中断 // 处理中断逻辑 } \",\"使用线程的isInterrupted方法检查中断状态\",\"ExecutorService executor = Executors.newFixedThreadPool(5); Future future = executor.submit(() -> { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } }); // 停止某个线程 executor.shutdownNow(); if (Thread.interrupted()) { // 中断标志位为true表示被中断 // 处理中断逻辑 Thread.currentThread().interrupt(); } \",\"import java.util.concurrent.*; public class Main { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future<String> future = executor.submit(() -> { try { while (!Thread.currentThread().isInterrupted()) { System.out.println(\\\"Working...\\\"); Thread.sleep(5000); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } return \\\"Done\\\"; }); System.out.println(\\\"Future status: \\\" + future.isDone()); Thread.sleep(3000); System.out.println(\\\"Try to cancel future...\\\"); future.cancel(true); System.out.println(\\\"Future status: \\\" + future.isCancelled()); System.out.println(\\\"Future result: \\\" + future.get()); executor.shutdown(); } } \"]},\"214\":{\"h\":\"线程池的核心参数\",\"t\":[\"线程池的核心参数如下：\",\"corePoolSize：核心线程数，即线程池维护的最低线程数。\",\"maximumPoolSize：最大线程数，即线程池维护的最大线程数。\",\"keepAliveTime：线程空闲 timeout，即线程空闲 timeout 时间。\",\"unit：时间单位。\",\"workQueue：任务队列，用于保存等待线程执行的任务。\",\"threadFactory：线程工厂，用于创建新线程。\",\"handler：拒绝执行策略，当任务队列和线程池都达到最大容量时，将执行任务的续行策略。\"]},\"215\":{\"c\":[\"Java\"]},\"216\":{\"c\":[\"Java\",\"并发\"]},\"217\":{\"h\":\"SpringBean的生命周期\"},\"218\":{\"c\":[\"Java\"]},\"219\":{\"c\":[\"Java\"]},\"220\":{\"h\":\"Elastic Search\"},\"221\":{\"h\":\"Posts\"},\"222\":{\"h\":\"My S Q L\"},\"223\":{\"h\":\"Vue3\"},\"224\":{\"h\":\"数据结构\"},\"225\":{\"h\":\"旅游\"},\"226\":{\"h\":\"架构\"},\"227\":{\"h\":\"电商\"},\"228\":{\"h\":\"简历\"},\"229\":{\"h\":\"算法\"},\"230\":{\"h\":\"记录\"},\"231\":{\"h\":\"Jvm\"},\"232\":{\"h\":\"Java\"},\"233\":{\"h\":\"并发\"},\"234\":{\"h\":\"Spring\"},\"235\":{\"h\":\"Java框架\"}},\"dirtCount\":0,\"index\":[[\"简历\",{\"0\":{\"228\":1}}],[\"简单\",{\"1\":{\"8\":1,\"14\":1}}],[\"拒绝执行策略\",{\"1\":{\"214\":1}}],[\"用于创建新线程\",{\"1\":{\"214\":1}}],[\"用于保存等待线程执行的任务\",{\"1\":{\"214\":1}}],[\"用于存储同一类型的数据元素\",{\"1\":{\"49\":1}}],[\"任务队列\",{\"1\":{\"214\":1}}],[\"任务执行管理\",{\"1\":{\"212\":1}}],[\"核心线程数\",{\"1\":{\"214\":1}}],[\"核心api\",{\"0\":{\"104\":1}}],[\"unit\",{\"1\":{\"214\":1}}],[\"util\",{\"1\":{\"213\":1}}],[\"uml\",{\"1\":{\"3\":1}}],[\"处理中断逻辑\",{\"1\":{\"213\":2}}],[\"处理任务的异常等\",{\"1\":{\"212\":1}}],[\"中断标志位为true表示被中断\",{\"1\":{\"213\":2}}],[\"中恢复bufferpool的环境\",{\"1\":{\"35\":1}}],[\"停止某个线程\",{\"1\":{\"213\":3}}],[\"执行任务\",{\"1\":{\"213\":3}}],[\"消费者模式\",{\"1\":{\"212\":1}}],[\"限制任务的执行时间\",{\"1\":{\"212\":1}}],[\"而不用等待新的线程创建和就绪\",{\"1\":{\"212\":1}}],[\"而不是为每个任务创建一个新的线程\",{\"1\":{\"212\":1}}],[\"控制资源消耗\",{\"1\":{\"212\":1}}],[\"控制交易流程\",{\"1\":{\"103\":1}}],[\"表示该线程已经执行完毕\",{\"1\":{\"208\":1}}],[\"表示线程阻塞于锁\",{\"1\":{\"208\":1}}],[\"终止\",{\"1\":{\"208\":1}}],[\"超时等待\",{\"1\":{\"208\":1}}],[\"进入该状态的线程需要等待其他线程做出一些特定动作\",{\"1\":{\"208\":1}}],[\"进行冒泡排序\",{\"1\":{\"128\":2}}],[\"进行es数据同步\",{\"1\":{\"93\":1}}],[\"等待\",{\"1\":{\"208\":1}}],[\"等待被线程调度选中\",{\"1\":{\"208\":1}}],[\"阻塞\",{\"1\":{\"208\":1}}],[\"就绪状态的线程在获得cpu时间片后变为运行中状态\",{\"1\":{\"208\":1}}],[\"两种状态笼统的称为\",{\"1\":{\"208\":1}}],[\"运行\",{\"1\":{\"208\":2}}],[\"新创建了一个线程对象\",{\"1\":{\"208\":1}}],[\"新增页\",{\"1\":{\"27\":2}}],[\"初始\",{\"1\":{\"208\":1}}],[\"初始化largest为当前节点\",{\"1\":{\"141\":1}}],[\"初始化组件函数\",{\"1\":{\"48\":1}}],[\"方法\",{\"1\":{\"208\":3}}],[\"方案\",{\"2\":{\"19\":1,\"85\":1,\"95\":1,\"98\":1,\"101\":1,\"110\":1,\"113\":1}}],[\"线程工厂\",{\"1\":{\"214\":1}}],[\"线程空闲\",{\"1\":{\"214\":1}}],[\"线程池的核心参数如下\",{\"1\":{\"214\":1}}],[\"线程池的核心参数\",{\"0\":{\"214\":1}}],[\"线程池中的线程是并发执行的\",{\"1\":{\"213\":1}}],[\"线程池可以立即分配线程执行任务\",{\"1\":{\"212\":1}}],[\"线程池设计思想\",{\"0\":{\"212\":1}}],[\"线程池\",{\"0\":{\"211\":1}}],[\"线程对象创建后\",{\"1\":{\"208\":1}}],[\"线程\",{\"0\":{\"208\":1}}],[\"锁\",{\"2\":{\"198\":1,\"201\":1,\"204\":1,\"207\":1}}],[\"博客\",{\"2\":{\"185\":1,\"186\":1}}],[\"博主\",{\"2\":{\"4\":1,\"5\":1}}],[\"字体\",{\"2\":{\"183\":1}}],[\"资料\",{\"0\":{\"178\":1}}],[\"资源利用率\",{\"1\":{\"72\":1}}],[\"所以消耗内存\",{\"1\":{\"177\":1}}],[\"保留模式\",{\"0\":{\"177\":1}}],[\"保证订单安全和隐私\",{\"1\":{\"103\":1}}],[\"保证了持久性和一致性\",{\"1\":{\"35\":1}}],[\"保证实时性主要依赖于搜索服务的定时间隔\",{\"1\":{\"15\":1}}],[\"保证实时性\",{\"1\":{\"8\":1}}],[\"游戏等\",{\"1\":{\"176\":1}}],[\"特效\",{\"1\":{\"176\":1}}],[\"特有的组件\",{\"1\":{\"35\":1}}],[\"动画\",{\"1\":{\"176\":1}}],[\"适用于动态元素渲染\",{\"1\":{\"176\":1}}],[\"每一帧都会消耗cpu和gpu资源\",{\"1\":{\"176\":1}}],[\"每次渲染的是需要改变的元素\",{\"1\":{\"177\":1}}],[\"每次渲染都立即重新绘制\",{\"1\":{\"176\":1}}],[\"每次从待排序的数据元素中选出最小\",{\"1\":{\"168\":1}}],[\"每次取出的都是当前堆中的最大元素\",{\"1\":{\"140\":1}}],[\"即线程空闲\",{\"1\":{\"214\":1}}],[\"即线程池维护的最大线程数\",{\"1\":{\"214\":1}}],[\"即线程池维护的最低线程数\",{\"1\":{\"214\":1}}],[\"即时模式\",{\"0\":{\"176\":1}}],[\"即为按升序排序后的结果\",{\"1\":{\"170\":1}}],[\"寻找最小元素的索引\",{\"1\":{\"172\":1}}],[\"遍历数组\",{\"1\":{\"172\":1}}],[\"输出\",{\"1\":{\"172\":1}}],[\"忽略前四个元素\",{\"1\":{\"170\":1}}],[\"忽略前三个元素\",{\"1\":{\"170\":1}}],[\"忽略前两个元素\",{\"1\":{\"170\":1}}],[\"忽略第一个元素\",{\"1\":{\"170\":1}}],[\"按升序排序\",{\"1\":{\"170\":1}}],[\"给定数组\",{\"1\":{\"170\":1}}],[\"步骤\",{\"0\":{\"169\":1}}],[\"或最大\",{\"1\":{\"168\":1}}],[\"计数排序\",{\"0\":{\"165\":1}}],[\"计划图\",{\"0\":{\"67\":1}}],[\"桶排序\",{\"0\":{\"162\":1}}],[\"斐波那契数列\",{\"2\":{\"161\":1}}],[\"斐波那契数列问题\",{\"0\":{\"159\":1}}],[\"​n=0n=1n>=1​​​\",{\"1\":{\"159\":1}}],[\"取出下一个元素\",{\"1\":{\"156\":1}}],[\"取消订单\",{\"1\":{\"104\":1}}],[\"代码实现\",{\"0\":{\"172\":1}}],[\"代码的执行步骤\",{\"1\":{\"156\":1}}],[\"代理方案\",{\"1\":{\"3\":1}}],[\"找到最小元素\",{\"1\":{\"170\":5}}],[\"找到最小\",{\"1\":{\"169\":2}}],[\"找到相应位置并插入\",{\"1\":{\"153\":1,\"156\":1}}],[\"找到耗时较长的sql语句\",{\"1\":{\"32\":1}}],[\"插入排序的时间复杂度为o\",{\"1\":{\"156\":1}}],[\"插入排序的效率为o\",{\"1\":{\"156\":1}}],[\"插入排序的工作原理是\",{\"1\":{\"156\":1}}],[\"插入排序需要o\",{\"1\":{\"154\":1,\"155\":1}}],[\"插入排序是一种简单直观的排序算法\",{\"1\":{\"153\":1}}],[\"插入排序\",{\"0\":{\"153\":1},\"1\":{\"156\":1}}],[\"递归调用\",{\"1\":{\"150\":2}}],[\"待排序的数组\",{\"1\":{\"150\":1}}],[\"待发货\",{\"1\":{\"103\":1}}],[\"参数说明\",{\"1\":{\"150\":1}}],[\"q\",{\"0\":{\"222\":1}}],[\"quicksort\",{\"1\":{\"150\":5}}],[\"qps\",{\"1\":{\"72\":1}}],[\"三数中值法选取基准等优化方法\",{\"1\":{\"150\":1}}],[\"为了避免最坏情况的发生\",{\"1\":{\"150\":1}}],[\"为什么要分库分表\",{\"0\":{\"27\":1}}],[\"选择排序的时间复杂度为\",{\"1\":{\"171\":1}}],[\"选择排序的算法步骤如下\",{\"1\":{\"169\":1}}],[\"选择排序是一种简单直观的排序算法\",{\"1\":{\"168\":1}}],[\"选择排序\",{\"0\":{\"168\":1}}],[\"选择区分度高的列作为索引\",{\"1\":{\"31\":1}}],[\"选取中间元素作为基准\",{\"1\":{\"150\":1}}],[\"选取最后一个元素作为基准\",{\"1\":{\"150\":1}}],[\"选取第一个元素作为基准\",{\"1\":{\"150\":1}}],[\"不支持直接停止某一个线程\",{\"1\":{\"213\":1}}],[\"不会重新绘制\",{\"1\":{\"177\":1}}],[\"不同的选取方法会影响排序的效率\",{\"1\":{\"150\":1}}],[\"不一致不更新\",{\"1\":{\"108\":1}}],[\"该类提供了可重用的线程池\",{\"1\":{\"212\":1}}],[\"该状态不同于waiting\",{\"1\":{\"208\":1}}],[\"该状态的线程位于可运行线程池中\",{\"1\":{\"208\":1}}],[\"该方法包含线程要执行的代码\",{\"1\":{\"208\":1}}],[\"该元素可以认为已经被排序\",{\"1\":{\"156\":1}}],[\"该基准就处于数列的中间位置\",{\"1\":{\"150\":1}}],[\"该算法通过使用两个指针\",{\"1\":{\"132\":1}}],[\"相同的数可以放在任一边\",{\"1\":{\"150\":1}}],[\"相机\",{\"1\":{\"64\":1}}],[\"比如main线程\",{\"1\":{\"208\":1}}],[\"比如\",{\"1\":{\"176\":1}}],[\"比基准值大的元素都放在基准的后面\",{\"1\":{\"150\":1}}],[\"比较3和4\",{\"1\":{\"128\":1}}],[\"比较3和5\",{\"1\":{\"128\":2}}],[\"比较6和4\",{\"1\":{\"128\":1}}],[\"比较8和4\",{\"1\":{\"128\":1}}],[\"比较8和6\",{\"1\":{\"128\":1}}],[\"比较5和4\",{\"1\":{\"128\":1}}],[\"比较5和6\",{\"1\":{\"128\":1}}],[\"比较5和8\",{\"1\":{\"128\":1}}],[\"比较5和3\",{\"1\":{\"128\":1}}],[\"称为\",{\"1\":{\"150\":1}}],[\"采用分治法\",{\"1\":{\"150\":1}}],[\"快速排序的时间复杂度为o\",{\"1\":{\"150\":1}}],[\"快速排序的关键步骤是基准的选取\",{\"1\":{\"150\":1}}],[\"快速排序是一种常用的排序算法\",{\"1\":{\"150\":1}}],[\"快速排序\",{\"0\":{\"150\":1},\"1\":{\"150\":1}}],[\"归并排序\",{\"0\":{\"147\":1}}],[\"希尔排序\",{\"0\":{\"144\":1}}],[\"则r=a\",{\"1\":{\"150\":1}}],[\"则l=0\",{\"1\":{\"150\":1}}],[\"则将largest与当前节点交换\",{\"1\":{\"141\":1}}],[\"则更新largest为右子节点\",{\"1\":{\"141\":1}}],[\"则更新largest为左子节点\",{\"1\":{\"141\":1}}],[\"右子节点\",{\"1\":{\"141\":1}}],[\"左子节点\",{\"1\":{\"141\":1}}],[\"调用了该对象的start\",{\"1\":{\"208\":1}}],[\"调用方将版本号作为参数给接口\",{\"1\":{\"108\":1}}],[\"调整堆\",{\"1\":{\"141\":1}}],[\"重新成为一个大顶堆\",{\"1\":{\"141\":1}}],[\"重复使用线程\",{\"1\":{\"212\":1}}],[\"重复步骤3\",{\"1\":{\"156\":1}}],[\"重复步骤2~5\",{\"1\":{\"156\":1}}],[\"重复步骤2\",{\"1\":{\"127\":1}}],[\"重复上述步骤\",{\"1\":{\"140\":1,\"169\":1}}],[\"重复执行以下步骤\",{\"1\":{\"140\":1}}],[\"构建大顶堆\",{\"1\":{\"141\":1}}],[\"构建语法树\",{\"1\":{\"40\":1}}],[\"因此在需要保持相同元素的原始顺序时应谨慎使用\",{\"1\":{\"140\":1}}],[\"因为双指针同时进行遍历\",{\"1\":{\"132\":1}}],[\"空间复杂度\",{\"0\":{\"155\":1}}],[\"空间复杂度为o\",{\"1\":{\"140\":1}}],[\"空间有效利用\",{\"0\":{\"53\":1}}],[\"与第五个元素\",{\"1\":{\"170\":1}}],[\"与第四个元素\",{\"1\":{\"170\":1}}],[\"与第三个元素\",{\"1\":{\"170\":1}}],[\"与第二个元素\",{\"1\":{\"170\":1}}],[\"与第一个元素\",{\"1\":{\"170\":1}}],[\"与堆的最后一个元素交换\",{\"1\":{\"140\":1}}],[\"与同步双写相比分析优缺点\",{\"1\":{\"10\":1}}],[\"根节点\",{\"1\":{\"140\":1}}],[\"使其重新成为一个大顶堆\",{\"1\":{\"140\":1,\"141\":1}}],[\"使其满足大顶堆的特性\",{\"1\":{\"140\":1}}],[\"使用线程的isinterrupted方法检查中断状态\",{\"1\":{\"213\":1}}],[\"使用线程的interrupted方法检查中断标志位\",{\"1\":{\"213\":1}}],[\"使用线程的interrupt方法中断线程\",{\"1\":{\"213\":1}}],[\"使用计数排序算法对每个数字出现的次数进行统计\",{\"1\":{\"137\":1}}],[\"使用双指针算法可以有效地提高解决数组或链表相关问题的效率\",{\"1\":{\"132\":1}}],[\"使用订单id作为幂等标识下单\",{\"1\":{\"107\":1}}],[\"使用elasticsearch作为搜索引擎\",{\"1\":{\"91\":1}}],[\"使用explain语句解析sql执行计划\",{\"1\":{\"32\":1}}],[\"使用单体架构\",{\"1\":{\"74\":1}}],[\"建堆的过程从数组的最后一个非叶子节点开始\",{\"1\":{\"140\":1}}],[\"建堆\",{\"1\":{\"140\":1}}],[\"堆是一个可以推导具有最大或最小值的树形结构\",{\"1\":{\"140\":1}}],[\"堆排序的时间复杂度为o\",{\"1\":{\"140\":1}}],[\"堆排序分为两个步骤\",{\"1\":{\"140\":1}}],[\"堆排序利用堆的特性进行排序\",{\"1\":{\"140\":1}}],[\"堆排序\",{\"0\":{\"140\":1},\"1\":{\"140\":1}}],[\"是操作系统进行调度的基本单元\",{\"1\":{\"208\":1}}],[\"是待排序数组的长度\",{\"1\":{\"171\":1}}],[\"是利用堆\",{\"1\":{\"140\":1}}],[\"是一种简单直观的排序算法\",{\"1\":{\"156\":1}}],[\"是一种简单的排序算法\",{\"1\":{\"126\":1}}],[\"是一种常见的算法思想\",{\"1\":{\"132\":1}}],[\"osfcc\",{\"1\":{\"181\":1}}],[\"ov\",{\"1\":{\"181\":1}}],[\"o\",{\"1\":{\"171\":1}}],[\"out\",{\"1\":{\"141\":2,\"150\":6,\"172\":1,\"213\":5}}],[\"output\",{\"1\":{\"137\":3}}],[\"okr\",{\"1\":{\"3\":1}}],[\"获取cpu的使用权\",{\"1\":{\"208\":1}}],[\"获取最大值的位数\",{\"1\":{\"137\":1}}],[\"获取待排序数组中的最大值\",{\"1\":{\"137\":1}}],[\"||\",{\"1\":{\"137\":1}}],[\"将执行任务的续行策略\",{\"1\":{\"214\":1}}],[\"将其与第二个元素交换位置\",{\"1\":{\"169\":1}}],[\"将其与第一个元素交换位置\",{\"1\":{\"169\":1}}],[\"将新元素插入到该位置后\",{\"1\":{\"156\":1}}],[\"将该元素移动到下一位置\",{\"1\":{\"156\":1}}],[\"将所有比基准值小的元素都放在基准前面\",{\"1\":{\"150\":1}}],[\"将当前堆中的最大元素与堆的最后一个元素交换\",{\"1\":{\"141\":1}}],[\"将堆的大小减1\",{\"1\":{\"140\":1}}],[\"将堆中的最大元素\",{\"1\":{\"140\":1}}],[\"将一个无序的数组构建成一个大顶堆\",{\"1\":{\"140\":1}}],[\"将有序数组重新赋值给原数组\",{\"1\":{\"137\":1}}],[\"将整数按位数划分为不同的桶\",{\"1\":{\"136\":1}}],[\"依次向上调整每个节点\",{\"1\":{\"140\":1}}],[\"依次对每一位进行排序\",{\"1\":{\"137\":1}}],[\"依次确定每个数字在有序数组中的位置\",{\"1\":{\"137\":1}}],[\"依次放到数列的起始位置\",{\"1\":{\"127\":1}}],[\"确定最大位数d\",{\"1\":{\"137\":1}}],[\"确保订单信息的安全性和隐私性\",{\"1\":{\"103\":1}}],[\"得到最终的排序结果\",{\"1\":{\"136\":1}}],[\"基准\",{\"1\":{\"150\":1}}],[\"基于计数排序的结果\",{\"1\":{\"137\":1}}],[\"基本原理\",{\"0\":{\"136\":1}}],[\"基数排序的实现步骤如下\",{\"1\":{\"137\":1}}],[\"基数排序的时间复杂度为o\",{\"1\":{\"136\":1}}],[\"基数排序的基本思想是\",{\"1\":{\"136\":1}}],[\"基数排序是一种非比较性的排序算法\",{\"1\":{\"136\":1}}],[\"基数排序\",{\"0\":{\"135\":1}}],[\"链表\",{\"2\":{\"134\":1}}],[\"降低到o\",{\"1\":{\"132\":1}}],[\"统计数组中元素出现次数等\",{\"1\":{\"132\":1}}],[\"另一个从起始位置开始向后遍历\",{\"1\":{\"132\":1}}],[\"我们通常使用两个指针\",{\"1\":{\"132\":1}}],[\"我们通常使用两个指针从数组的两端同时开始遍历\",{\"1\":{\"132\":1}}],[\"通知或中断\",{\"1\":{\"208\":1}}],[\"通常有以下几种选取方法\",{\"1\":{\"150\":1}}],[\"通常用于解决数组或链表相关的问题\",{\"1\":{\"132\":1}}],[\"通过工作线程来执行任务\",{\"1\":{\"212\":1}}],[\"通过构建有序序列\",{\"1\":{\"156\":1}}],[\"通过上面文章的方案比较\",{\"1\":{\"93\":1}}],[\"通过主键去聚簇索引查找记录\",{\"1\":{\"45\":1}}],[\"双指针算法通常可以分为两种情况\",{\"1\":{\"132\":1}}],[\"双指针算法\",{\"1\":{\"132\":1}}],[\"双指针\",{\"0\":{\"132\":1},\"2\":{\"134\":1}}],[\"排序截至到数组末尾\",{\"1\":{\"150\":1}}],[\"排序后的数组\",{\"1\":{\"141\":1}}],[\"排序\",{\"1\":{\"140\":1,\"141\":1},\"2\":{\"131\":1,\"139\":1,\"143\":1,\"146\":1,\"149\":1,\"152\":1,\"158\":1,\"164\":1,\"167\":1,\"174\":1}}],[\"排查执行计划中扫描行数较多的查询语句\",{\"1\":{\"32\":1}}],[\"排查执行计划中是否有全表扫描的情况\",{\"1\":{\"32\":1}}],[\"排查慢查询过程\",{\"0\":{\"32\":1}}],[\">=\",{\"1\":{\"137\":1,\"141\":2,\"156\":1}}],[\">\",{\"1\":{\"129\":1,\"137\":2,\"141\":2,\"150\":1,\"156\":1,\"213\":4}}],[\"<=\",{\"1\":{\"137\":1}}],[\"<\",{\"1\":{\"129\":2,\"137\":3,\"141\":2,\"150\":7,\"156\":1,\"172\":3}}],[\"0\",{\"1\":{\"129\":2,\"137\":6,\"141\":4,\"150\":1,\"156\":1,\"172\":1}}],[\"00\",{\"1\":{\"65\":6}}],[\"000\",{\"1\":{\"44\":2,\"45\":2}}],[\"future<string>\",{\"1\":{\"213\":1}}],[\"future\",{\"1\":{\"213\":16}}],[\"file\",{\"1\":{\"181\":1}}],[\"fonts\",{\"1\":{\"181\":1}}],[\"for\",{\"1\":{\"129\":2,\"137\":4,\"141\":3,\"150\":2,\"156\":1,\"172\":2}}],[\"free\",{\"1\":{\"181\":1}}],[\"f\",{\"1\":{\"159\":1}}],[\"flink\",{\"1\":{\"3\":1}}],[\"versus\",{\"1\":{\"178\":1}}],[\"void\",{\"1\":{\"129\":1,\"137\":2,\"141\":4,\"150\":2,\"156\":1,\"172\":2,\"213\":1}}],[\"vue3\",{\"0\":{\"223\":1}}],[\"vuepress\",{\"1\":{\"184\":1},\"2\":{\"186\":1}}],[\"vuex\",{\"1\":{\"48\":1}}],[\"vue\",{\"1\":{\"3\":1}}],[\"平均情况\",{\"1\":{\"129\":1}}],[\"复杂度分析\",{\"0\":{\"129\":1}}],[\"整个数列排序完成\",{\"1\":{\"128\":1}}],[\"继续冒泡排序\",{\"1\":{\"128\":2}}],[\"剩下的数列\",{\"1\":{\"128\":2}}],[\"此时处于就绪状态\",{\"1\":{\"208\":1}}],[\"此时最小元素3已经排好序\",{\"1\":{\"128\":1}}],[\"此时最大元素8已经排好序\",{\"1\":{\"128\":1}}],[\"此时第三大元素5已经排好序\",{\"1\":{\"128\":1}}],[\"此时次大元素6已经排好序\",{\"1\":{\"128\":1}}],[\"第五次遍历\",{\"1\":{\"170\":1}}],[\"第四次遍历\",{\"1\":{\"170\":1}}],[\"第四轮结束\",{\"1\":{\"128\":1}}],[\"第四轮\",{\"1\":{\"128\":1}}],[\"第三次遍历\",{\"1\":{\"170\":1}}],[\"第三轮结束\",{\"1\":{\"128\":1}}],[\"第三轮\",{\"1\":{\"128\":1}}],[\"第二次遍历\",{\"1\":{\"170\":1}}],[\"第二轮结束\",{\"1\":{\"128\":1}}],[\"第二轮\",{\"1\":{\"128\":1}}],[\"第一次遍历\",{\"1\":{\"170\":1}}],[\"第一轮结束\",{\"1\":{\"128\":1}}],[\"第一轮\",{\"1\":{\"128\":1}}],[\"位置不变\",{\"1\":{\"128\":5}}],[\"发现3<4\",{\"1\":{\"128\":1}}],[\"发现3<5\",{\"1\":{\"128\":2}}],[\"发现6>4\",{\"1\":{\"128\":1}}],[\"发现8>4\",{\"1\":{\"128\":1}}],[\"发现8>6\",{\"1\":{\"128\":1}}],[\"发现5>4\",{\"1\":{\"128\":1}}],[\"发现5>3\",{\"1\":{\"128\":1}}],[\"发现5<6\",{\"1\":{\"128\":1}}],[\"发现5<8\",{\"1\":{\"128\":1}}],[\"发货\",{\"1\":{\"104\":1}}],[\"534695668\",{\"1\":{\"178\":1}}],[\"5000\",{\"1\":{\"213\":1}}],[\"50\",{\"1\":{\"150\":1}}],[\"5\",{\"1\":{\"128\":12,\"141\":1,\"156\":1,\"170\":9,\"172\":2,\"213\":3}}],[\"示例\",{\"0\":{\"128\":1,\"170\":1}}],[\"直到所有元素均排序完毕\",{\"1\":{\"169\":1}}],[\"直到所有元素排序完成\",{\"1\":{\"127\":1}}],[\"直到全部待排序的数据元素排完\",{\"1\":{\"168\":1}}],[\"直到找到已排序的元素小于或者等于新元素的位置\",{\"1\":{\"156\":1}}],[\"直到堆的大小为1\",{\"1\":{\"140\":1}}],[\"直到最高位\",{\"1\":{\"137\":1}}],[\"直接访问\",{\"0\":{\"51\":1}}],[\"放到已排序序列的末尾\",{\"1\":{\"127\":1}}],[\"再从剩下的元素中挑出最小\",{\"1\":{\"127\":1}}],[\"元素\",{\"1\":{\"127\":2}}],[\"也就是说该数列已经排序完成\",{\"1\":{\"126\":1}}],[\"走访数列的工作是重复地进行直到没有再需要交换\",{\"1\":{\"126\":1}}],[\"它可以在指定的时间后自行返回\",{\"1\":{\"208\":1}}],[\"它包含线程的控制方法和线程的生命周期方法\",{\"1\":{\"208\":1}}],[\"它的基本思想是\",{\"1\":{\"168\":1}}],[\"它的基本思想是通过构建有序序列\",{\"1\":{\"153\":1}}],[\"它的基本步骤如下\",{\"1\":{\"150\":1}}],[\"它重复地走访过要排序的数列\",{\"1\":{\"126\":1}}],[\"它由一组连续的内存空间组成\",{\"1\":{\"49\":1}}],[\"冒泡排序是一种稳定的排序算法\",{\"1\":{\"129\":1}}],[\"冒泡排序\",{\"0\":{\"126\":1},\"1\":{\"126\":1}}],[\"zenozeng\",{\"1\":{\"181\":1}}],[\"zhihu\",{\"1\":{\"178\":1}}],[\"zhuanlan\",{\"1\":{\"178\":1}}],[\"zh\",{\"1\":{\"178\":1}}],[\"zab一致性算法\",{\"0\":{\"123\":1}}],[\"zq99299\",{\"1\":{\"96\":1}}],[\"算法描述\",{\"0\":{\"127\":1}}],[\"算法\",{\"0\":{\"229\":1},\"2\":{\"115\":1,\"116\":1,\"118\":1,\"119\":1,\"121\":1,\"122\":1,\"124\":1,\"125\":1,\"130\":1,\"131\":1,\"133\":1,\"134\":1,\"138\":1,\"139\":1,\"142\":1,\"143\":1,\"145\":1,\"146\":1,\"148\":1,\"149\":1,\"151\":1,\"152\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1,\"163\":1,\"164\":1,\"166\":1,\"167\":1,\"173\":1,\"174\":1}}],[\"提高响应能力\",{\"1\":{\"212\":1}}],[\"提高程序的性能\",{\"1\":{\"212\":1}}],[\"提示用户刷新页面\",{\"1\":{\"108\":1}}],[\"提前三天预约\",{\"1\":{\"65\":4}}],[\"当任务队列和线程池都达到最大容量时\",{\"1\":{\"214\":1}}],[\"当有新的任务提交时\",{\"1\":{\"212\":1}}],[\"当线程数量过多时\",{\"1\":{\"212\":1}}],[\"当前位的权值\",{\"1\":{\"137\":1}}],[\"当数组是逆序排列时\",{\"1\":{\"129\":1}}],[\"当数组已经按照排序需求排好时\",{\"1\":{\"129\":1}}],[\"当版本一致的时候更新数据\",{\"1\":{\"108\":1}}],[\"当然\",{\"1\":{\"74\":1}}],[\"版本号的乐观锁机制\",{\"1\":{\"108\":1}}],[\"请求顺序不一致导致数据错乱\",{\"0\":{\"108\":1}}],[\"请求成功率\",{\"1\":{\"72\":1}}],[\"然后按每个位数分别对桶中的元素进行排序\",{\"1\":{\"136\":1}}],[\"然后根据具体的问题来决定两个指针的移动方式\",{\"1\":{\"132\":1}}],[\"然后\",{\"1\":{\"107\":1}}],[\"然后将数据写入\",{\"1\":{\"27\":1}}],[\"然后将数据返回给客户端\",{\"1\":{\"27\":1}}],[\"首先\",{\"1\":{\"107\":1}}],[\"注意的场景\",{\"0\":{\"106\":1}}],[\"完成\",{\"1\":{\"104\":1}}],[\"评价\",{\"1\":{\"104\":1}}],[\"签收\",{\"1\":{\"104\":1}}],[\"创建订单\",{\"1\":{\"104\":1}}],[\"创口贴\",{\"1\":{\"64\":1}}],[\"生成订单id\",{\"1\":{\"104\":1,\"107\":1}}],[\"生命周期\",{\"1\":{\"48\":1}}],[\"具体的实现方式根据业务需求和系统架构进行选择\",{\"1\":{\"103\":1}}],[\"具体分布式架构下的并发性能还是需要测试\",{\"1\":{\"74\":1}}],[\"交换最小元素与当前元素的位置\",{\"1\":{\"172\":1}}],[\"交换数组中的两个元素\",{\"1\":{\"141\":1}}],[\"交换arr\",{\"1\":{\"129\":1}}],[\"交换位置\",{\"1\":{\"128\":5,\"170\":5}}],[\"交易分析等操作\",{\"1\":{\"103\":1}}],[\"交通\",{\"1\":{\"65\":1}}],[\"以达到最佳的性能和效果\",{\"1\":{\"212\":1}}],[\"以及降低资源消耗和线程管理的复杂度\",{\"1\":{\"212\":1}}],[\"以下是收录免费中问字体的github仓库\",{\"1\":{\"181\":1}}],[\"以下是堆排序的示例代码\",{\"1\":{\"140\":1}}],[\"以上代码实现了选择排序的排序算法和排序结果的输出\",{\"1\":{\"172\":1}}],[\"以上三种迭代的方式\",{\"1\":{\"74\":1}}],[\"以满足不同业务场景的需求\",{\"1\":{\"103\":1}}],[\"以便用户和商家进行订单管理\",{\"1\":{\"103\":1}}],[\"支付订单\",{\"1\":{\"104\":1}}],[\"支付信息\",{\"1\":{\"103\":1}}],[\"支付信息等\",{\"1\":{\"103\":1}}],[\"支持订单修改和取消\",{\"1\":{\"103\":1}}],[\"支持订单查询和统计\",{\"1\":{\"103\":1}}],[\"已排序\",{\"1\":{\"156\":1}}],[\"已完成等\",{\"1\":{\"103\":1}}],[\"已发货\",{\"1\":{\"103\":1}}],[\"已支付\",{\"1\":{\"103\":1}}],[\"物流信息等交易相关数据\",{\"1\":{\"103\":1}}],[\"物流模块\",{\"1\":{\"88\":1}}],[\"记录搭建vuepress博客\",{\"0\":{\"184\":1}}],[\"记录\",{\"0\":{\"230\":1},\"2\":{\"179\":1,\"182\":1}}],[\"记录并管理交易信息\",{\"1\":{\"103\":1}}],[\"记录大小k\",{\"1\":{\"44\":1,\"45\":1}}],[\"记录大小\",{\"1\":{\"43\":1}}],[\"收货地址\",{\"1\":{\"103\":1}}],[\"包括订单号\",{\"1\":{\"103\":1}}],[\"订单状态机设计\",{\"0\":{\"105\":1}}],[\"订单\",{\"1\":{\"92\":1}}],[\"订单模块\",{\"1\":{\"88\":1}}],[\"elastic\",{\"0\":{\"220\":1}}],[\"elasticsearch\",{\"1\":{\"9\":1},\"2\":{\"18\":1,\"19\":1}}],[\"e\",{\"1\":{\"213\":1}}],[\"exception\",{\"1\":{\"213\":1}}],[\"executors\",{\"1\":{\"213\":4}}],[\"executorservice\",{\"1\":{\"213\":4}}],[\"executor\",{\"1\":{\"213\":12}}],[\"end\",{\"1\":{\"96\":1}}],[\"es数据同步方案\",{\"0\":{\"93\":1}}],[\"es数据映射\",{\"0\":{\"92\":1}}],[\"es需要对以下数据做映射\",{\"1\":{\"92\":1}}],[\"热卖商品\",{\"1\":{\"91\":1}}],[\"规格描述\",{\"1\":{\"91\":1}}],[\"更新库存\",{\"1\":{\"89\":1}}],[\"搜索相关度排序\",{\"1\":{\"91\":1}}],[\"搜索商品列表高性能低延时方案\",{\"0\":{\"91\":1}}],[\"搜索商品列表\",{\"1\":{\"89\":1}}],[\"搜索服务\",{\"1\":{\"12\":1}}],[\"录入商品\",{\"1\":{\"89\":1}}],[\"供应链模块\",{\"1\":{\"88\":1}}],[\"从而实现高效的并发处理\",{\"1\":{\"212\":1}}],[\"从而提高程序的响应能力\",{\"1\":{\"212\":1}}],[\"从而控制程序对系统资源的消耗\",{\"1\":{\"212\":1}}],[\"从而解决问题\",{\"1\":{\"132\":1}}],[\"从第一个元素开始\",{\"1\":{\"156\":1}}],[\"从左向右找第一个大于x的数\",{\"1\":{\"150\":1}}],[\"从右向左找第一个小于x的数\",{\"1\":{\"150\":1}}],[\"从起始位置开始排序\",{\"1\":{\"150\":1}}],[\"从数列中随机选取一个元素作为基准\",{\"1\":{\"150\":1}}],[\"从数列中挑出一个元素\",{\"1\":{\"150\":1}}],[\"从数列中挑出最小\",{\"1\":{\"127\":1}}],[\"从数组的一端向另一端移动的双指针算法\",{\"1\":{\"132\":1}}],[\"从数组的两端向中间移动的双指针算法\",{\"1\":{\"132\":1}}],[\"从个人手中回收商品\",{\"1\":{\"87\":1}}],[\"从外部企业渠道采购到公司内部\",{\"1\":{\"87\":1}}],[\"从底往上计算高度\",{\"1\":{\"43\":1}}],[\"企业回收\",{\"1\":{\"87\":1}}],[\"企业采购\",{\"1\":{\"87\":1}}],[\"企业生产\",{\"1\":{\"87\":1}}],[\"公司内部记录和管理\",{\"1\":{\"87\":1}}],[\"公交地铁都需要\",{\"1\":{\"64\":1}}],[\"一次比较两个元素\",{\"1\":{\"126\":1}}],[\"一致性\",{\"2\":{\"116\":1,\"119\":1,\"122\":1,\"125\":1}}],[\"一般是有自己的供应链\",{\"1\":{\"87\":1}}],[\"一个指向数组的起始位置\",{\"1\":{\"132\":1}}],[\"一个非叶子节点存放叶子节点数量\",{\"1\":{\"43\":1}}],[\"一个叶子节点存放数据量\",{\"1\":{\"43\":1}}],[\"自产自销\",{\"1\":{\"87\":1}}],[\"自拍杆\",{\"1\":{\"64\":1}}],[\"电商购物车方案\",{\"0\":{\"111\":1}}],[\"电商订单的实现可以采用数据库存储\",{\"1\":{\"103\":1}}],[\"电商订单的职责\",{\"0\":{\"103\":1}}],[\"电商订单需要采取相应的安全措施\",{\"1\":{\"103\":1}}],[\"电商订单可以支持用户和商家对订单进行修改和取消操作\",{\"1\":{\"103\":1}}],[\"电商订单可以提供订单查询和统计功能\",{\"1\":{\"103\":1}}],[\"电商订单可以根据订单状态控制交易流程\",{\"1\":{\"103\":1}}],[\"电商订单负责记录和管理商品信息\",{\"1\":{\"103\":1}}],[\"电商订单具有以下职责\",{\"1\":{\"103\":1}}],[\"电商订单是记录电商平台上的交易信息的重要数据实体\",{\"1\":{\"103\":1}}],[\"电商订单设计方案\",{\"0\":{\"102\":1}}],[\"电商支付设计方案\",{\"0\":{\"99\":1}}],[\"电商搜索设计方案\",{\"0\":{\"96\":1}}],[\"电商商品设计方案\",{\"0\":{\"86\":1}}],[\"电商售后设计方案\",{\"0\":{\"83\":1}}],[\"电商\",{\"0\":{\"227\":1},\"2\":{\"81\":1,\"82\":1,\"84\":1,\"85\":1,\"94\":1,\"95\":1,\"97\":1,\"98\":1,\"100\":1,\"101\":1,\"109\":1,\"110\":1,\"112\":1,\"113\":1}}],[\"电商业务流程时序\",{\"0\":{\"80\":1},\"1\":{\"83\":1,\"86\":1,\"96\":1,\"99\":1,\"102\":1,\"111\":1}}],[\"测试\",{\"1\":{\"141\":1}}],[\"测试3级缓存\",{\"0\":{\"77\":1}}],[\"测试2级缓存\",{\"0\":{\"76\":1}}],[\"测试无缓存\",{\"0\":{\"75\":1}}],[\"测试并发性能\",{\"1\":{\"74\":1}}],[\"测试单体的并发性能可以粗略估算水平扩容的分布式架构的性能\",{\"1\":{\"74\":1}}],[\"仅使用mysql\",{\"1\":{\"74\":1}}],[\"仅需要在需要同步数据的逻辑上增加往elasticsearch写\",{\"1\":{\"8\":1}}],[\"库存接口\",{\"1\":{\"74\":1}}],[\"改变程序代码\",{\"1\":{\"74\":1}}],[\"编程语言固定\",{\"1\":{\"74\":1}}],[\"编写过数据大屏以及后台管理界面\",{\"1\":{\"3\":1}}],[\"家庭网络的路由大概是千兆网\",{\"1\":{\"74\":1}}],[\"本地网络\",{\"1\":{\"74\":1}}],[\"本身的组件\",{\"1\":{\"35\":1}}],[\"固定使用mysql和redis\",{\"1\":{\"74\":1}}],[\"设计一个高并发的程序\",{\"1\":{\"74\":1}}],[\"设计图\",{\"1\":{\"3\":1}}],[\"考虑的因素比较多\",{\"1\":{\"74\":1}}],[\"程序代码\",{\"1\":{\"73\":1}}],[\"下面是使用\",{\"1\":{\"172\":1}}],[\"下行速率\",{\"1\":{\"73\":1}}],[\"下载\",{\"1\":{\"64\":1}}],[\"上行速率\",{\"1\":{\"73\":1}}],[\"带宽\",{\"1\":{\"73\":1}}],[\"单体架构\",{\"1\":{\"73\":1}}],[\"软件架构固定\",{\"1\":{\"74\":1}}],[\"软件架构\",{\"1\":{\"73\":1}}],[\"软件工程专业\",{\"1\":{\"2\":1}}],[\"硬件固定\",{\"1\":{\"74\":1}}],[\"硬件\",{\"1\":{\"73\":1}}],[\"影响并发的因素\",{\"0\":{\"73\":1}}],[\"get\",{\"1\":{\"213\":1}}],[\"gui\",{\"2\":{\"180\":1}}],[\"gui渲染模式\",{\"0\":{\"175\":1}}],[\"gossip一致性算法\",{\"0\":{\"114\":1}}],[\"gc\",{\"1\":{\"72\":1}}],[\"github\",{\"1\":{\"38\":1,\"96\":1,\"181\":2}}],[\"内存\",{\"1\":{\"72\":1,\"73\":1,\"74\":1}}],[\"成功数\",{\"1\":{\"72\":1}}],[\"running\",{\"1\":{\"208\":2}}],[\"runnable\",{\"1\":{\"208\":1}}],[\"runnable接口定义了一个run\",{\"1\":{\"208\":1}}],[\"r\",{\"1\":{\"150\":5}}],[\"right\",{\"1\":{\"141\":4}}],[\"radix\",{\"1\":{\"137\":3}}],[\"radixsort\",{\"1\":{\"137\":2}}],[\"raft一致性算法\",{\"0\":{\"120\":1}}],[\"rt\",{\"1\":{\"72\":1}}],[\"result\",{\"1\":{\"213\":1}}],[\"ready\",{\"1\":{\"208\":2}}],[\"reactive\",{\"1\":{\"48\":1}}],[\"react\",{\"1\":{\"3\":1}}],[\"retained\",{\"1\":{\"178\":1}}],[\"return\",{\"1\":{\"137\":1,\"213\":1}}],[\"ref\",{\"1\":{\"48\":1}}],[\"redo\",{\"1\":{\"35\":3}}],[\"redis\",{\"1\":{\"3\":1,\"73\":1,\"74\":2}}],[\"响应时间\",{\"1\":{\"72\":1}}],[\"响应式操作数据\",{\"1\":{\"48\":3}}],[\"衡量高并发的指标\",{\"0\":{\"72\":1}}],[\"网络异常情况下\",{\"0\":{\"108\":1}}],[\"网络固定\",{\"1\":{\"74\":1}}],[\"网络\",{\"1\":{\"73\":1}}],[\"网络传输可能成为瓶颈\",{\"1\":{\"27\":2}}],[\"网站流量高峰期等情况下\",{\"1\":{\"71\":1}}],[\"秒杀场景\",{\"1\":{\"71\":1}}],[\"服务不可用等问题\",{\"1\":{\"71\":1}}],[\"高并发通常出现在促销活动\",{\"1\":{\"71\":1}}],[\"高并发是指在一定时间内\",{\"1\":{\"71\":1}}],[\"高并发定义\",{\"0\":{\"71\":1}}],[\"高并发设计\",{\"0\":{\"70\":1,\"74\":1}}],[\"旅游\",{\"0\":{\"225\":1},\"2\":{\"68\":1,\"69\":1}}],[\"旅游地点\",{\"0\":{\"62\":1}}],[\"望江亭\",{\"1\":{\"66\":1}}],[\"解放西路和福胜路正路口太平街牌牌坊的斜对面华远云玺前坪\",{\"1\":{\"66\":1}}],[\"解耦合\",{\"1\":{\"11\":1,\"17\":1}}],[\"碧沙湖地铁站5号口\",{\"1\":{\"66\":2}}],[\"梅溪湖文化艺术中心\",{\"1\":{\"66\":1}}],[\"梅溪湖中国结桥\",{\"1\":{\"66\":1}}],[\"拍照点\",{\"0\":{\"66\":1},\"1\":{\"66\":1}}],[\"地铁4号线湖南大学\",{\"1\":{\"65\":1}}],[\"地铁2号线湘江中路\",{\"1\":{\"65\":1}}],[\"地铁2号线橘子洲\",{\"1\":{\"65\":1}}],[\"地铁2\",{\"1\":{\"65\":1}}],[\"~\",{\"1\":{\"65\":4}}],[\"7\",{\"1\":{\"65\":2,\"141\":1}}],[\"免费中文字体文件下载\",{\"0\":{\"181\":1}}],[\"免费\",{\"1\":{\"65\":2}}],[\"预约\",{\"1\":{\"65\":1}}],[\"预约景点\",{\"1\":{\"65\":1}}],[\"门票\",{\"1\":{\"65\":1}}],[\"景点\",{\"1\":{\"65\":1}}],[\"鞋子\",{\"1\":{\"64\":1}}],[\"防晒霜\",{\"1\":{\"64\":1}}],[\"便携小风扇\",{\"1\":{\"64\":1}}],[\"薄外套\",{\"1\":{\"64\":1}}],[\"驱蚊液\",{\"1\":{\"64\":1}}],[\"充电宝\",{\"1\":{\"64\":1}}],[\"纸巾\",{\"1\":{\"64\":1}}],[\"多带\",{\"1\":{\"64\":1}}],[\"口罩\",{\"1\":{\"64\":1}}],[\"必备\",{\"1\":{\"64\":1}}],[\"必备物\",{\"1\":{\"64\":1}}],[\"晴雨伞\",{\"1\":{\"64\":1}}],[\"学生证等优惠证件\",{\"1\":{\"64\":1}}],[\"身份证\",{\"1\":{\"64\":1}}],[\"证件\",{\"1\":{\"64\":1}}],[\"乘车码\",{\"1\":{\"64\":1}}],[\"出发前准备\",{\"0\":{\"65\":1}}],[\"出行必备\",{\"0\":{\"64\":1}}],[\"出生年月\",{\"1\":{\"2\":1}}],[\"湖南省查杀是雨花区韶山北路258号\",{\"1\":{\"63\":1}}],[\"湖南大学\",{\"1\":{\"62\":1}}],[\"长沙地铁\",{\"1\":{\"64\":1}}],[\"长沙雅士亚豪生酒店\",{\"1\":{\"63\":1}}],[\"长沙旅游\",{\"0\":{\"61\":1}}],[\"住宿\",{\"0\":{\"63\":1}}],[\"杨帆夜市\",{\"1\":{\"62\":1}}],[\"后湖\",{\"1\":{\"62\":1}}],[\"文和友\",{\"1\":{\"62\":1}}],[\"四方坪夜市\",{\"1\":{\"62\":1}}],[\"丰盈西里\",{\"1\":{\"62\":1}}],[\"潮宗街\",{\"1\":{\"62\":1}}],[\"东瓜山\",{\"1\":{\"62\":1}}],[\"苏家巷\",{\"1\":{\"62\":1}}],[\"苏文广\",{\"1\":{\"2\":1}}],[\"太平街\",{\"1\":{\"62\":1}}],[\"杜甫江阁公众号\",{\"1\":{\"65\":1}}],[\"杜甫江阁\",{\"1\":{\"62\":1,\"65\":1}}],[\"岳麓书院公众号\",{\"1\":{\"65\":1}}],[\"岳麓书院\",{\"1\":{\"62\":1,\"65\":1}}],[\"岳麓山橘子洲旅游区公众号\",{\"1\":{\"65\":2}}],[\"岳麓山\",{\"1\":{\"62\":1,\"65\":1}}],[\"爱晚亭\",{\"1\":{\"62\":1}}],[\"坡子街\",{\"1\":{\"62\":1}}],[\"黄兴步行街\",{\"1\":{\"62\":1}}],[\"五一广场\",{\"1\":{\"62\":1}}],[\"橘子洲\",{\"1\":{\"62\":1,\"65\":1}}],[\"但还没有调用start\",{\"1\":{\"208\":1}}],[\"但在最坏情况下时间复杂度为o\",{\"1\":{\"150\":1}}],[\"但是可以通过以下几种方式中断线程的执行\",{\"1\":{\"213\":1}}],[\"但是需要记录状态\",{\"1\":{\"177\":1}}],[\"但是这里为了测试方便才使用单体架构\",{\"1\":{\"74\":1}}],[\"但是不适用于需要动态增加或删除元素的场景\",{\"1\":{\"58\":1}}],[\"但数据库的连接数却是有限的\",{\"1\":{\"27\":1}}],[\"综上所述\",{\"1\":{\"58\":1}}],[\"并提供了丰富的配置选项\",{\"1\":{\"212\":1}}],[\"并提高程序的可靠性\",{\"1\":{\"212\":1}}],[\"并递归调整堆\",{\"1\":{\"141\":1}}],[\"并有公司内部记录和管理\",{\"1\":{\"87\":1}}],[\"并由公司内部记录和管理\",{\"1\":{\"87\":1}}],[\"并发\",{\"0\":{\"233\":1},\"2\":{\"79\":1,\"210\":1,\"216\":1}}],[\"并发数\",{\"1\":{\"72\":1}}],[\"并发慢\",{\"1\":{\"27\":1}}],[\"并且不能动态改变\",{\"1\":{\"55\":1}}],[\"大于新元素\",{\"1\":{\"156\":1}}],[\"大顶堆的特点是父节点的值大于或等于其子节点的值\",{\"1\":{\"140\":1}}],[\"大\",{\"1\":{\"127\":2,\"169\":2}}],[\"大量的请求同时访问应用程序或系统\",{\"1\":{\"71\":1}}],[\"大小固定\",{\"0\":{\"55\":1}}],[\"大学\",{\"1\":{\"2\":1}}],[\"会预分配足够的内存空间用于存储元素\",{\"1\":{\"53\":1}}],[\"在java中\",{\"1\":{\"213\":1}}],[\"在剩下的元素中\",{\"1\":{\"169\":1}}],[\"在待排序的元素中\",{\"1\":{\"169\":1}}],[\"在已经排序的元素序列中从后向前扫描\",{\"1\":{\"156\":1}}],[\"在已排序序列中从后向前扫描\",{\"1\":{\"153\":1,\"156\":1}}],[\"在最坏情况下\",{\"1\":{\"156\":1}}],[\"在最坏的情况下\",{\"1\":{\"154\":1}}],[\"在最好情况下\",{\"1\":{\"155\":1,\"156\":1}}],[\"在这个分区退出之后\",{\"1\":{\"150\":1}}],[\"在创建数组时\",{\"1\":{\"53\":1}}],[\"在高并发场景下多个业务同时对一个数据库操作\",{\"1\":{\"27\":1}}],[\"修改等操作\",{\"1\":{\"52\":1}}],[\"修改数据\",{\"1\":{\"48\":3}}],[\"删除\",{\"1\":{\"52\":1}}],[\"灵活操作\",{\"0\":{\"52\":1}}],[\"可以根据实际需要来配置线程池的参数\",{\"1\":{\"212\":1}}],[\"可以避免过多的线程同时占用资源\",{\"1\":{\"212\":1}}],[\"可以采用随机选取基准\",{\"1\":{\"150\":1}}],[\"可以将时间复杂度从o\",{\"1\":{\"132\":1}}],[\"可以有效利用内存空间\",{\"1\":{\"53\":1}}],[\"可以通过索引对数组中的元素进行增加\",{\"1\":{\"52\":1}}],[\"可以通过索引直接访问数组中的元素\",{\"1\":{\"51\":1}}],[\"可以实现不同的数据写入需求\",{\"1\":{\"17\":1}}],[\"done\",{\"1\":{\"213\":1}}],[\"drxie\",{\"1\":{\"181\":1}}],[\"d\",{\"1\":{\"150\":2}}],[\"divide\",{\"1\":{\"150\":1}}],[\"digit\",{\"1\":{\"137\":5}}],[\"dianping\",{\"1\":{\"38\":1}}],[\"dn\",{\"1\":{\"136\":1}}],[\"details\",{\"1\":{\"48\":1}}],[\"接下来对剩下的数列\",{\"1\":{\"128\":1}}],[\"接\",{\"1\":{\"48\":1}}],[\"传\",{\"1\":{\"48\":1}}],[\"组件传值\",{\"1\":{\"48\":1}}],[\"workqueue\",{\"1\":{\"214\":1}}],[\"working\",{\"1\":{\"213\":1}}],[\"waiting\",{\"1\":{\"208\":2}}],[\"watcheffect\",{\"1\":{\"48\":1}}],[\"watch\",{\"1\":{\"48\":1}}],[\"win32\",{\"1\":{\"178\":1}}],[\"windows\",{\"1\":{\"178\":1}}],[\"while\",{\"1\":{\"137\":1,\"150\":3,\"156\":1,\"213\":4}}],[\"www\",{\"1\":{\"38\":1,\"48\":1}}],[\"监听器\",{\"1\":{\"48\":1}}],[\"暴露对象里面的字段\",{\"1\":{\"48\":1}}],[\"暴露数据和方法\",{\"1\":{\"48\":1}}],[\"源数据改变\",{\"1\":{\"48\":1}}],[\"视图不改变\",{\"1\":{\"48\":1}}],[\"视图改变\",{\"1\":{\"48\":2}}],[\"只需进行一次遍历\",{\"1\":{\"129\":1}}],[\"只看程序代码的方式\",{\"1\":{\"74\":1}}],[\"只能操作复杂数据对象\",{\"1\":{\"48\":1}}],[\"只存在内存\",{\"1\":{\"35\":1}}],[\"只存在binlog和业务回查的延迟\",{\"1\":{\"17\":1}}],[\"推荐用来操作基础数据\",{\"1\":{\"48\":1}}],[\"函数\",{\"0\":{\"48\":1}}],[\"40\",{\"1\":{\"150\":1}}],[\"40块\",{\"1\":{\"65\":1}}],[\"4c8g的硬件\",{\"1\":{\"74\":1}}],[\"4号线荣湾镇\",{\"1\":{\"65\":1}}],[\"4\",{\"1\":{\"45\":1,\"128\":14,\"156\":1,\"170\":11,\"172\":2}}],[\"4年工作经验\",{\"1\":{\"3\":1}}],[\"9\",{\"1\":{\"65\":1}}],[\"9765\",{\"1\":{\"45\":1}}],[\"9~2019\",{\"1\":{\"2\":1}}],[\"辅助索引b+树的高度为4\",{\"1\":{\"45\":1}}],[\"辅助索引最大是256byte\",{\"1\":{\"45\":1}}],[\"辅助索引找到主键\",{\"1\":{\"45\":1}}],[\"辅助索引的叶子节点存放的事主键值\",{\"1\":{\"45\":1}}],[\"辅助索引例子计算\",{\"0\":{\"45\":1}}],[\"3级缓存\",{\"1\":{\"74\":1}}],[\"3000\",{\"1\":{\"213\":1}}],[\"30\",{\"1\":{\"65\":2,\"150\":1}}],[\"3\",{\"0\":{\"53\":1,\"57\":1},\"1\":{\"44\":1,\"45\":1,\"64\":1,\"128\":14,\"156\":1,\"170\":9,\"172\":2}}],[\"2级缓存\",{\"1\":{\"74\":1}}],[\"21\",{\"1\":{\"65\":1}}],[\"23\",{\"1\":{\"65\":1}}],[\"22\",{\"1\":{\"65\":1}}],[\"24\",{\"1\":{\"48\":1}}],[\"256\",{\"1\":{\"45\":1}}],[\"2千万的数据\",{\"1\":{\"44\":1,\"45\":1}}],[\"2\",{\"0\":{\"52\":1,\"56\":1},\"1\":{\"44\":1,\"64\":1,\"141\":4,\"156\":1,\"170\":8,\"172\":2}}],[\"20\",{\"1\":{\"44\":1,\"45\":1,\"150\":1}}],[\"2015\",{\"1\":{\"2\":1}}],[\"8\",{\"1\":{\"44\":1,\"45\":1,\"128\":5}}],[\"聚簇索引例子计算\",{\"0\":{\"44\":1}}],[\"树高\",{\"1\":{\"43\":1,\"44\":1,\"45\":1}}],[\"+f\",{\"1\":{\"159\":1}}],[\"+=\",{\"1\":{\"137\":1}}],[\"++\",{\"1\":{\"137\":1}}],[\"+\",{\"1\":{\"43\":2,\"74\":3,\"141\":3,\"156\":2,\"213\":3}}],[\"=⎩⎨⎧​01f\",{\"1\":{\"159\":1}}],[\"==\",{\"1\":{\"137\":1}}],[\"=\",{\"1\":{\"43\":5,\"44\":7,\"45\":7,\"129\":6,\"137\":15,\"141\":13,\"150\":7,\"156\":6,\"172\":9,\"213\":8}}],[\"叶子节点存放数据\",{\"1\":{\"43\":1}}],[\"索引树高log\",{\"1\":{\"44\":1,\"45\":1}}],[\"索引数b\",{\"1\":{\"44\":1,\"45\":1}}],[\"索引的高度\",{\"1\":{\"43\":1}}],[\"索引大小x\",{\"1\":{\"44\":1,\"45\":1}}],[\"索引大小\",{\"1\":{\"43\":1}}],[\"索引列不参与计算\",{\"1\":{\"31\":1}}],[\"blocked\",{\"1\":{\"208\":1}}],[\"blog\",{\"1\":{\"48\":1}}],[\"before\",{\"1\":{\"150\":1}}],[\"build\",{\"1\":{\"140\":1}}],[\"bubblesort\",{\"1\":{\"129\":2}}],[\"bubble\",{\"1\":{\"126\":1}}],[\"back\",{\"1\":{\"96\":1}}],[\"book\",{\"1\":{\"96\":1}}],[\"b2b\",{\"1\":{\"87\":1}}],[\"b+树的高度为3\",{\"1\":{\"44\":1}}],[\"b\",{\"1\":{\"43\":2,\"44\":1,\"45\":1}}],[\"byte\",{\"1\":{\"43\":3}}],[\"binlog\",{\"1\":{\"35\":1}}],[\"keepalivetime\",{\"1\":{\"214\":1}}],[\"key\",{\"1\":{\"156\":3}}],[\"k\",{\"1\":{\"43\":2}}],[\"kafka\",{\"1\":{\"12\":1}}],[\"n−2\",{\"1\":{\"159\":1}}],[\"n−1\",{\"1\":{\"159\":1}}],[\"num\",{\"1\":{\"141\":2}}],[\"null\",{\"1\":{\"137\":1}}],[\"nlogn\",{\"1\":{\"140\":1,\"150\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"213\":1}}],[\"newfixedthreadpool\",{\"1\":{\"213\":3}}],[\"new\",{\"1\":{\"137\":2,\"208\":1}}],[\"net\",{\"1\":{\"48\":1}}],[\"n是待排序元素个数\",{\"1\":{\"136\":1}}],[\"n^2\",{\"1\":{\"129\":2,\"132\":1,\"150\":1,\"154\":1,\"156\":1,\"171\":1}}],[\"note\",{\"1\":{\"96\":1}}],[\"n\",{\"1\":{\"43\":2,\"56\":1,\"57\":1,\"129\":4,\"132\":1,\"141\":8,\"150\":2,\"155\":1,\"156\":3,\"159\":1,\"171\":1,\"172\":3}}],[\"总数\",{\"1\":{\"72\":1}}],[\"总结\",{\"0\":{\"58\":1},\"1\":{\"44\":1,\"45\":1}}],[\"总结下来\",{\"1\":{\"27\":1}}],[\"总记录n\",{\"1\":{\"44\":1,\"45\":1}}],[\"总记录数\",{\"1\":{\"43\":1}}],[\"总页数p\",{\"1\":{\"44\":1,\"45\":1}}],[\"总页数\",{\"1\":{\"43\":1}}],[\"语法解析原理\",{\"0\":{\"40\":1}}],[\"语法解析器应用场景\",{\"0\":{\"39\":1}}],[\"语言最终会被编译成指令在程序中运行\",{\"1\":{\"38\":1}}],[\"语言\",{\"1\":{\"3\":1}}],[\"美团开源的sql\",{\"1\":{\"38\":1}}],[\"开放时间\",{\"1\":{\"65\":1}}],[\"开福寺\",{\"1\":{\"62\":1}}],[\"开源的sql解析器\",{\"1\":{\"38\":1}}],[\"开发技能\",{\"0\":{\"3\":1}}],[\"phaser锁\",{\"0\":{\"202\":1}}],[\"pivot\",{\"1\":{\"150\":1}}],[\"printf\",{\"1\":{\"150\":6}}],[\"print\",{\"1\":{\"141\":1}}],[\"println\",{\"1\":{\"141\":1,\"172\":1,\"213\":5}}],[\"private\",{\"1\":{\"137\":1}}],[\"provide\",{\"1\":{\"48\":1}}],[\"prometheus\",{\"1\":{\"3\":1}}],[\"placevalue\",{\"1\":{\"137\":5}}],[\"pointers\",{\"1\":{\"132\":1}}],[\"posts\",{\"0\":{\"221\":1}}],[\"post\",{\"1\":{\"48\":1}}],[\"public\",{\"1\":{\"129\":2,\"137\":2,\"141\":3,\"150\":3,\"156\":2,\"172\":3,\"213\":2}}],[\"paxos一致性算法\",{\"0\":{\"117\":1}}],[\"parser\",{\"1\":{\"38\":1}}],[\"p\",{\"1\":{\"43\":2,\"44\":1,\"45\":1,\"178\":1}}],[\"由于堆排序是一种不稳定的排序算法\",{\"1\":{\"140\":1}}],[\"由于数据的更新操作都是在内存发生的\",{\"1\":{\"35\":1}}],[\"由专门的公司维护\",{\"1\":{\"38\":1}}],[\"磁盘\",{\"1\":{\"73\":1}}],[\"磁盘的数据是落后于内存的数据的\",{\"1\":{\"35\":1}}],[\"磁盘io可能成为瓶颈\",{\"1\":{\"27\":2}}],[\"还没有落入磁盘中\",{\"1\":{\"35\":1}}],[\"还需要改动商品代码\",{\"1\":{\"9\":1}}],[\"假设数据在提交事务后\",{\"1\":{\"35\":1}}],[\"如何停止线程池中的线程\",{\"0\":{\"213\":1}}],[\"如何解决aba问题\",{\"0\":{\"108\":1}}],[\"如何避免重复下单\",{\"0\":{\"107\":1}}],[\"如何保证内存的数据和磁盘的数据一致性\",{\"1\":{\"35\":1}}],[\"如待支付\",{\"1\":{\"103\":1}}],[\"如响应时间变慢\",{\"1\":{\"71\":1}}],[\"如果该元素\",{\"1\":{\"156\":1}}],[\"如果largest不是当前节点\",{\"1\":{\"141\":1}}],[\"如果右子节点比当前节点大\",{\"1\":{\"141\":1}}],[\"如果左子节点比当前节点大\",{\"1\":{\"141\":1}}],[\"如果他们的顺序错误就把他们交换过来\",{\"1\":{\"126\":1}}],[\"如果设计一个高并发的系统\",{\"1\":{\"74\":1}}],[\"如果需要删除数组中的中间元素\",{\"1\":{\"57\":1}}],[\"如果需要在数组的中间插入元素\",{\"1\":{\"56\":1}}],[\"如果需要存储更多的元素\",{\"1\":{\"55\":1}}],[\"如果实在无法优化\",{\"1\":{\"32\":1}}],[\"如果写入数据会导致b+树的索引结构变化\",{\"1\":{\"27\":1}}],[\"如果写不会导致b+树结构变化\",{\"1\":{\"27\":1}}],[\"作用\",{\"1\":{\"35\":1}}],[\"的元素\",{\"1\":{\"169\":2}}],[\"的一个元素\",{\"1\":{\"168\":1}}],[\"的空间复杂度\",{\"1\":{\"154\":1,\"155\":1}}],[\"的时间复杂度和o\",{\"1\":{\"154\":1,\"155\":1}}],[\"的思想\",{\"1\":{\"150\":1}}],[\"的作用就是用来保证磁盘和内存数据的一致性\",{\"1\":{\"35\":1}}],[\"的\",{\"1\":{\"35\":1}}],[\"的分布式缓存策略\",{\"1\":{\"3\":1}}],[\"时间单位\",{\"1\":{\"214\":1}}],[\"时间\",{\"1\":{\"214\":1}}],[\"时间复杂度\",{\"0\":{\"154\":1,\"171\":1}}],[\"时间复杂度为o\",{\"1\":{\"51\":1,\"56\":1,\"57\":1,\"129\":3}}],[\"时\",{\"1\":{\"35\":2}}],[\"l\",{\"0\":{\"222\":1},\"1\":{\"150\":5}}],[\"learnwin32\",{\"1\":{\"178\":1}}],[\"learn\",{\"1\":{\"178\":1}}],[\"left\",{\"1\":{\"141\":4}}],[\"length\",{\"1\":{\"129\":1,\"137\":7,\"141\":1,\"150\":4,\"156\":1,\"172\":1}}],[\"largest\",{\"1\":{\"141\":8}}],[\"log\",{\"1\":{\"35\":5,\"43\":1}}],[\"linux\",{\"1\":{\"3\":1}}],[\"其他线程\",{\"1\":{\"208\":1}}],[\"其中d是数字的最大位数\",{\"1\":{\"136\":1}}],[\"其中\",{\"1\":{\"35\":1,\"171\":1}}],[\"其实更多是写锁导致的并发性能问题\",{\"1\":{\"27\":1}}],[\"最大线程数\",{\"1\":{\"214\":1}}],[\"最终得到的数组为\",{\"1\":{\"170\":1}}],[\"最终得到的数组就是一个有序的数组\",{\"1\":{\"140\":1}}],[\"最终将所有位数上的排序结果合并在一起\",{\"1\":{\"136\":1}}],[\"最终选用数据订阅方式\",{\"1\":{\"93\":1}}],[\"最坏情况\",{\"1\":{\"129\":1}}],[\"最好情况\",{\"1\":{\"129\":1}}],[\"最后交给存储引擎执行sql\",{\"1\":{\"35\":1}}],[\"最左前缀匹配原则\",{\"1\":{\"31\":1}}],[\"看看是否折中的方案实现业务\",{\"1\":{\"32\":1}}],[\"制定方案优化sql\",{\"1\":{\"32\":1}}],[\"尽量扩展索引\",{\"1\":{\"31\":1}}],[\"优化原则\",{\"0\":{\"31\":1}}],[\"优点\",{\"0\":{\"8\":1,\"11\":1,\"14\":1,\"17\":1}}],[\"导致资源浪费和系统负载过高\",{\"1\":{\"212\":1}}],[\"导致系统出现性能瓶颈\",{\"1\":{\"71\":1}}],[\"导致后续数据库无法正常访问\",{\"1\":{\"27\":1}}],[\"导致innodb的存储文件<表名>\",{\"1\":{\"27\":2}}],[\"很容易将连接数耗尽导致too\",{\"1\":{\"27\":1}}],[\"这样可以保证任务的执行质量\",{\"1\":{\"212\":1}}],[\"这样可以避免线程的创建和销毁带来的开销\",{\"1\":{\"212\":1}}],[\"这种数据结构进行选择排序的一种算法\",{\"1\":{\"140\":1}}],[\"这种算法通常用于解决一些排序或统计的问题\",{\"1\":{\"132\":1}}],[\"这种算法通常用于解决一些查找或筛选的问题\",{\"1\":{\"132\":1}}],[\"这种情况下\",{\"1\":{\"132\":2}}],[\"这种方式是串行的\",{\"1\":{\"27\":1}}],[\"这里网络不会成为卡点\",{\"1\":{\"74\":1}}],[\"这里用控制变量法去控制其他因素保持不变\",{\"1\":{\"74\":1}}],[\"这个时候再将差异的数据写入磁盘中\",{\"1\":{\"35\":1}}],[\"这个时候发生了断电\",{\"1\":{\"35\":1}}],[\"这是innodb的写入操作流程\",{\"1\":{\"35\":1}}],[\"这是mysql架构组件执行流程\",{\"1\":{\"35\":1}}],[\"这是我的个人简历\",{\"1\":{\"1\":1}}],[\"那么语言本身是可以被解析\",{\"1\":{\"38\":1}}],[\"那么断电恢复后\",{\"1\":{\"35\":1}}],[\"那么redo\",{\"1\":{\"35\":1}}],[\"那么如果断电后\",{\"1\":{\"35\":1}}],[\"那么是分段悲观锁写入的方式\",{\"1\":{\"27\":1}}],[\"那么是用乐观锁写入\",{\"1\":{\"27\":1}}],[\"那么elasticsearch和mysql的数据无法保证一致\",{\"1\":{\"9\":1}}],[\"写入文件\",{\"1\":{\"27\":1}}],[\"写入elasticsearch出现网络异常\",{\"1\":{\"9\":1}}],[\"写慢\",{\"1\":{\"27\":1}}],[\"查找数组中的环形子数组等\",{\"1\":{\"132\":1}}],[\"查找\",{\"1\":{\"27\":1}}],[\"查询接口将版本返回给调用方\",{\"1\":{\"108\":1}}],[\"查询商品详情\",{\"1\":{\"89\":1}}],[\"查询\",{\"1\":{\"3\":1}}],[\"读写锁机制更新索引b+树\",{\"1\":{\"27\":1}}],[\"读取文件\",{\"1\":{\"27\":2}}],[\"读慢\",{\"1\":{\"27\":1}}],[\"例如控制任务的执行顺序\",{\"1\":{\"212\":1}}],[\"例如验证只包含相同字符的最长子串\",{\"1\":{\"132\":1}}],[\"例如查找两个数的和等于目标值\",{\"1\":{\"132\":1}}],[\"例如\",{\"1\":{\"17\":1,\"150\":2}}],[\"客户端的写入适配器\",{\"1\":{\"17\":1}}],[\"良好的扩展行\",{\"1\":{\"17\":1}}],[\"利用canal组件即可无需在商品代码上做改动\",{\"1\":{\"17\":1}}],[\"利用canal订阅mysql的binlog做到解耦合\",{\"1\":{\"17\":1}}],[\"无缓存\",{\"1\":{\"74\":1}}],[\"无法删除中间元素\",{\"0\":{\"57\":1}}],[\"无法插入中间元素\",{\"0\":{\"56\":1}}],[\"无法保证实时性\",{\"1\":{\"15\":1}}],[\"无业务侵入\",{\"1\":{\"17\":1}}],[\"存放在序列的起始位置\",{\"1\":{\"168\":1}}],[\"存在mq延迟\",{\"1\":{\"12\":1}}],[\"存储系统\",{\"1\":{\"3\":1}}],[\"准实时\",{\"1\":{\"12\":1,\"17\":1}}],[\"商品信息\",{\"1\":{\"103\":1}}],[\"商品\",{\"1\":{\"92\":1}}],[\"商品副标题\",{\"1\":{\"91\":1}}],[\"商品标题\",{\"1\":{\"91\":1}}],[\"商品标签\",{\"1\":{\"91\":1,\"92\":1}}],[\"商品类目\",{\"1\":{\"91\":1,\"92\":1}}],[\"商品模型\",{\"0\":{\"90\":1}}],[\"商品核心功能\",{\"0\":{\"89\":1}}],[\"商品物流\",{\"1\":{\"88\":1}}],[\"商品售卖\",{\"1\":{\"88\":1}}],[\"商品上下游模块依赖\",{\"0\":{\"88\":1}}],[\"商品定价\",{\"1\":{\"87\":1}}],[\"商品描述\",{\"1\":{\"87\":1,\"91\":1}}],[\"商品规格\",{\"1\":{\"87\":1,\"92\":1}}],[\"商品来源\",{\"1\":{\"87\":1,\"88\":1}}],[\"商品的职责有哪些\",{\"0\":{\"87\":1}}],[\"商品本身无需关注同步elasticsearch的逻辑\",{\"1\":{\"11\":1}}],[\"商品业务和搜索业务强耦合\",{\"1\":{\"9\":1}}],[\"需要进行n\",{\"1\":{\"129\":2}}],[\"需要将后面的元素都向前移动一位\",{\"1\":{\"57\":1}}],[\"需要将后面的元素都向后移动一位\",{\"1\":{\"56\":1}}],[\"需要重新创建一个更大的数组\",{\"1\":{\"55\":1}}],[\"需要分库分表的情况无非是数据库性能无法满足业务要求\",{\"1\":{\"27\":1}}],[\"需要考虑额外组件的可靠性\",{\"1\":{\"12\":1}}],[\"需要额外保证一致性\",{\"1\":{\"9\":1}}],[\"需要定制搜索需求需求时\",{\"1\":{\"9\":1}}],[\"和运行中\",{\"1\":{\"208\":1}}],[\"和arr\",{\"1\":{\"129\":1}}],[\"和\",{\"1\":{\"9\":1}}],[\"扩展性差\",{\"1\":{\"9\":1}}],[\"缺点\",{\"0\":{\"9\":1,\"12\":1,\"15\":1}}],[\"数学公式如下\",{\"1\":{\"159\":1}}],[\"数列还是\",{\"1\":{\"128\":5}}],[\"数列变成\",{\"1\":{\"128\":5}}],[\"数组保持不变\",{\"1\":{\"170\":2}}],[\"数组变为\",{\"1\":{\"170\":3}}],[\"数组适用于元素数量固定且需要直接访问的场景\",{\"1\":{\"58\":1}}],[\"数组的右边界\",{\"1\":{\"150\":1}}],[\"数组的左边界\",{\"1\":{\"150\":1}}],[\"数组的大小在创建时就需要确定\",{\"1\":{\"55\":1}}],[\"数组的主要缺点包括\",{\"0\":{\"54\":1}}],[\"数组的主要优点包括\",{\"0\":{\"50\":1}}],[\"数组是一种线性数据结构\",{\"1\":{\"49\":1}}],[\"数组\",{\"0\":{\"49\":1},\"2\":{\"60\":1,\"134\":1}}],[\"数据结构\",{\"0\":{\"224\":1},\"2\":{\"59\":1,\"60\":1}}],[\"数据库固定\",{\"1\":{\"74\":1}}],[\"数据库\",{\"1\":{\"73\":1}}],[\"数据库页大小\",{\"1\":{\"43\":1}}],[\"数据库指针大小\",{\"1\":{\"43\":1}}],[\"数据量过大\",{\"1\":{\"27\":2}}],[\"数据订阅\",{\"0\":{\"16\":1},\"1\":{\"6\":1}}],[\"数仓\",{\"1\":{\"3\":1}}],[\"定时任务\",{\"0\":{\"13\":1},\"1\":{\"6\":1}}],[\"异步双写\",{\"0\":{\"10\":1},\"1\":{\"6\":1}}],[\"同步双写\",{\"0\":{\"7\":1},\"1\":{\"6\":1}}],[\"框架\",{\"1\":{\"3\":1}}],[\"实时图表\",{\"1\":{\"176\":1}}],[\"实时计算任务\",{\"1\":{\"3\":1}}],[\"实现选择排序的示例代码\",{\"1\":{\"172\":1}}],[\"实现步骤\",{\"0\":{\"137\":1}}],[\"实现持久性和一致性\",{\"1\":{\"35\":1}}],[\"实现原理\",{\"1\":{\"3\":2}}],[\"离线计算任务\",{\"1\":{\"3\":1}}],[\"catch\",{\"1\":{\"213\":1}}],[\"cancel\",{\"1\":{\"213\":3}}],[\"canal组件还支持各种数据库\",{\"1\":{\"17\":1}}],[\"currentthread\",{\"1\":{\"213\":6}}],[\"cyclicbarrier锁\",{\"0\":{\"199\":1}}],[\"chinese\",{\"1\":{\"181\":1}}],[\"cn\",{\"1\":{\"178\":1}}],[\"class\",{\"1\":{\"129\":1,\"137\":1,\"141\":1,\"150\":1,\"156\":1,\"172\":1,\"213\":1}}],[\"clickhouse\",{\"1\":{\"3\":1}}],[\"c2b\",{\"1\":{\"87\":1}}],[\"cpu\",{\"1\":{\"72\":1,\"73\":1}}],[\"cpu内存查找\",{\"1\":{\"27\":1}}],[\"cpu内存查找可能成为瓶颈\",{\"1\":{\"27\":1}}],[\"csdn\",{\"1\":{\"48\":1}}],[\"c\",{\"1\":{\"43\":2}}],[\"corepoolsize\",{\"1\":{\"214\":1}}],[\"concurrent\",{\"1\":{\"213\":1}}],[\"conquer\",{\"1\":{\"150\":1}}],[\"connections报错\",{\"1\":{\"27\":1}}],[\"countdownlatch锁\",{\"0\":{\"196\":1}}],[\"count\",{\"1\":{\"137\":7}}],[\"countingsort\",{\"1\":{\"137\":2}}],[\"computed计算属性\",{\"1\":{\"48\":1}}],[\"com\",{\"1\":{\"0\":1,\"2\":1,\"38\":2,\"48\":1,\"178\":2,\"181\":1}}],[\"架构\",{\"0\":{\"226\":1},\"1\":{\"3\":1},\"2\":{\"78\":1,\"79\":1}}],[\"策略\",{\"1\":{\"3\":1}}],[\"timeout\",{\"1\":{\"214\":2}}],[\"timed\",{\"1\":{\"208\":1}}],[\"try\",{\"1\":{\"213\":2}}],[\"true\",{\"1\":{\"213\":2}}],[\"throws\",{\"1\":{\"213\":1}}],[\"threadfactory\",{\"1\":{\"214\":1}}],[\"thread\",{\"1\":{\"213\":10}}],[\"thread类是一个实现了runnable接口的类\",{\"1\":{\"208\":1}}],[\"terminated\",{\"1\":{\"208\":1}}],[\"temp\",{\"1\":{\"129\":2,\"141\":2,\"172\":2}}],[\"ttf\",{\"2\":{\"183\":1}}],[\"tab=readme\",{\"1\":{\"181\":1}}],[\"two\",{\"1\":{\"132\":1}}],[\"to\",{\"1\":{\"213\":1}}],[\"tostring\",{\"1\":{\"172\":1}}],[\"torefs\",{\"1\":{\"48\":1}}],[\"toref\",{\"1\":{\"48\":1}}],[\"todo\",{\"1\":{\"0\":1}}],[\"tcc\",{\"1\":{\"3\":1}}],[\"x\",{\"1\":{\"43\":2,\"150\":5}}],[\"xxl\",{\"1\":{\"3\":1}}],[\"xa\",{\"1\":{\"3\":1}}],[\"掌握常见监控告警设计\",{\"1\":{\"3\":1}}],[\"掌握常见分布式事务设计\",{\"1\":{\"3\":1}}],[\"掌握数据仓库设计\",{\"1\":{\"3\":1}}],[\"掌握基于\",{\"1\":{\"3\":1}}],[\"掌握分布式调度设计\",{\"1\":{\"3\":1}}],[\"掌握分布式缓存设计\",{\"1\":{\"3\":1}}],[\"掌握分布式存储设计\",{\"1\":{\"3\":1}}],[\"掌握复杂\",{\"1\":{\"3\":1}}],[\"脚手架\",{\"1\":{\"3\":1}}],[\"脚本\",{\"1\":{\"3\":1}}],[\"微服务分布式架构实现\",{\"1\":{\"3\":1}}],[\"全家桶\",{\"1\":{\"3\":1}}],[\"全日制统招本科\",{\"1\":{\"2\":1}}],[\"系统生态\",{\"1\":{\"3\":1}}],[\"系统\",{\"1\":{\"3\":1}}],[\"分别从数组或链表的两端向中间移动\",{\"1\":{\"132\":1}}],[\"分布式架构\",{\"1\":{\"73\":1}}],[\"分布式事务管理\",{\"1\":{\"3\":1}}],[\"分库分表\",{\"1\":{\"3\":1}}],[\"my\",{\"0\":{\"222\":1}}],[\"mysql索引b+树高度计算\",{\"0\":{\"43\":1}}],[\"mysql源码的解析器\",{\"1\":{\"38\":1}}],[\"mysql的缓存忽略不计\",{\"1\":{\"74\":1}}],[\"mysql的语法解析器\",{\"0\":{\"38\":1}}],[\"mysql的sql执行过程\",{\"0\":{\"35\":1}}],[\"mysql慢查询优化\",{\"0\":{\"30\":1}}],[\"mysql需要先将ibd文件读取到内存中进行查找写入位置\",{\"1\":{\"27\":1}}],[\"mysql需要先将ibd文件读取到内存中进行查找\",{\"1\":{\"27\":1}}],[\"mysql分库分表\",{\"0\":{\"26\":1}}],[\"mysql事务\",{\"0\":{\"23\":1}}],[\"mysql事务提交之后\",{\"1\":{\"9\":1}}],[\"mysql主从复制\",{\"0\":{\"20\":1}}],[\"mysql同步数据es\",{\"0\":{\"6\":1},\"1\":{\"93\":1}}],[\"mysql\",{\"1\":{\"3\":3,\"9\":1,\"35\":1,\"73\":1,\"74\":2},\"2\":{\"19\":1,\"21\":1,\"22\":1,\"24\":1,\"25\":1,\"28\":1,\"29\":1,\"33\":1,\"34\":1,\"36\":1,\"37\":1,\"41\":1,\"42\":1,\"46\":1,\"47\":1}}],[\"mode\",{\"1\":{\"178\":2}}],[\"microsoft\",{\"1\":{\"178\":1}}],[\"minindex\",{\"1\":{\"172\":5}}],[\"main\",{\"1\":{\"141\":1,\"150\":1,\"172\":1,\"213\":2}}],[\"maximumpoolsize\",{\"1\":{\"214\":1}}],[\"max\",{\"1\":{\"140\":1}}],[\"maxnum\",{\"1\":{\"137\":4}}],[\"many\",{\"1\":{\"27\":1}}],[\"md\",{\"1\":{\"83\":1,\"86\":1,\"93\":1,\"96\":1,\"99\":1,\"102\":1,\"111\":1}}],[\"meituan\",{\"1\":{\"38\":1}}],[\"mvcc\",{\"1\":{\"3\":1}}],[\"after\",{\"1\":{\"150\":1}}],[\"a\",{\"1\":{\"150\":17}}],[\"and\",{\"1\":{\"150\":1}}],[\"algorithm\",{\"1\":{\"132\":1}}],[\"args\",{\"1\":{\"141\":1,\"150\":1,\"172\":1,\"213\":1}}],[\"arrays\",{\"1\":{\"172\":1}}],[\"array\",{\"1\":{\"156\":7}}],[\"arraycopy\",{\"1\":{\"137\":1}}],[\"arr\",{\"1\":{\"129\":8,\"137\":17,\"141\":20,\"172\":11}}],[\"article\",{\"1\":{\"48\":1}}],[\"api接口调用等方式\",{\"1\":{\"103\":1}}],[\"advisor\",{\"1\":{\"38\":1}}],[\"acid\",{\"1\":{\"3\":1}}],[\"agent\",{\"1\":{\"3\":1}}],[\"了解索引实现机制\",{\"1\":{\"3\":1}}],[\"了解\",{\"1\":{\"3\":4}}],[\"对应的序列是逆序的\",{\"1\":{\"156\":1}}],[\"对应的序列是已排序的\",{\"1\":{\"156\":1}}],[\"对应的解析器有哪些实现\",{\"1\":{\"38\":1}}],[\"对未排序数据\",{\"1\":{\"153\":1,\"156\":1}}],[\"对基准的左右两个分区重复步骤1和步骤2\",{\"1\":{\"150\":1}}],[\"对交换后的元素进行调整\",{\"1\":{\"141\":1}}],[\"对堆进行调整\",{\"1\":{\"140\":1}}],[\"对最末位进行排序\",{\"1\":{\"137\":1}}],[\"对数列\",{\"1\":{\"128\":1}}],[\"对\",{\"1\":{\"3\":1}}],[\"熟练编写\",{\"1\":{\"3\":1}}],[\"熟练\",{\"1\":{\"3\":1}}],[\"熟练使用常见的分布式调度平台\",{\"1\":{\"3\":1}}],[\"熟练使用\",{\"1\":{\"3\":2}}],[\"熟悉线上运维命令\",{\"1\":{\"3\":1}}],[\"熟悉常见\",{\"1\":{\"3\":1}}],[\"熟悉读写分离策略\",{\"1\":{\"3\":1}}],[\"熟悉\",{\"1\":{\"3\":6}}],[\"heapify\",{\"1\":{\"141\":4}}],[\"heapsort\",{\"1\":{\"141\":1}}],[\"heap\",{\"1\":{\"140\":4}}],[\"html\",{\"1\":{\"48\":1}}],[\"https\",{\"1\":{\"0\":1,\"38\":2,\"48\":2,\"96\":1,\"178\":2,\"181\":2}}],[\"h\",{\"1\":{\"43\":2}}],[\"hbase\",{\"1\":{\"3\":1,\"17\":1}}],[\"handler\",{\"1\":{\"214\":1}}],[\"hadoop\",{\"1\":{\"3\":1}}],[\"ha\",{\"1\":{\"3\":1}}],[\"主从复制策略\",{\"1\":{\"3\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"工作法\",{\"1\":{\"3\":1}}],[\"精通\",{\"1\":{\"3\":2}}],[\"精通业务关系建模\",{\"1\":{\"3\":1}}],[\"绘制系统架构图\",{\"1\":{\"3\":1}}],[\"能够独立设计大型复杂系统\",{\"1\":{\"3\":1}}],[\"juc\",{\"2\":{\"198\":1,\"201\":1,\"204\":1}}],[\"j+1\",{\"1\":{\"129\":4}}],[\"j++\",{\"1\":{\"129\":1,\"172\":1}}],[\"j\",{\"1\":{\"129\":6,\"141\":3,\"150\":11,\"156\":7,\"172\":4}}],[\"job\",{\"1\":{\"3\":1}}],[\"jvm垃圾回收\",{\"0\":{\"193\":1}}],[\"jvm参数调优\",{\"0\":{\"190\":1}}],[\"jvm内存模型\",{\"0\":{\"187\":1}}],[\"jvm\",{\"0\":{\"231\":1},\"1\":{\"3\":1,\"72\":1},\"2\":{\"189\":1,\"192\":1,\"195\":1}}],[\"java框架\",{\"0\":{\"235\":1}}],[\"java线程池的设计思想是基于生产者\",{\"1\":{\"212\":1}}],[\"java线程池的设计思想是为了提高线程的使用效率和响应能力\",{\"1\":{\"212\":1}}],[\"java线程池通过threadpoolexecutor类来实现\",{\"1\":{\"212\":1}}],[\"java线程池可以对任务的执行进行管理\",{\"1\":{\"212\":1}}],[\"java线程池可以快速响应任务的提交和执行\",{\"1\":{\"212\":1}}],[\"java线程池可以控制线程的数量\",{\"1\":{\"212\":1}}],[\"java线程池中的线程可以被重复使用\",{\"1\":{\"212\":1}}],[\"java线程池主要具有以下设计思想\",{\"1\":{\"212\":1}}],[\"java线程中将就绪\",{\"1\":{\"208\":1}}],[\"java中的线程有以下几种状态\",{\"1\":{\"208\":1}}],[\"java中的线程由thread类和runnable接口实现\",{\"1\":{\"208\":1}}],[\"java的线程是程序执行的最小单位\",{\"1\":{\"208\":1}}],[\"java代码实现\",{\"0\":{\"156\":1}}],[\"java实现\",{\"0\":{\"141\":1}}],[\"javalc\",{\"1\":{\"48\":1}}],[\"java\",{\"0\":{\"232\":1},\"1\":{\"0\":1,\"3\":2,\"74\":1,\"172\":1,\"213\":1},\"2\":{\"19\":1,\"22\":1,\"25\":1,\"29\":1,\"34\":1,\"37\":1,\"42\":1,\"47\":1,\"85\":1,\"95\":1,\"98\":1,\"101\":1,\"110\":1,\"113\":1,\"188\":1,\"189\":1,\"191\":1,\"192\":1,\"194\":1,\"195\":1,\"197\":1,\"198\":1,\"200\":1,\"201\":1,\"203\":1,\"204\":1,\"206\":1,\"207\":1,\"209\":1,\"210\":1,\"215\":1,\"216\":1,\"218\":1,\"219\":1}}],[\"s\",{\"0\":{\"222\":1}}],[\"sleep\",{\"1\":{\"213\":2}}],[\"swap\",{\"1\":{\"141\":3}}],[\"system\",{\"1\":{\"137\":1,\"141\":2,\"150\":6,\"172\":1,\"213\":5}}],[\"status\",{\"1\":{\"213\":2}}],[\"static\",{\"1\":{\"129\":1,\"137\":2,\"141\":4,\"150\":2,\"156\":1,\"172\":2,\"213\":1}}],[\"string\",{\"1\":{\"141\":1,\"150\":1,\"172\":1,\"213\":1}}],[\"storage\",{\"1\":{\"96\":1}}],[\"sort\",{\"1\":{\"126\":1,\"140\":2,\"141\":2,\"150\":2,\"156\":2}}],[\"submit\",{\"1\":{\"213\":4}}],[\"supming1\",{\"1\":{\"48\":1}}],[\"suveng\",{\"1\":{\"2\":1}}],[\"search\",{\"0\":{\"220\":1}}],[\"seata\",{\"1\":{\"3\":1}}],[\"selectionsort\",{\"1\":{\"172\":3}}],[\"setup\",{\"1\":{\"48\":1}}],[\"schedulex\",{\"1\":{\"3\":1}}],[\"shutdown\",{\"1\":{\"213\":1}}],[\"shutdownnow\",{\"1\":{\"213\":3}}],[\"shallowreactive\",{\"1\":{\"48\":1}}],[\"shallowref\",{\"1\":{\"48\":1}}],[\"sharding\",{\"1\":{\"3\":1}}],[\"shell\",{\"1\":{\"3\":1}}],[\"springbean的生命周期\",{\"0\":{\"217\":1}}],[\"springblade\",{\"1\":{\"3\":1}}],[\"springcloud\",{\"1\":{\"3\":1}}],[\"spring\",{\"0\":{\"234\":1},\"1\":{\"3\":1}}],[\"sphere\",{\"1\":{\"3\":1}}],[\"spi\",{\"1\":{\"3\":1}}],[\"sql分析监控\",{\"1\":{\"39\":1}}],[\"sqladvisor\",{\"1\":{\"38\":1}}],[\"sqlparser\",{\"1\":{\"38\":1}}],[\"sql本身是一种程序语言\",{\"1\":{\"38\":1}}],[\"sql\",{\"1\":{\"3\":3,\"38\":1}}],[\"反射\",{\"1\":{\"3\":1}}],[\"import\",{\"1\":{\"213\":1}}],[\"immediate\",{\"1\":{\"178\":1}}],[\"iscancelled\",{\"1\":{\"213\":1}}],[\"isdone\",{\"1\":{\"213\":1}}],[\"isinterrupted\",{\"1\":{\"213\":4}}],[\"ist`ure\",{\"1\":{\"0\":1}}],[\"i<a\",{\"1\":{\"150\":2}}],[\"i=0\",{\"1\":{\"150\":2}}],[\"i+1\",{\"1\":{\"150\":1,\"172\":1}}],[\"i++\",{\"1\":{\"129\":1,\"137\":3,\"150\":4,\"156\":1,\"172\":1}}],[\"if\",{\"1\":{\"129\":1,\"137\":2,\"141\":3,\"150\":3,\"172\":1,\"213\":2}}],[\"ifs国金中心\",{\"1\":{\"62\":1}}],[\"i\",{\"1\":{\"129\":3,\"137\":16,\"141\":18,\"150\":15,\"156\":4,\"172\":5}}],[\"insertionsort\",{\"1\":{\"156\":1}}],[\"insertion\",{\"1\":{\"156\":1}}],[\"index\",{\"1\":{\"137\":2}}],[\"interrupt\",{\"1\":{\"213\":2}}],[\"interruptedexception\",{\"1\":{\"213\":1}}],[\"interrupted\",{\"1\":{\"213\":2}}],[\"int\",{\"1\":{\"129\":5,\"137\":17,\"141\":16,\"150\":6,\"156\":5,\"172\":7}}],[\"inject\",{\"1\":{\"48\":1}}],[\"innodb会从redo\",{\"1\":{\"35\":1}}],[\"innodb\",{\"1\":{\"35\":1}}],[\"innodb存储引擎执行过程\",{\"1\":{\"35\":1}}],[\"ibd过大\",{\"1\":{\"27\":2}}],[\"io\",{\"1\":{\"3\":1,\"72\":1,\"96\":1,\"181\":1}}],[\"邮箱\",{\"1\":{\"2\":1}}],[\"手机号\",{\"1\":{\"2\":1}}],[\"60\",{\"1\":{\"150\":1}}],[\"62\",{\"1\":{\"45\":1}}],[\"6\",{\"1\":{\"2\":1,\"43\":2,\"65\":1,\"128\":9,\"141\":1,\"156\":1}}],[\"韩山师范学院\",{\"1\":{\"2\":1}}],[\"13\",{\"1\":{\"141\":1}}],[\"10\",{\"1\":{\"137\":5,\"150\":1}}],[\"1024\",{\"1\":{\"43\":2,\"44\":1}}],[\"1次遍历\",{\"1\":{\"129\":2}}],[\"18\",{\"1\":{\"65\":1}}],[\"18320664028\",{\"1\":{\"2\":1}}],[\"11\",{\"1\":{\"141\":1}}],[\"11块\",{\"1\":{\"65\":1}}],[\"1170\",{\"1\":{\"44\":1}}],[\"1\",{\"0\":{\"51\":1,\"55\":1},\"1\":{\"43\":1,\"51\":1,\"64\":1,\"129\":2,\"137\":7,\"140\":1,\"141\":3,\"150\":3,\"154\":1,\"155\":1,\"156\":5,\"170\":8,\"172\":3}}],[\"16\",{\"1\":{\"43\":2}}],[\"16kb\",{\"1\":{\"43\":1}}],[\"163\",{\"1\":{\"2\":1}}],[\"121267418\",{\"1\":{\"48\":1}}],[\"1250000\",{\"1\":{\"44\":1}}],[\"12\",{\"1\":{\"2\":1,\"141\":1}}],[\"1996\",{\"1\":{\"2\":1}}],[\"男\",{\"1\":{\"2\":1}}],[\"性别\",{\"1\":{\"2\":1}}],[\"姓名\",{\"1\":{\"2\":1}}],[\"个人信息\",{\"0\":{\"2\":1}}],[\"介绍页\",{\"0\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
