const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":127,\"nextId\":127,\"documentIds\":{\"0\":\"v-858cfdd6\",\"1\":\"v-858cfdd6#个人信息\",\"2\":\"v-858cfdd6#开发技能\",\"3\":\"v-858cfdd6@0\",\"4\":\"v-858cfdd6@1\",\"5\":\"v-23a3277c\",\"6\":\"v-23a3277c#同步双写\",\"7\":\"v-23a3277c#异步双写\",\"8\":\"v-23a3277c#定时任务\",\"9\":\"v-23a3277c#数据订阅\",\"10\":\"v-23a3277c@0\",\"11\":\"v-23a3277c@1\",\"12\":\"v-4aba7d42\",\"13\":\"v-4aba7d42@0\",\"14\":\"v-4aba7d42@1\",\"15\":\"v-715bd40c\",\"16\":\"v-715bd40c#线程池设计思想\",\"17\":\"v-715bd40c#如何停止线程池中的线程\",\"18\":\"v-715bd40c#线程池的核心参数\",\"19\":\"v-715bd40c@0\",\"20\":\"v-715bd40c@1\",\"21\":\"v-966f2e04\",\"22\":\"v-966f2e04#数组的主要优点包括\",\"23\":\"v-966f2e04#_1-直接访问\",\"24\":\"v-966f2e04#_2-灵活操作\",\"25\":\"v-966f2e04#_3-空间有效利用\",\"26\":\"v-966f2e04#数组的主要缺点包括\",\"27\":\"v-966f2e04#_1-大小固定\",\"28\":\"v-966f2e04#_2-无法插入中间元素\",\"29\":\"v-966f2e04#_3-无法删除中间元素\",\"30\":\"v-966f2e04#总结\",\"31\":\"v-966f2e04@0\",\"32\":\"v-966f2e04@1\",\"33\":\"v-6e83e7f2\",\"34\":\"v-6e83e7f2@0\",\"35\":\"v-6e83e7f2@1\",\"36\":\"v-07deb444\",\"37\":\"v-07deb444@0\",\"38\":\"v-07deb444@1\",\"39\":\"v-7f3bcc24\",\"40\":\"v-7f3bcc24#商品的职责有哪些\",\"41\":\"v-7f3bcc24#商品上下游模块依赖\",\"42\":\"v-7f3bcc24#商品核心功能\",\"43\":\"v-7f3bcc24#商品模型\",\"44\":\"v-7f3bcc24#搜索商品列表高性能低延时方案\",\"45\":\"v-7f3bcc24#es数据映射\",\"46\":\"v-7f3bcc24#es数据同步方案\",\"47\":\"v-7f3bcc24@0\",\"48\":\"v-7f3bcc24@1\",\"49\":\"v-ad1c3c84\",\"50\":\"v-ad1c3c84@0\",\"51\":\"v-ad1c3c84@1\",\"52\":\"v-15048e98\",\"53\":\"v-15048e98@0\",\"54\":\"v-15048e98@1\",\"55\":\"v-39f55f6b\",\"56\":\"v-39f55f6b#电商订单的职责\",\"57\":\"v-39f55f6b#核心api\",\"58\":\"v-39f55f6b#订单状态机设计\",\"59\":\"v-39f55f6b#注意的场景\",\"60\":\"v-39f55f6b#如何避免重复下单\",\"61\":\"v-39f55f6b#如何解决aba问题-网络异常情况下-请求顺序不一致导致数据错乱\",\"62\":\"v-39f55f6b@0\",\"63\":\"v-39f55f6b@1\",\"64\":\"v-3b3d9a8a\",\"65\":\"v-3b3d9a8a@0\",\"66\":\"v-3b3d9a8a@1\",\"67\":\"v-ba177c94\",\"68\":\"v-ba177c94#算法描述\",\"69\":\"v-ba177c94#示例\",\"70\":\"v-ba177c94#复杂度分析\",\"71\":\"v-ba177c94@0\",\"72\":\"v-ba177c94@1\",\"73\":\"v-5ddbd226\",\"74\":\"v-5ddbd226@0\",\"75\":\"v-5ddbd226@1\",\"76\":\"v-03c9219a\",\"77\":\"v-03c9219a#基本原理\",\"78\":\"v-03c9219a#实现步骤\",\"79\":\"v-03c9219a@0\",\"80\":\"v-03c9219a@1\",\"81\":\"v-7880f48f\",\"82\":\"v-7880f48f#java实现\",\"83\":\"v-7880f48f@0\",\"84\":\"v-7880f48f@1\",\"85\":\"v-d7d1d7ba\",\"86\":\"v-d7d1d7ba@0\",\"87\":\"v-d7d1d7ba@1\",\"88\":\"v-eb2d2b96\",\"89\":\"v-eb2d2b96@0\",\"90\":\"v-eb2d2b96@1\",\"91\":\"v-2b127a42\",\"92\":\"v-2b127a42@0\",\"93\":\"v-2b127a42@1\",\"94\":\"v-ac8bb2e0\",\"95\":\"v-ac8bb2e0#时间复杂度\",\"96\":\"v-ac8bb2e0#空间复杂度\",\"97\":\"v-ac8bb2e0#java代码实现\",\"98\":\"v-ac8bb2e0@0\",\"99\":\"v-ac8bb2e0@1\",\"100\":\"v-282d451c\",\"101\":\"v-282d451c@0\",\"102\":\"v-282d451c@1\",\"103\":\"v-473c9a0e\",\"104\":\"v-473c9a0e@0\",\"105\":\"v-473c9a0e@1\",\"106\":\"v-6d2fe6d7\",\"107\":\"v-6d2fe6d7@0\",\"108\":\"v-6d2fe6d7@1\",\"109\":\"v-14e554f9\",\"110\":\"v-14e554f9#步骤\",\"111\":\"v-14e554f9#示例\",\"112\":\"v-14e554f9#时间复杂度\",\"113\":\"v-14e554f9#代码实现\",\"114\":\"v-14e554f9@0\",\"115\":\"v-14e554f9@1\",\"116\":\"v-6d027e4e\",\"117\":\"v-6d027e4e@0\",\"118\":\"v-6d027e4e@1\",\"119\":\"v-c5a98646\",\"120\":\"v-564155e4\",\"121\":\"v-00c53a6e\",\"122\":\"v-2d9b4560\",\"123\":\"v-01b1397a\",\"124\":\"v-d0fc7660\",\"125\":\"v-6a17959c\",\"126\":\"v-461e7ade\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[1,20],\"2\":[1,84],\"3\":[null,null,1],\"4\":[null,null,1],\"5\":[1,4],\"6\":[1,11],\"7\":[1],\"8\":[1],\"9\":[1],\"10\":[null,null,1],\"11\":[null,null,2],\"12\":[1,44],\"13\":[null,null,1],\"14\":[null,null,2],\"15\":[1],\"16\":[1,37],\"17\":[1,70],\"18\":[1,25],\"19\":[null,null,1],\"20\":[null,null,2],\"21\":[1,4],\"22\":[2],\"23\":[2,4],\"24\":[2,4],\"25\":[2,4],\"26\":[2],\"27\":[2,5],\"28\":[2,5],\"29\":[2,5],\"30\":[1,4],\"31\":[null,null,1],\"32\":[null,null,2],\"33\":[1],\"34\":[null,null,1],\"35\":[null,null,1],\"36\":[1,2],\"37\":[null,null,1],\"38\":[null,null,2],\"39\":[1,2],\"40\":[2,16],\"41\":[1,7],\"42\":[1,4],\"43\":[1],\"44\":[1,9],\"45\":[1,6],\"46\":[1,5],\"47\":[null,null,1],\"48\":[null,null,2],\"49\":[1,12],\"50\":[null,null,1],\"51\":[null,null,2],\"52\":[1,2],\"53\":[null,null,1],\"54\":[null,null,2],\"55\":[1,2],\"56\":[1,31],\"57\":[1,9],\"58\":[1],\"59\":[1],\"60\":[2,5],\"61\":[4,6],\"62\":[null,null,1],\"63\":[null,null,2],\"64\":[1,2],\"65\":[null,null,1],\"66\":[null,null,2],\"67\":[1,10],\"68\":[1,9],\"69\":[1,46],\"70\":[1,36],\"71\":[null,null,1],\"72\":[null,null,2],\"73\":[1,31],\"74\":[null,null,1],\"75\":[null,null,4],\"76\":[1],\"77\":[1,11],\"78\":[1,52],\"79\":[null,null,1],\"80\":[null,null,2],\"81\":[1,36],\"82\":[1,63],\"83\":[null,null,1],\"84\":[null,null,2],\"85\":[1],\"86\":[null,null,1],\"87\":[null,null,2],\"88\":[1],\"89\":[null,null,1],\"90\":[null,null,2],\"91\":[1,88],\"92\":[null,null,1],\"93\":[null,null,2],\"94\":[1,6],\"95\":[1,7],\"96\":[1,7],\"97\":[1,58],\"98\":[null,null,1],\"99\":[null,null,2],\"100\":[1,8],\"101\":[null,null,1],\"102\":[null,null,2],\"103\":[1],\"104\":[null,null,1],\"105\":[null,null,2],\"106\":[1],\"107\":[null,null,1],\"108\":[null,null,2],\"109\":[1,8],\"110\":[1,11],\"111\":[1,28],\"112\":[1,7],\"113\":[1,44],\"114\":[null,null,1],\"115\":[null,null,2],\"116\":[1,1],\"117\":[null,null,1],\"118\":[null,null,2],\"119\":[2],\"120\":[1],\"121\":[1],\"122\":[1],\"123\":[1],\"124\":[1],\"125\":[1],\"126\":[1]},\"averageFieldLength\":[1.1835346399688382,21.012396151495082,1.123071893199004],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"这是我的个人简历\"]},\"1\":{\"h\":\"个人信息\",\"t\":[\"姓名: 苏文广 性别: 男 出生年月: 1996-12 大学: 韩山师范学院-软件工程专业(2015.9~2019.6/全日制统招本科) 手机号: 18320664028 邮箱: suveng@163.com\"]},\"2\":{\"h\":\"开发技能\",\"t\":[\"4年工作经验\",\"熟悉 Java 语言, IO,反射,SPI,jvm, java agent\",\"精通业务关系建模;能够独立设计大型复杂系统, 绘制系统架构图, UML 设计图, 精通 OKR 工作法\",\"精通 MySQL,掌握复杂 SQL 查询, 熟悉读写分离策略,主从复制策略, 熟悉常见 MySQL HA 代理方案, 熟练使用 sharding-sphere 对 MySQL 分库分表, 了解 ACID 实现原理,了解 MVCC 实现原理, 了解索引实现机制, 了解 XA 分布式事务管理\",\"熟悉 Linux 系统, 熟悉线上运维命令, 熟练 shell 脚本\",\"熟悉 Spring 全家桶, 熟悉 SpringCloud 微服务分布式架构实现,SpringBlade 脚手架\",\"掌握分布式存储设计; 熟悉 Hadoop 存储系统, 熟悉 HBase 数仓\",\"掌握分布式缓存设计; 掌握基于 Redis 的分布式缓存策略;\",\"掌握分布式调度设计; 熟练使用常见的分布式调度平台, xxl-job, schedulex\",\"掌握常见分布式事务设计, TCC 策略, Seata 架构\",\"掌握数据仓库设计, 熟练编写 Clickhouse sql 离线计算任务, Flink sql 实时计算任务\",\"掌握常见监控告警设计,熟练使用 Prometheus 系统生态\",\"了解 Vue,React 框架, 编写过数据大屏以及后台管理界面\"]},\"3\":{\"c\":[\"博主\"]},\"4\":{\"c\":[\"博主\"]},\"5\":{\"h\":\"MySQL同步数据ES\",\"t\":[\"同步双写\",\"异步双写\",\"定时任务\",\"数据订阅\"]},\"6\":{\"h\":\"同步双写\",\"t\":[\"优点:\",\"简单\",\"缺点:\",\"商品业务和搜索业务强耦合\",\"扩展性差, 需要定制搜索需求需求时, 还需要改动商品代码\",\"ES 和 MySQL 存在分布式事务问题\"]},\"7\":{\"h\":\"异步双写\"},\"8\":{\"h\":\"定时任务\"},\"9\":{\"h\":\"数据订阅\"},\"10\":{\"c\":[\"ES\"]},\"11\":{\"c\":[\"ES\",\"Java\"]},\"12\":{\"h\":\"线程\",\"t\":[\"Java的线程是程序执行的最小单位，是操作系统进行调度的基本单元。Java中的线程由Thread类和Runnable接口实现。Thread类是一个实现了Runnable接口的类，它包含线程的控制方法和线程的生命周期方法。Runnable接口定义了一个run()方法，该方法包含线程要执行的代码。\",\"Java中的线程有以下几种状态：\",\"初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。\",\"运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。\",\"阻塞(BLOCKED)：表示线程阻塞于锁。\",\"等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。\",\"超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。\",\"终止(TERMINATED)：表示该线程已经执行完毕。\"]},\"13\":{\"c\":[\"Java\"]},\"14\":{\"c\":[\"Java\",\"并发\"]},\"15\":{\"h\":\"线程池\"},\"16\":{\"h\":\"线程池设计思想\",\"t\":[\"Java线程池的设计思想是为了提高线程的使用效率和响应能力，以及降低资源消耗和线程管理的复杂度。 Java线程池主要具有以下设计思想：\",\"重复使用线程：Java线程池中的线程可以被重复使用，而不是为每个任务创建一个新的线程。这样可以避免线程的创建和销毁带来的开销，提高程序的性能。\",\"控制资源消耗：Java线程池可以控制线程的数量，从而控制程序对系统资源的消耗。当线程数量过多时，可以避免过多的线程同时占用资源，导致资源浪费和系统负载过高。\",\"提高响应能力：Java线程池可以快速响应任务的提交和执行，从而提高程序的响应能力。当有新的任务提交时，线程池可以立即分配线程执行任务，而不用等待新的线程创建和就绪。\",\"任务执行管理：Java线程池可以对任务的执行进行管理，例如控制任务的执行顺序、限制任务的执行时间、处理任务的异常等。这样可以保证任务的执行质量，并提高程序的可靠性。\",\"Java线程池通过ThreadPoolExecutor类来实现，该类提供了可重用的线程池，并提供了丰富的配置选项，可以根据实际需要来配置线程池的参数，以达到最佳的性能和效果。 Java线程池的设计思想是基于生产者-消费者模式，通过工作线程来执行任务，从而实现高效的并发处理。\"]},\"17\":{\"h\":\"如何停止线程池中的线程\",\"t\":[\"在Java中，线程池中的线程是并发执行的，不支持直接停止某一个线程。但是可以通过以下几种方式中断线程的执行：\",\"使用线程的interrupt方法中断线程\",\"ExecutorService executor = Executors.newFixedThreadPool(5); Future future = executor.submit(() -> { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } }); // 停止某个线程 executor.shutdownNow(); future.cancel(true); \",\"使用线程的interrupted方法检查中断标志位\",\"ExecutorService executor = Executors.newFixedThreadPool(5); Future future = executor.submit(() -> { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } }); // 停止某个线程 executor.shutdownNow(); if (Thread.interrupted()) { // 中断标志位为true表示被中断 // 处理中断逻辑 } \",\"使用线程的isInterrupted方法检查中断状态\",\"ExecutorService executor = Executors.newFixedThreadPool(5); Future future = executor.submit(() -> { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } }); // 停止某个线程 executor.shutdownNow(); if (Thread.interrupted()) { // 中断标志位为true表示被中断 // 处理中断逻辑 Thread.currentThread().interrupt(); } \",\"import java.util.concurrent.*; public class Main { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future<String> future = executor.submit(() -> { try { while (!Thread.currentThread().isInterrupted()) { System.out.println(\\\"Working...\\\"); Thread.sleep(5000); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } return \\\"Done\\\"; }); System.out.println(\\\"Future status: \\\" + future.isDone()); Thread.sleep(3000); System.out.println(\\\"Try to cancel future...\\\"); future.cancel(true); System.out.println(\\\"Future status: \\\" + future.isCancelled()); System.out.println(\\\"Future result: \\\" + future.get()); executor.shutdown(); } } \"]},\"18\":{\"h\":\"线程池的核心参数\",\"t\":[\"线程池的核心参数如下：\",\"corePoolSize：核心线程数，即线程池维护的最低线程数。\",\"maximumPoolSize：最大线程数，即线程池维护的最大线程数。\",\"keepAliveTime：线程空闲 timeout，即线程空闲 timeout 时间。\",\"unit：时间单位。\",\"workQueue：任务队列，用于保存等待线程执行的任务。\",\"threadFactory：线程工厂，用于创建新线程。\",\"handler：拒绝执行策略，当任务队列和线程池都达到最大容量时，将执行任务的续行策略。\"]},\"19\":{\"c\":[\"Java\"]},\"20\":{\"c\":[\"Java\",\"并发\"]},\"21\":{\"h\":\"数组\",\"t\":[\"数组是一种线性数据结构，它由一组连续的内存空间组成，用于存储同一类型的数据元素。\"]},\"22\":{\"h\":\"数组的主要优点包括：\"},\"23\":{\"h\":\"1. 直接访问\",\"t\":[\"可以通过索引直接访问数组中的元素，时间复杂度为O(1)。\"]},\"24\":{\"h\":\"2. 灵活操作\",\"t\":[\"可以通过索引对数组中的元素进行增加、删除、修改等操作。\"]},\"25\":{\"h\":\"3. 空间有效利用\",\"t\":[\"在创建数组时，会预分配足够的内存空间用于存储元素，可以有效利用内存空间。\"]},\"26\":{\"h\":\"数组的主要缺点包括：\"},\"27\":{\"h\":\"1. 大小固定\",\"t\":[\"数组的大小在创建时就需要确定，并且不能动态改变，如果需要存储更多的元素，需要重新创建一个更大的数组。\"]},\"28\":{\"h\":\"2. 无法插入中间元素\",\"t\":[\"如果需要在数组的中间插入元素，需要将后面的元素都向后移动一位，时间复杂度为O(n)。\"]},\"29\":{\"h\":\"3. 无法删除中间元素\",\"t\":[\"如果需要删除数组中的中间元素，需要将后面的元素都向前移动一位，时间复杂度为O(n)。\"]},\"30\":{\"h\":\"总结\",\"t\":[\"综上所述，数组适用于元素数量固定且需要直接访问的场景，但是不适用于需要动态增加或删除元素的场景。\"]},\"31\":{\"c\":[\"数据结构\"]},\"32\":{\"c\":[\"数据结构\",\"数组\"]},\"33\":{\"h\":\"电商业务流程时序\"},\"34\":{\"c\":[\"电商\"]},\"35\":{\"c\":[\"电商\"]},\"36\":{\"h\":\"电商售后设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"37\":{\"c\":[\"电商\"]},\"38\":{\"c\":[\"电商\",\"方案\"]},\"39\":{\"h\":\"电商商品设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"40\":{\"h\":\"商品的职责有哪些?\",\"t\":[\"商品来源 \",\"企业生产(自产自销) : 一般是有自己的供应链,公司内部记录和管理\",\"企业采购(B2B) : 从外部企业渠道采购到公司内部, 并由公司内部记录和管理\",\"企业回收(C2B) : 从个人手中回收商品, 并有公司内部记录和管理\",\"商品规格\",\"商品描述\",\"商品定价\"]},\"41\":{\"h\":\"商品上下游模块依赖\",\"t\":[\"供应链模块(商品来源)\",\"订单模块(商品售卖)\",\"物流模块(商品物流)\"]},\"42\":{\"h\":\"商品核心功能\",\"t\":[\"录入商品\",\"搜索商品列表\",\"查询商品详情\",\"更新库存\"]},\"43\":{\"h\":\"商品模型\"},\"44\":{\"h\":\"搜索商品列表高性能低延时方案\",\"t\":[\"使用ElasticSearch作为搜索引擎\",\"搜索相关度排序\",\"商品类目\",\"商品标签\",\"商品标题\",\"商品副标题\",\"商品描述\",\"规格描述\",\"热卖商品\"]},\"45\":{\"h\":\"ES数据映射\",\"t\":[\"ES需要对以下数据做映射\",\"商品 \",\"商品类目\",\"商品标签\",\"商品规格\",\"订单\"]},\"46\":{\"h\":\"ES数据同步方案\",\"t\":[\"MySQL同步数据ES.md\",\"通过上面文章的方案比较, 最终选用数据订阅方式,进行ES数据同步\"]},\"47\":{\"c\":[\"电商\"]},\"48\":{\"c\":[\"电商\",\"方案\"]},\"49\":{\"h\":\"电商搜索设计方案\",\"t\":[\"电商业务流程时序.md\",\"https://zq99299.github.io/note-book/back-end-storage/\"]},\"50\":{\"c\":[\"电商\"]},\"51\":{\"c\":[\"电商\",\"方案\"]},\"52\":{\"h\":\"电商支付设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"53\":{\"c\":[\"电商\"]},\"54\":{\"c\":[\"电商\",\"方案\"]},\"55\":{\"h\":\"电商订单设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"56\":{\"h\":\"电商订单的职责\",\"t\":[\"电商订单是记录电商平台上的交易信息的重要数据实体，包括订单号、商品信息、收货地址、支付信息等。\",\"电商订单具有以下职责： \",\"记录并管理交易信息：电商订单负责记录和管理商品信息、支付信息、物流信息等交易相关数据。\",\"控制交易流程：电商订单可以根据订单状态控制交易流程，如待支付、已支付、待发货、已发货、已完成等。\",\"支持订单查询和统计：电商订单可以提供订单查询和统计功能，以便用户和商家进行订单管理、交易分析等操作。\",\"支持订单修改和取消：电商订单可以支持用户和商家对订单进行修改和取消操作，以满足不同业务场景的需求。\",\"保证订单安全和隐私：电商订单需要采取相应的安全措施，确保订单信息的安全性和隐私性。\",\"电商订单的实现可以采用数据库存储、API接口调用等方式，具体的实现方式根据业务需求和系统架构进行选择。\"]},\"57\":{\"h\":\"核心API\",\"t\":[\"生成订单id();\",\"创建订单();\",\"取消订单();\",\"支付订单();\",\"发货();\",\"签收();\",\"评价();\",\"完成();\"]},\"58\":{\"h\":\"订单状态机设计\"},\"59\":{\"h\":\"注意的场景\"},\"60\":{\"h\":\"如何避免重复下单?\",\"t\":[\"首先,生成订单ID; 然后,使用订单ID作为幂等标识下单;\"]},\"61\":{\"h\":\"如何解决ABA问题? (网络异常情况下, 请求顺序不一致导致数据错乱)\",\"t\":[\"版本号的乐观锁机制\",\"查询接口将版本返回给调用方\",\"调用方将版本号作为参数给接口, 当版本一致的时候更新数据, 不一致不更新, 提示用户刷新页面\"]},\"62\":{\"c\":[\"电商\"]},\"63\":{\"c\":[\"电商\",\"方案\"]},\"64\":{\"h\":\"电商购物车方案\",\"t\":[\"电商业务流程时序.md\"]},\"65\":{\"c\":[\"电商\"]},\"66\":{\"c\":[\"电商\",\"方案\"]},\"67\":{\"h\":\"冒泡排序\",\"t\":[\"冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\"]},\"68\":{\"h\":\"算法描述\",\"t\":[\"从数列中挑出最小（大）元素，依次放到数列的起始位置；\",\"再从剩下的元素中挑出最小（大）元素，放到已排序序列的末尾；\",\"重复步骤2，直到所有元素排序完成。\"]},\"69\":{\"h\":\"示例\",\"t\":[\"对数列 {5, 3, 8, 6, 4} 进行冒泡排序：\",\"第一轮：\",\"比较5和3，发现5>3，交换位置，数列变成 {3, 5, 8, 6, 4}；\",\"比较5和8，发现5<8，位置不变，数列还是 {3, 5, 8, 6, 4}；\",\"比较8和6，发现8>6，交换位置，数列变成 {3, 5, 6, 8, 4}；\",\"比较8和4，发现8>4，交换位置，数列变成 {3, 5, 6, 4, 8}； 第一轮结束，此时最大元素8已经排好序，接下来对剩下的数列 {3, 5, 6, 4} 进行冒泡排序。\",\"第二轮：\",\"比较3和5，发现3<5，位置不变，数列还是 {3, 5, 6, 4}；\",\"比较5和6，发现5<6，位置不变，数列还是 {3, 5, 6, 4}；\",\"比较6和4，发现6>4，交换位置，数列变成 {3, 5, 4, 6}； 第二轮结束，此时次大元素6已经排好序，剩下的数列 {3, 5, 4} 继续冒泡排序。\",\"第三轮：\",\"比较3和5，发现3<5，位置不变，数列还是 {3, 5, 4}；\",\"比较5和4，发现5>4，交换位置，数列变成 {3, 4, 5}； 第三轮结束，此时第三大元素5已经排好序，剩下的数列 {3, 4} 继续冒泡排序。\",\"第四轮：\",\"比较3和4，发现3<4，位置不变，数列还是 {3, 4}； 第四轮结束，此时最小元素3已经排好序，整个数列排序完成。\"]},\"70\":{\"h\":\"复杂度分析\",\"t\":[\"最好情况：当数组已经按照排序需求排好时，只需进行一次遍历，时间复杂度为O(n)；\",\"最坏情况：当数组是逆序排列时，需要进行n-1次遍历，时间复杂度为O(n^2)；\",\"平均情况：需要进行n-1次遍历，时间复杂度为O(n^2)。\",\"冒泡排序是一种稳定的排序算法。\",\"public class bubbleSort { public static void bubbleSort(int[] arr) { int n = arr.length; for (int i = 0; i < n-1; i++) { for (int j = 0; j < n-i-1; j++) { if (arr[j] > arr[j+1]) { // 交换arr[j]和arr[j+1] int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } } } \"]},\"71\":{\"c\":[\"算法\"]},\"72\":{\"c\":[\"算法\",\"排序\"]},\"73\":{\"h\":\"双指针\",\"t\":[\"双指针算法（Two-Pointers Algorithm）是一种常见的算法思想，通常用于解决数组或链表相关的问题。该算法通过使用两个指针，分别从数组或链表的两端向中间移动，从而解决问题。 双指针算法通常可以分为两种情况：\",\"从数组的两端向中间移动的双指针算法： 这种情况下，我们通常使用两个指针从数组的两端同时开始遍历，然后根据具体的问题来决定两个指针的移动方式。这种算法通常用于解决一些查找或筛选的问题，例如查找两个数的和等于目标值、查找数组中的环形子数组等。\",\"从数组的一端向另一端移动的双指针算法： 这种情况下，我们通常使用两个指针，一个指向数组的起始位置，另一个从起始位置开始向后遍历。这种算法通常用于解决一些排序或统计的问题，例如验证只包含相同字符的最长子串、统计数组中元素出现次数等。\",\"使用双指针算法可以有效地提高解决数组或链表相关问题的效率，因为双指针同时进行遍历，可以将时间复杂度从O(n^2)降低到O(n)。\"]},\"74\":{\"c\":[\"算法\"]},\"75\":{\"c\":[\"算法\",\"双指针\",\"数组\",\"链表\"]},\"76\":{\"h\":\"基数排序\"},\"77\":{\"h\":\"基本原理\",\"t\":[\"基数排序是一种非比较性的排序算法。基数排序的基本思想是：将整数按位数划分为不同的桶，然后按每个位数分别对桶中的元素进行排序，最终将所有位数上的排序结果合并在一起，得到最终的排序结果。\",\"基数排序的时间复杂度为O(dn)，其中d是数字的最大位数，n是待排序元素个数。\"]},\"78\":{\"h\":\"实现步骤\",\"t\":[\"基数排序的实现步骤如下：\",\"获取待排序数组中的最大值，确定最大位数d。\",\"对最末位进行排序，使用计数排序算法对每个数字出现的次数进行统计。\",\"基于计数排序的结果，依次确定每个数字在有序数组中的位置。\",\"将有序数组重新赋值给原数组。\",\"依次对每一位进行排序，直到最高位。\",\"public class radixSort { public static void radixSort(int[] arr) { if (arr == null || arr.length <= 1) { return; } // 获取最大值的位数 int maxNum = arr[0]; for (int i = 1; i < arr.length; i++) { if (arr[i] > maxNum) { maxNum = arr[i]; } } int placeValue = 1; // 当前位的权值 while (maxNum / placeValue > 0) { countingSort(arr, placeValue); placeValue *= 10; } } private static void countingSort(int[] arr, int placeValue) { int[] count = new int[10]; int radix = 10; for (int i = 0; i < arr.length; i++) { int digit = (arr[i] / radix) % 10; count[digit]++; } for (int i = 1; i < count.length; i++) { count[i] += count[i - 1]; } int[] output = new int[arr.length]; for (int i = arr.length - 1; i >= 0; i--) { int digit = (arr[i] / radix) % 10; int index = count[digit] - 1; output[index] = arr[i]; count[digit]--; } System.arraycopy(output, 0, arr, 0, arr.length); } } \"]},\"79\":{\"c\":[\"算法\"]},\"80\":{\"c\":[\"算法\",\"排序\"]},\"81\":{\"h\":\"堆排序\",\"t\":[\"堆排序（Heap Sort）是利用堆（Heap）这种数据结构进行选择排序的一种算法。堆是一个可以推导具有最大或最小值的树形结构，堆排序利用堆的特性进行排序。\",\"堆排序分为两个步骤：\",\"建堆（Build Heap）：将一个无序的数组构建成一个大顶堆（Max Heap）。大顶堆的特点是父节点的值大于或等于其子节点的值。建堆的过程从数组的最后一个非叶子节点开始，依次向上调整每个节点，使其满足大顶堆的特性。\",\"排序（Sort）：重复执行以下步骤，直到堆的大小为1：\",\"将堆中的最大元素（根节点）与堆的最后一个元素交换。\",\"将堆的大小减1。\",\"对堆进行调整，使其重新成为一个大顶堆。\",\"重复上述步骤，每次取出的都是当前堆中的最大元素，最终得到的数组就是一个有序的数组。\",\"堆排序的时间复杂度为O(nlogn)，空间复杂度为O(1)。由于堆排序是一种不稳定的排序算法，因此在需要保持相同元素的原始顺序时应谨慎使用。\",\"以下是堆排序的示例代码：\"]},\"82\":{\"h\":\"Java实现\",\"t\":[\"public class HeapSort { public static void sort(int[] arr) { int n = arr.length; // 构建大顶堆 for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i); // 排序 for (int i = n - 1; i >= 0; i--) { // 将当前堆中的最大元素与堆的最后一个元素交换 swap(arr, 0, i); // 对交换后的元素进行调整，重新成为一个大顶堆 heapify(arr, i, 0); } } // 调整堆，使其重新成为一个大顶堆 static void heapify(int[] arr, int n, int i) { int largest = i; // 初始化largest为当前节点 int left = 2 * i + 1; // 左子节点 int right = 2 * i + 2; // 右子节点 // 如果左子节点比当前节点大，则更新largest为左子节点 if (left < n && arr[left] > arr[largest]) largest = left; // 如果右子节点比当前节点大，则更新largest为右子节点 if (right < n && arr[right] > arr[largest]) largest = right; // 如果largest不是当前节点，则将largest与当前节点交换，并递归调整堆 if (largest != i) { swap(arr, i, largest); heapify(arr, n, largest); } } // 交换数组中的两个元素 static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } // 测试 public static void main(String[] args) { int[] arr = { 12, 11, 13, 5, 6, 7 }; sort(arr); System.out.println(\\\"排序后的数组：\\\"); for (int num : arr) System.out.print(num + \\\" \\\"); } } \"]},\"83\":{\"c\":[\"算法\"]},\"84\":{\"c\":[\"算法\",\"排序\"]},\"85\":{\"h\":\"希尔排序\"},\"86\":{\"c\":[\"算法\"]},\"87\":{\"c\":[\"算法\",\"排序\"]},\"88\":{\"h\":\"归并排序\"},\"89\":{\"c\":[\"算法\"]},\"90\":{\"c\":[\"算法\",\"排序\"]},\"91\":{\"h\":\"快速排序\",\"t\":[\"快速排序是一种常用的排序算法，采用分治法（Divide and Conquer）的思想。它的基本步骤如下：\",\"从数列中挑出一个元素，称为“基准”（pivot）。\",\"将所有比基准值小的元素都放在基准前面，比基准值大的元素都放在基准的后面（相同的数可以放在任一边）。在这个分区退出之后，该基准就处于数列的中间位置。\",\"对基准的左右两个分区重复步骤1和步骤2。 快速排序的关键步骤是基准的选取，不同的选取方法会影响排序的效率。通常有以下几种选取方法： \",\"选取第一个元素作为基准\",\"选取最后一个元素作为基准\",\"选取中间元素作为基准\",\"从数列中随机选取一个元素作为基准\",\"快速排序的时间复杂度为O(nlogn)，但在最坏情况下时间复杂度为O(n^2)。为了避免最坏情况的发生，可以采用随机选取基准、三数中值法选取基准等优化方法。\",\"public class QuickSort { /* * 快速排序 * * 参数说明： * a -- 待排序的数组 * l -- 数组的左边界(例如，从起始位置开始排序，则l=0) * r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1) */ public static void quickSort(int[] a, int l, int r) { if (l < r) { int i,j,x; i = l; j = r; x = a[i]; while (i < j) { while(i < j && a[j] > x) j--; // 从右向左找第一个小于x的数 if(i < j) a[i++] = a[j]; while(i < j && a[i] < x) i++; // 从左向右找第一个大于x的数 if(i < j) a[j--] = a[i]; } a[i] = x; quickSort(a, l, i-1); /* 递归调用 */ quickSort(a, i+1, r); /* 递归调用 */ } } public static void main(String[] args) { int i; int a[] = {30,40,60,10,20,50}; System.out.printf(\\\"before sort:\\\"); for (i=0; i<a.length; i++) System.out.printf(\\\"%d \\\", a[i]); System.out.printf(\\\"\\\\n\\\"); quickSort(a, 0, a.length-1); System.out.printf(\\\"after sort:\\\"); for (i=0; i<a.length; i++) System.out.printf(\\\"%d \\\", a[i]); System.out.printf(\\\"\\\\n\\\"); } } \"]},\"92\":{\"c\":[\"算法\"]},\"93\":{\"c\":[\"算法\",\"排序\"]},\"94\":{\"h\":\"插入排序\",\"t\":[\"插入排序是一种简单直观的排序算法。它的基本思想是通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\"]},\"95\":{\"h\":\"时间复杂度\",\"t\":[\"在最坏的情况下，插入排序需要O(n^2)的时间复杂度和O(1)的空间复杂度。\"]},\"96\":{\"h\":\"空间复杂度\",\"t\":[\"在最好情况下，插入排序需要O(n)的时间复杂度和O(1)的空间复杂度。\"]},\"97\":{\"h\":\"Java代码实现\",\"t\":[\"/** * 插入排序(Insertion Sort)是一种简单直观的排序算法。 * 插入排序的工作原理是：通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 * * 在最好情况下，插入排序的效率为O(n)，对应的序列是已排序的； * 在最坏情况下，插入排序的时间复杂度为O(n^2)，对应的序列是逆序的。 * * 代码的执行步骤： * 1. 从第一个元素开始，该元素可以认为已经被排序； * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描； * 3. 如果该元素（已排序）大于新元素，将该元素移动到下一位置； * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； * 5. 将新元素插入到该位置后； * 6. 重复步骤2~5。 */ public class InsertionSort { public static void sort(int[] array) { int n = array.length; for (int i = 1; i < n; i++) { int key = array[i]; int j = i - 1; while (j >= 0 && array[j] > key) { array[j + 1] = array[j]; j--; } array[j + 1] = key; } } } \"]},\"98\":{\"c\":[\"算法\"]},\"99\":{\"c\":[\"算法\",\"排序\"]},\"100\":{\"h\":\"斐波那契数列问题\",\"t\":[\"数学公式如下:\",\"f(n)=⎩⎨⎧​01f(n−1)+f(n−2)​n=0n=1n>=1​​​\"]},\"101\":{\"c\":[\"算法\"]},\"102\":{\"c\":[\"算法\",\"斐波那契数列\"]},\"103\":{\"h\":\"桶排序\"},\"104\":{\"c\":[\"算法\"]},\"105\":{\"c\":[\"算法\",\"排序\"]},\"106\":{\"h\":\"计数排序\"},\"107\":{\"c\":[\"算法\"]},\"108\":{\"c\":[\"算法\",\"排序\"]},\"109\":{\"h\":\"选择排序\",\"t\":[\"选择排序是一种简单直观的排序算法。它的基本思想是：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\"]},\"110\":{\"h\":\"步骤\",\"t\":[\"选择排序的算法步骤如下：\",\"在待排序的元素中，找到最小（大）的元素，将其与第一个元素交换位置。\",\"在剩下的元素中，找到最小（大）的元素，将其与第二个元素交换位置。\",\"重复上述步骤，直到所有元素均排序完毕。\"]},\"111\":{\"h\":\"示例\",\"t\":[\"给定数组 [3, 4, 2, 1, 5]，按升序排序。\",\"第一次遍历，找到最小元素 1，与第一个元素 3 交换位置，数组变为 [1, 4, 2, 3, 5]。\",\"第二次遍历，忽略第一个元素，找到最小元素 2，与第二个元素 4 交换位置，数组变为 [1, 2, 4, 3, 5]。\",\"第三次遍历，忽略前两个元素，找到最小元素 3，与第三个元素 4 交换位置，数组变为 [1, 2, 3, 4, 5]。\",\"第四次遍历，忽略前三个元素，找到最小元素 4，与第四个元素 4 交换位置，数组保持不变 [1, 2, 3, 4, 5]。\",\"第五次遍历，忽略前四个元素，找到最小元素 5，与第五个元素 5 交换位置，数组保持不变 [1, 2, 3, 4, 5]。\",\"最终得到的数组为 [1, 2, 3, 4, 5]，即为按升序排序后的结果。\"]},\"112\":{\"h\":\"时间复杂度\",\"t\":[\"选择排序的时间复杂度为 O(n^2)，其中 n 是待排序数组的长度。\"]},\"113\":{\"h\":\"代码实现\",\"t\":[\"下面是使用 Java 实现选择排序的示例代码：\",\"public class SelectionSort { public static void main(String[] args) { int[] arr = {3, 4, 2, 1, 5}; selectionSort(arr); System.out.println(Arrays.toString(arr)); // 输出：[1, 2, 3, 4, 5] } public static void selectionSort(int[] arr) { int n = arr.length; // 遍历数组 for (int i = 0; i < n-1; i++) { int minIndex = i; // 寻找最小元素的索引 for (int j = i+1; j < n; j++) { if (arr[j] < arr[minIndex]) { minIndex = j; } } // 交换最小元素与当前元素的位置 int temp = arr[minIndex]; arr[minIndex] = arr[i]; arr[i] = temp; } } } \",\"以上代码实现了选择排序的排序算法和排序结果的输出。\"]},\"114\":{\"c\":[\"算法\"]},\"115\":{\"c\":[\"算法\",\"排序\"]},\"116\":{\"h\":\"记录搭建VuePress博客\",\"t\":[\"VuePress\"]},\"117\":{\"c\":[\"博客\"]},\"118\":{\"c\":[\"VuePress\",\"博客\"]},\"119\":{\"h\":\"E S\"},\"120\":{\"h\":\"Posts\"},\"121\":{\"h\":\"Java\"},\"122\":{\"h\":\"数据结构\"},\"123\":{\"h\":\"电商\"},\"124\":{\"h\":\"简历\"},\"125\":{\"h\":\"算法题\"},\"126\":{\"h\":\"记录\"}},\"dirtCount\":0,\"index\":[[\"简历\",{\"0\":{\"124\":1}}],[\"简单\",{\"1\":{\"6\":1}}],[\"博客\",{\"2\":{\"117\":1,\"118\":1}}],[\"博主\",{\"2\":{\"3\":1,\"4\":1}}],[\"记录\",{\"0\":{\"126\":1}}],[\"记录搭建vuepress博客\",{\"0\":{\"116\":1}}],[\"记录并管理交易信息\",{\"1\":{\"56\":1}}],[\"寻找最小元素的索引\",{\"1\":{\"113\":1}}],[\"遍历数组\",{\"1\":{\"113\":1}}],[\"输出\",{\"1\":{\"113\":1}}],[\"下面是使用\",{\"1\":{\"113\":1}}],[\"即为按升序排序后的结果\",{\"1\":{\"111\":1}}],[\"即线程空闲\",{\"1\":{\"18\":1}}],[\"即线程池维护的最大线程数\",{\"1\":{\"18\":1}}],[\"即线程池维护的最低线程数\",{\"1\":{\"18\":1}}],[\"忽略前四个元素\",{\"1\":{\"111\":1}}],[\"忽略前三个元素\",{\"1\":{\"111\":1}}],[\"忽略前两个元素\",{\"1\":{\"111\":1}}],[\"忽略第一个元素\",{\"1\":{\"111\":1}}],[\"与第五个元素\",{\"1\":{\"111\":1}}],[\"与第四个元素\",{\"1\":{\"111\":1}}],[\"与第三个元素\",{\"1\":{\"111\":1}}],[\"与第二个元素\",{\"1\":{\"111\":1}}],[\"与第一个元素\",{\"1\":{\"111\":1}}],[\"与堆的最后一个元素交换\",{\"1\":{\"81\":1}}],[\"按升序排序\",{\"1\":{\"111\":1}}],[\"给定数组\",{\"1\":{\"111\":1}}],[\"找到最小元素\",{\"1\":{\"111\":5}}],[\"找到最小\",{\"1\":{\"110\":2}}],[\"找到相应位置并插入\",{\"1\":{\"94\":1,\"97\":1}}],[\"步骤\",{\"0\":{\"110\":1}}],[\"或最大\",{\"1\":{\"109\":1}}],[\"每次从待排序的数据元素中选出最小\",{\"1\":{\"109\":1}}],[\"每次取出的都是当前堆中的最大元素\",{\"1\":{\"81\":1}}],[\"选择排序的时间复杂度为\",{\"1\":{\"112\":1}}],[\"选择排序的算法步骤如下\",{\"1\":{\"110\":1}}],[\"选择排序是一种简单直观的排序算法\",{\"1\":{\"109\":1}}],[\"选择排序\",{\"0\":{\"109\":1}}],[\"选取中间元素作为基准\",{\"1\":{\"91\":1}}],[\"选取最后一个元素作为基准\",{\"1\":{\"91\":1}}],[\"选取第一个元素作为基准\",{\"1\":{\"91\":1}}],[\"计数排序\",{\"0\":{\"106\":1}}],[\"桶排序\",{\"0\":{\"103\":1}}],[\"斐波那契数列\",{\"2\":{\"102\":1}}],[\"斐波那契数列问题\",{\"0\":{\"100\":1}}],[\"​n=0n=1n>=1​​​\",{\"1\":{\"100\":1}}],[\"key\",{\"1\":{\"97\":3}}],[\"keepalivetime\",{\"1\":{\"18\":1}}],[\"取出下一个元素\",{\"1\":{\"97\":1}}],[\"取消订单\",{\"1\":{\"57\":1}}],[\"代码实现\",{\"0\":{\"113\":1}}],[\"代码的执行步骤\",{\"1\":{\"97\":1}}],[\"代理方案\",{\"1\":{\"2\":1}}],[\"插入排序的时间复杂度为o\",{\"1\":{\"97\":1}}],[\"插入排序的效率为o\",{\"1\":{\"97\":1}}],[\"插入排序的工作原理是\",{\"1\":{\"97\":1}}],[\"插入排序需要o\",{\"1\":{\"95\":1,\"96\":1}}],[\"插入排序是一种简单直观的排序算法\",{\"1\":{\"94\":1}}],[\"插入排序\",{\"0\":{\"94\":1},\"1\":{\"97\":1}}],[\"递归调用\",{\"1\":{\"91\":2}}],[\"待排序的数组\",{\"1\":{\"91\":1}}],[\"待发货\",{\"1\":{\"56\":1}}],[\"参数说明\",{\"1\":{\"91\":1}}],[\"quicksort\",{\"1\":{\"91\":5}}],[\"三数中值法选取基准等优化方法\",{\"1\":{\"91\":1}}],[\"为了避免最坏情况的发生\",{\"1\":{\"91\":1}}],[\"相同的数可以放在任一边\",{\"1\":{\"91\":1}}],[\"称为\",{\"1\":{\"91\":1}}],[\"的元素\",{\"1\":{\"110\":2}}],[\"的一个元素\",{\"1\":{\"109\":1}}],[\"的空间复杂度\",{\"1\":{\"95\":1,\"96\":1}}],[\"的时间复杂度和o\",{\"1\":{\"95\":1,\"96\":1}}],[\"的思想\",{\"1\":{\"91\":1}}],[\"的分布式缓存策略\",{\"1\":{\"2\":1}}],[\"采用分治法\",{\"1\":{\"91\":1}}],[\"快速排序的时间复杂度为o\",{\"1\":{\"91\":1}}],[\"快速排序的关键步骤是基准的选取\",{\"1\":{\"91\":1}}],[\"快速排序是一种常用的排序算法\",{\"1\":{\"91\":1}}],[\"快速排序\",{\"0\":{\"91\":1},\"1\":{\"91\":1}}],[\"归并排序\",{\"0\":{\"88\":1}}],[\"希尔排序\",{\"0\":{\"85\":1}}],[\"7\",{\"1\":{\"82\":1}}],[\"测试\",{\"1\":{\"82\":1}}],[\"则r=a\",{\"1\":{\"91\":1}}],[\"则l=0\",{\"1\":{\"91\":1}}],[\"则将largest与当前节点交换\",{\"1\":{\"82\":1}}],[\"则更新largest为右子节点\",{\"1\":{\"82\":1}}],[\"则更新largest为左子节点\",{\"1\":{\"82\":1}}],[\"右子节点\",{\"1\":{\"82\":1}}],[\"左子节点\",{\"1\":{\"82\":1}}],[\"调整堆\",{\"1\":{\"82\":1}}],[\"调用方将版本号作为参数给接口\",{\"1\":{\"61\":1}}],[\"调用了该对象的start\",{\"1\":{\"12\":1}}],[\"重新成为一个大顶堆\",{\"1\":{\"82\":1}}],[\"重复步骤3\",{\"1\":{\"97\":1}}],[\"重复步骤2~5\",{\"1\":{\"97\":1}}],[\"重复步骤2\",{\"1\":{\"68\":1}}],[\"重复上述步骤\",{\"1\":{\"81\":1,\"110\":1}}],[\"重复执行以下步骤\",{\"1\":{\"81\":1}}],[\"重复使用线程\",{\"1\":{\"16\":1}}],[\"构建大顶堆\",{\"1\":{\"82\":1}}],[\"因此在需要保持相同元素的原始顺序时应谨慎使用\",{\"1\":{\"81\":1}}],[\"因为双指针同时进行遍历\",{\"1\":{\"73\":1}}],[\"由于堆排序是一种不稳定的排序算法\",{\"1\":{\"81\":1}}],[\"空间复杂度\",{\"0\":{\"96\":1}}],[\"空间复杂度为o\",{\"1\":{\"81\":1}}],[\"空间有效利用\",{\"0\":{\"25\":1}}],[\"根节点\",{\"1\":{\"81\":1}}],[\"使其重新成为一个大顶堆\",{\"1\":{\"81\":1,\"82\":1}}],[\"使其满足大顶堆的特性\",{\"1\":{\"81\":1}}],[\"使用计数排序算法对每个数字出现的次数进行统计\",{\"1\":{\"78\":1}}],[\"使用双指针算法可以有效地提高解决数组或链表相关问题的效率\",{\"1\":{\"73\":1}}],[\"使用订单id作为幂等标识下单\",{\"1\":{\"60\":1}}],[\"使用elasticsearch作为搜索引擎\",{\"1\":{\"44\":1}}],[\"使用线程的isinterrupted方法检查中断状态\",{\"1\":{\"17\":1}}],[\"使用线程的interrupted方法检查中断标志位\",{\"1\":{\"17\":1}}],[\"使用线程的interrupt方法中断线程\",{\"1\":{\"17\":1}}],[\"建堆的过程从数组的最后一个非叶子节点开始\",{\"1\":{\"81\":1}}],[\"建堆\",{\"1\":{\"81\":1}}],[\"堆是一个可以推导具有最大或最小值的树形结构\",{\"1\":{\"81\":1}}],[\"堆排序的时间复杂度为o\",{\"1\":{\"81\":1}}],[\"堆排序分为两个步骤\",{\"1\":{\"81\":1}}],[\"堆排序利用堆的特性进行排序\",{\"1\":{\"81\":1}}],[\"堆排序\",{\"0\":{\"81\":1},\"1\":{\"81\":1}}],[\"||\",{\"1\":{\"78\":1}}],[\"依次向上调整每个节点\",{\"1\":{\"81\":1}}],[\"依次对每一位进行排序\",{\"1\":{\"78\":1}}],[\"依次确定每个数字在有序数组中的位置\",{\"1\":{\"78\":1}}],[\"依次放到数列的起始位置\",{\"1\":{\"68\":1}}],[\"确定最大位数d\",{\"1\":{\"78\":1}}],[\"确保订单信息的安全性和隐私性\",{\"1\":{\"56\":1}}],[\"获取最大值的位数\",{\"1\":{\"78\":1}}],[\"获取待排序数组中的最大值\",{\"1\":{\"78\":1}}],[\"获取cpu的使用权\",{\"1\":{\"12\":1}}],[\"其中\",{\"1\":{\"112\":1}}],[\"其中d是数字的最大位数\",{\"1\":{\"77\":1}}],[\"其他线程\",{\"1\":{\"12\":1}}],[\"d\",{\"1\":{\"91\":2}}],[\"divide\",{\"1\":{\"91\":1}}],[\"digit\",{\"1\":{\"78\":5}}],[\"dn\",{\"1\":{\"77\":1}}],[\"done\",{\"1\":{\"17\":1}}],[\"得到最终的排序结果\",{\"1\":{\"77\":1}}],[\"将其与第二个元素交换位置\",{\"1\":{\"110\":1}}],[\"将其与第一个元素交换位置\",{\"1\":{\"110\":1}}],[\"将新元素插入到该位置后\",{\"1\":{\"97\":1}}],[\"将该元素移动到下一位置\",{\"1\":{\"97\":1}}],[\"将所有比基准值小的元素都放在基准前面\",{\"1\":{\"91\":1}}],[\"将当前堆中的最大元素与堆的最后一个元素交换\",{\"1\":{\"82\":1}}],[\"将堆的大小减1\",{\"1\":{\"81\":1}}],[\"将堆中的最大元素\",{\"1\":{\"81\":1}}],[\"将一个无序的数组构建成一个大顶堆\",{\"1\":{\"81\":1}}],[\"将有序数组重新赋值给原数组\",{\"1\":{\"78\":1}}],[\"将整数按位数划分为不同的桶\",{\"1\":{\"77\":1}}],[\"将执行任务的续行策略\",{\"1\":{\"18\":1}}],[\"基准\",{\"1\":{\"91\":1}}],[\"基于计数排序的结果\",{\"1\":{\"78\":1}}],[\"基本原理\",{\"0\":{\"77\":1}}],[\"基数排序的实现步骤如下\",{\"1\":{\"78\":1}}],[\"基数排序的时间复杂度为o\",{\"1\":{\"77\":1}}],[\"基数排序的基本思想是\",{\"1\":{\"77\":1}}],[\"基数排序是一种非比较性的排序算法\",{\"1\":{\"77\":1}}],[\"基数排序\",{\"0\":{\"76\":1}}],[\"链表\",{\"2\":{\"75\":1}}],[\"降低到o\",{\"1\":{\"73\":1}}],[\"统计数组中元素出现次数等\",{\"1\":{\"73\":1}}],[\"另一个从起始位置开始向后遍历\",{\"1\":{\"73\":1}}],[\"我们通常使用两个指针\",{\"1\":{\"73\":1}}],[\"我们通常使用两个指针从数组的两端同时开始遍历\",{\"1\":{\"73\":1}}],[\"查找数组中的环形子数组等\",{\"1\":{\"73\":1}}],[\"查询接口将版本返回给调用方\",{\"1\":{\"61\":1}}],[\"查询商品详情\",{\"1\":{\"42\":1}}],[\"查询\",{\"1\":{\"2\":1}}],[\"例如\",{\"1\":{\"91\":2}}],[\"例如验证只包含相同字符的最长子串\",{\"1\":{\"73\":1}}],[\"例如查找两个数的和等于目标值\",{\"1\":{\"73\":1}}],[\"例如控制任务的执行顺序\",{\"1\":{\"16\":1}}],[\"双指针算法通常可以分为两种情况\",{\"1\":{\"73\":1}}],[\"双指针算法\",{\"1\":{\"73\":1}}],[\"双指针\",{\"0\":{\"73\":1},\"2\":{\"75\":1}}],[\"排序截至到数组末尾\",{\"1\":{\"91\":1}}],[\"排序后的数组\",{\"1\":{\"82\":1}}],[\"排序\",{\"1\":{\"81\":1,\"82\":1},\"2\":{\"72\":1,\"80\":1,\"84\":1,\"87\":1,\"90\":1,\"93\":1,\"99\":1,\"105\":1,\"108\":1,\"115\":1}}],[\"算法题\",{\"0\":{\"125\":1}}],[\"算法\",{\"2\":{\"71\":1,\"72\":1,\"74\":1,\"75\":1,\"79\":1,\"80\":1,\"83\":1,\"84\":1,\"86\":1,\"87\":1,\"89\":1,\"90\":1,\"92\":1,\"93\":1,\"98\":1,\"99\":1,\"101\":1,\"102\":1,\"104\":1,\"105\":1,\"107\":1,\"108\":1,\"114\":1,\"115\":1}}],[\"算法描述\",{\"0\":{\"68\":1}}],[\"<=\",{\"1\":{\"78\":1}}],[\"<\",{\"1\":{\"70\":2,\"78\":3,\"82\":2,\"91\":7,\"97\":1,\"113\":3}}],[\"0\",{\"1\":{\"70\":2,\"78\":6,\"82\":4,\"91\":1,\"97\":1,\"113\":1}}],[\"l\",{\"1\":{\"91\":5}}],[\"left\",{\"1\":{\"82\":4}}],[\"length\",{\"1\":{\"70\":1,\"78\":7,\"82\":1,\"91\":4,\"97\":1,\"113\":1}}],[\"largest\",{\"1\":{\"82\":8}}],[\"linux\",{\"1\":{\"2\":1}}],[\"平均情况\",{\"1\":{\"70\":1}}],[\"只需进行一次遍历\",{\"1\":{\"70\":1}}],[\"复杂度分析\",{\"0\":{\"70\":1}}],[\"整个数列排序完成\",{\"1\":{\"69\":1}}],[\"继续冒泡排序\",{\"1\":{\"69\":2}}],[\"剩下的数列\",{\"1\":{\"69\":2}}],[\"第五次遍历\",{\"1\":{\"111\":1}}],[\"第四次遍历\",{\"1\":{\"111\":1}}],[\"第四轮结束\",{\"1\":{\"69\":1}}],[\"第四轮\",{\"1\":{\"69\":1}}],[\"第三次遍历\",{\"1\":{\"111\":1}}],[\"第三轮结束\",{\"1\":{\"69\":1}}],[\"第三轮\",{\"1\":{\"69\":1}}],[\"第二次遍历\",{\"1\":{\"111\":1}}],[\"第二轮结束\",{\"1\":{\"69\":1}}],[\"第二轮\",{\"1\":{\"69\":1}}],[\"第一次遍历\",{\"1\":{\"111\":1}}],[\"第一轮结束\",{\"1\":{\"69\":1}}],[\"第一轮\",{\"1\":{\"69\":1}}],[\"接下来对剩下的数列\",{\"1\":{\"69\":1}}],[\"此时最小元素3已经排好序\",{\"1\":{\"69\":1}}],[\"此时最大元素8已经排好序\",{\"1\":{\"69\":1}}],[\"此时第三大元素5已经排好序\",{\"1\":{\"69\":1}}],[\"此时次大元素6已经排好序\",{\"1\":{\"69\":1}}],[\"此时处于就绪状态\",{\"1\":{\"12\":1}}],[\"位置不变\",{\"1\":{\"69\":5}}],[\"交换最小元素与当前元素的位置\",{\"1\":{\"113\":1}}],[\"交换数组中的两个元素\",{\"1\":{\"82\":1}}],[\"交换arr\",{\"1\":{\"70\":1}}],[\"交换位置\",{\"1\":{\"69\":5,\"111\":5}}],[\"交易分析等操作\",{\"1\":{\"56\":1}}],[\"发现3<4\",{\"1\":{\"69\":1}}],[\"发现3<5\",{\"1\":{\"69\":2}}],[\"发现6>4\",{\"1\":{\"69\":1}}],[\"发现8>4\",{\"1\":{\"69\":1}}],[\"发现8>6\",{\"1\":{\"69\":1}}],[\"发现5>4\",{\"1\":{\"69\":1}}],[\"发现5>3\",{\"1\":{\"69\":1}}],[\"发现5<6\",{\"1\":{\"69\":1}}],[\"发现5<8\",{\"1\":{\"69\":1}}],[\"发货\",{\"1\":{\"57\":1}}],[\"比基准值大的元素都放在基准的后面\",{\"1\":{\"91\":1}}],[\"比较3和4\",{\"1\":{\"69\":1}}],[\"比较3和5\",{\"1\":{\"69\":2}}],[\"比较6和4\",{\"1\":{\"69\":1}}],[\"比较8和4\",{\"1\":{\"69\":1}}],[\"比较8和6\",{\"1\":{\"69\":1}}],[\"比较5和4\",{\"1\":{\"69\":1}}],[\"比较5和6\",{\"1\":{\"69\":1}}],[\"比较5和8\",{\"1\":{\"69\":1}}],[\"比较5和3\",{\"1\":{\"69\":1}}],[\"比如main线程\",{\"1\":{\"12\":1}}],[\"40\",{\"1\":{\"91\":1}}],[\"4\",{\"1\":{\"69\":14,\"97\":1,\"111\":11,\"113\":2}}],[\"4年工作经验\",{\"1\":{\"2\":1}}],[\"8\",{\"1\":{\"69\":5}}],[\"示例\",{\"0\":{\"69\":1,\"111\":1}}],[\"直到所有元素均排序完毕\",{\"1\":{\"110\":1}}],[\"直到所有元素排序完成\",{\"1\":{\"68\":1}}],[\"直到全部待排序的数据元素排完\",{\"1\":{\"109\":1}}],[\"直到找到已排序的元素小于或者等于新元素的位置\",{\"1\":{\"97\":1}}],[\"直到堆的大小为1\",{\"1\":{\"81\":1}}],[\"直到最高位\",{\"1\":{\"78\":1}}],[\"直接访问\",{\"0\":{\"23\":1}}],[\"放到已排序序列的末尾\",{\"1\":{\"68\":1}}],[\"再从剩下的元素中挑出最小\",{\"1\":{\"68\":1}}],[\"元素\",{\"1\":{\"68\":2}}],[\"也就是说该数列已经排序完成\",{\"1\":{\"67\":1}}],[\"走访数列的工作是重复地进行直到没有再需要交换\",{\"1\":{\"67\":1}}],[\"一个指向数组的起始位置\",{\"1\":{\"73\":1}}],[\"一次比较两个元素\",{\"1\":{\"67\":1}}],[\"一般是有自己的供应链\",{\"1\":{\"40\":1}}],[\"是待排序数组的长度\",{\"1\":{\"112\":1}}],[\"是利用堆\",{\"1\":{\"81\":1}}],[\"是一种简单直观的排序算法\",{\"1\":{\"97\":1}}],[\"是一种简单的排序算法\",{\"1\":{\"67\":1}}],[\"是一种常见的算法思想\",{\"1\":{\"73\":1}}],[\"是操作系统进行调度的基本单元\",{\"1\":{\"12\":1}}],[\"冒泡排序是一种稳定的排序算法\",{\"1\":{\"70\":1}}],[\"冒泡排序\",{\"0\":{\"67\":1},\"1\":{\"67\":1}}],[\"提示用户刷新页面\",{\"1\":{\"61\":1}}],[\"提高响应能力\",{\"1\":{\"16\":1}}],[\"提高程序的性能\",{\"1\":{\"16\":1}}],[\"不同的选取方法会影响排序的效率\",{\"1\":{\"91\":1}}],[\"不一致不更新\",{\"1\":{\"61\":1}}],[\"不支持直接停止某一个线程\",{\"1\":{\"17\":1}}],[\"版本号的乐观锁机制\",{\"1\":{\"61\":1}}],[\"请求顺序不一致导致数据错乱\",{\"0\":{\"61\":1}}],[\"网络异常情况下\",{\"0\":{\"61\":1}}],[\"然后按每个位数分别对桶中的元素进行排序\",{\"1\":{\"77\":1}}],[\"然后根据具体的问题来决定两个指针的移动方式\",{\"1\":{\"73\":1}}],[\"然后\",{\"1\":{\"60\":1}}],[\"首先\",{\"1\":{\"60\":1}}],[\"注意的场景\",{\"0\":{\"59\":1}}],[\"完成\",{\"1\":{\"57\":1}}],[\"评价\",{\"1\":{\"57\":1}}],[\"签收\",{\"1\":{\"57\":1}}],[\"创建订单\",{\"1\":{\"57\":1}}],[\"生成订单id\",{\"1\":{\"57\":1,\"60\":1}}],[\"核心api\",{\"0\":{\"57\":1}}],[\"核心线程数\",{\"1\":{\"18\":1}}],[\"具体的实现方式根据业务需求和系统架构进行选择\",{\"1\":{\"56\":1}}],[\"保证订单安全和隐私\",{\"1\":{\"56\":1}}],[\"支付订单\",{\"1\":{\"57\":1}}],[\"支付信息\",{\"1\":{\"56\":1}}],[\"支付信息等\",{\"1\":{\"56\":1}}],[\"支持订单修改和取消\",{\"1\":{\"56\":1}}],[\"支持订单查询和统计\",{\"1\":{\"56\":1}}],[\"已排序\",{\"1\":{\"97\":1}}],[\"已完成等\",{\"1\":{\"56\":1}}],[\"已发货\",{\"1\":{\"56\":1}}],[\"已支付\",{\"1\":{\"56\":1}}],[\"控制交易流程\",{\"1\":{\"56\":1}}],[\"控制资源消耗\",{\"1\":{\"16\":1}}],[\"物流信息等交易相关数据\",{\"1\":{\"56\":1}}],[\"物流模块\",{\"1\":{\"41\":1}}],[\"收货地址\",{\"1\":{\"56\":1}}],[\"包括订单号\",{\"1\":{\"56\":1}}],[\"github\",{\"1\":{\"49\":1}}],[\"get\",{\"1\":{\"17\":1}}],[\"zq99299\",{\"1\":{\"49\":1}}],[\"进行冒泡排序\",{\"1\":{\"69\":2}}],[\"进行es数据同步\",{\"1\":{\"46\":1}}],[\"进入该状态的线程需要等待其他线程做出一些特定动作\",{\"1\":{\"12\":1}}],[\"最终得到的数组为\",{\"1\":{\"111\":1}}],[\"最终得到的数组就是一个有序的数组\",{\"1\":{\"81\":1}}],[\"最终将所有位数上的排序结果合并在一起\",{\"1\":{\"77\":1}}],[\"最终选用数据订阅方式\",{\"1\":{\"46\":1}}],[\"最坏情况\",{\"1\":{\"70\":1}}],[\"最好情况\",{\"1\":{\"70\":1}}],[\"最大线程数\",{\"1\":{\"18\":1}}],[\"订单状态机设计\",{\"0\":{\"58\":1}}],[\"订单\",{\"1\":{\"45\":1}}],[\"订单模块\",{\"1\":{\"41\":1}}],[\"热卖商品\",{\"1\":{\"44\":1}}],[\"规格描述\",{\"1\":{\"44\":1}}],[\"搜索相关度排序\",{\"1\":{\"44\":1}}],[\"搜索商品列表高性能低延时方案\",{\"0\":{\"44\":1}}],[\"搜索商品列表\",{\"1\":{\"42\":1}}],[\"更新库存\",{\"1\":{\"42\":1}}],[\"录入商品\",{\"1\":{\"42\":1}}],[\"供应链模块\",{\"1\":{\"41\":1}}],[\"从第一个元素开始\",{\"1\":{\"97\":1}}],[\"从左向右找第一个大于x的数\",{\"1\":{\"91\":1}}],[\"从右向左找第一个小于x的数\",{\"1\":{\"91\":1}}],[\"从起始位置开始排序\",{\"1\":{\"91\":1}}],[\"从数列中随机选取一个元素作为基准\",{\"1\":{\"91\":1}}],[\"从数列中挑出一个元素\",{\"1\":{\"91\":1}}],[\"从数列中挑出最小\",{\"1\":{\"68\":1}}],[\"从数组的一端向另一端移动的双指针算法\",{\"1\":{\"73\":1}}],[\"从数组的两端向中间移动的双指针算法\",{\"1\":{\"73\":1}}],[\"从个人手中回收商品\",{\"1\":{\"40\":1}}],[\"从外部企业渠道采购到公司内部\",{\"1\":{\"40\":1}}],[\"从而解决问题\",{\"1\":{\"73\":1}}],[\"从而实现高效的并发处理\",{\"1\":{\"16\":1}}],[\"从而提高程序的响应能力\",{\"1\":{\"16\":1}}],[\"从而控制程序对系统资源的消耗\",{\"1\":{\"16\":1}}],[\"before\",{\"1\":{\"91\":1}}],[\"build\",{\"1\":{\"81\":1}}],[\"bubblesort\",{\"1\":{\"70\":2}}],[\"bubble\",{\"1\":{\"67\":1}}],[\"back\",{\"1\":{\"49\":1}}],[\"book\",{\"1\":{\"49\":1}}],[\"b2b\",{\"1\":{\"40\":1}}],[\"blocked\",{\"1\":{\"12\":1}}],[\"企业回收\",{\"1\":{\"40\":1}}],[\"企业采购\",{\"1\":{\"40\":1}}],[\"企业生产\",{\"1\":{\"40\":1}}],[\"公司内部记录和管理\",{\"1\":{\"40\":1}}],[\"自产自销\",{\"1\":{\"40\":1}}],[\"商品信息\",{\"1\":{\"56\":1}}],[\"商品\",{\"1\":{\"45\":1}}],[\"商品副标题\",{\"1\":{\"44\":1}}],[\"商品标题\",{\"1\":{\"44\":1}}],[\"商品标签\",{\"1\":{\"44\":1,\"45\":1}}],[\"商品类目\",{\"1\":{\"44\":1,\"45\":1}}],[\"商品模型\",{\"0\":{\"43\":1}}],[\"商品核心功能\",{\"0\":{\"42\":1}}],[\"商品物流\",{\"1\":{\"41\":1}}],[\"商品售卖\",{\"1\":{\"41\":1}}],[\"商品上下游模块依赖\",{\"0\":{\"41\":1}}],[\"商品定价\",{\"1\":{\"40\":1}}],[\"商品描述\",{\"1\":{\"40\":1,\"44\":1}}],[\"商品规格\",{\"1\":{\"40\":1,\"45\":1}}],[\"商品来源\",{\"1\":{\"40\":1,\"41\":1}}],[\"商品的职责有哪些\",{\"0\":{\"40\":1}}],[\"商品业务和搜索业务强耦合\",{\"1\":{\"6\":1}}],[\"方案\",{\"2\":{\"38\":1,\"48\":1,\"51\":1,\"54\":1,\"63\":1,\"66\":1}}],[\"方法\",{\"1\":{\"12\":3}}],[\"电商购物车方案\",{\"0\":{\"64\":1}}],[\"电商订单的实现可以采用数据库存储\",{\"1\":{\"56\":1}}],[\"电商订单的职责\",{\"0\":{\"56\":1}}],[\"电商订单需要采取相应的安全措施\",{\"1\":{\"56\":1}}],[\"电商订单可以支持用户和商家对订单进行修改和取消操作\",{\"1\":{\"56\":1}}],[\"电商订单可以提供订单查询和统计功能\",{\"1\":{\"56\":1}}],[\"电商订单可以根据订单状态控制交易流程\",{\"1\":{\"56\":1}}],[\"电商订单负责记录和管理商品信息\",{\"1\":{\"56\":1}}],[\"电商订单具有以下职责\",{\"1\":{\"56\":1}}],[\"电商订单是记录电商平台上的交易信息的重要数据实体\",{\"1\":{\"56\":1}}],[\"电商订单设计方案\",{\"0\":{\"55\":1}}],[\"电商支付设计方案\",{\"0\":{\"52\":1}}],[\"电商搜索设计方案\",{\"0\":{\"49\":1}}],[\"电商商品设计方案\",{\"0\":{\"39\":1}}],[\"电商售后设计方案\",{\"0\":{\"36\":1}}],[\"电商\",{\"0\":{\"123\":1},\"2\":{\"34\":1,\"35\":1,\"37\":1,\"38\":1,\"47\":1,\"48\":1,\"50\":1,\"51\":1,\"53\":1,\"54\":1,\"62\":1,\"63\":1,\"65\":1,\"66\":1}}],[\"电商业务流程时序\",{\"0\":{\"33\":1},\"1\":{\"36\":1,\"39\":1,\"49\":1,\"52\":1,\"55\":1,\"64\":1}}],[\"综上所述\",{\"1\":{\"30\":1}}],[\"总结\",{\"0\":{\"30\":1}}],[\"无法删除中间元素\",{\"0\":{\"29\":1}}],[\"无法插入中间元素\",{\"0\":{\"28\":1}}],[\"n−2\",{\"1\":{\"100\":1}}],[\"n−1\",{\"1\":{\"100\":1}}],[\"num\",{\"1\":{\"82\":2}}],[\"null\",{\"1\":{\"78\":1}}],[\"nlogn\",{\"1\":{\"81\":1,\"91\":1}}],[\"n是待排序元素个数\",{\"1\":{\"77\":1}}],[\"n^2\",{\"1\":{\"70\":2,\"73\":1,\"91\":1,\"95\":1,\"97\":1,\"112\":1}}],[\"note\",{\"1\":{\"49\":1}}],[\"n\",{\"1\":{\"28\":1,\"29\":1,\"70\":4,\"73\":1,\"82\":8,\"91\":2,\"96\":1,\"97\":3,\"100\":1,\"112\":1,\"113\":3}}],[\"newsinglethreadexecutor\",{\"1\":{\"17\":1}}],[\"newfixedthreadpool\",{\"1\":{\"17\":3}}],[\"new\",{\"1\":{\"12\":1,\"78\":2}}],[\"需要进行n\",{\"1\":{\"70\":2}}],[\"需要将后面的元素都向前移动一位\",{\"1\":{\"29\":1}}],[\"需要将后面的元素都向后移动一位\",{\"1\":{\"28\":1}}],[\"需要重新创建一个更大的数组\",{\"1\":{\"27\":1}}],[\"需要定制搜索需求需求时\",{\"1\":{\"6\":1}}],[\"如果该元素\",{\"1\":{\"97\":1}}],[\"如果largest不是当前节点\",{\"1\":{\"82\":1}}],[\"如果右子节点比当前节点大\",{\"1\":{\"82\":1}}],[\"如果左子节点比当前节点大\",{\"1\":{\"82\":1}}],[\"如果他们的顺序错误就把他们交换过来\",{\"1\":{\"67\":1}}],[\"如果需要删除数组中的中间元素\",{\"1\":{\"29\":1}}],[\"如果需要在数组的中间插入元素\",{\"1\":{\"28\":1}}],[\"如果需要存储更多的元素\",{\"1\":{\"27\":1}}],[\"如何解决aba问题\",{\"0\":{\"61\":1}}],[\"如何避免重复下单\",{\"0\":{\"60\":1}}],[\"如何停止线程池中的线程\",{\"0\":{\"17\":1}}],[\"如待支付\",{\"1\":{\"56\":1}}],[\"大于新元素\",{\"1\":{\"97\":1}}],[\"大顶堆的特点是父节点的值大于或等于其子节点的值\",{\"1\":{\"81\":1}}],[\"大\",{\"1\":{\"68\":2,\"110\":2}}],[\"大小固定\",{\"0\":{\"27\":1}}],[\"大学\",{\"1\":{\"1\":1}}],[\"会预分配足够的内存空间用于存储元素\",{\"1\":{\"25\":1}}],[\"在剩下的元素中\",{\"1\":{\"110\":1}}],[\"在待排序的元素中\",{\"1\":{\"110\":1}}],[\"在已经排序的元素序列中从后向前扫描\",{\"1\":{\"97\":1}}],[\"在已排序序列中从后向前扫描\",{\"1\":{\"94\":1,\"97\":1}}],[\"在最坏情况下\",{\"1\":{\"97\":1}}],[\"在最坏的情况下\",{\"1\":{\"95\":1}}],[\"在最好情况下\",{\"1\":{\"96\":1,\"97\":1}}],[\"在这个分区退出之后\",{\"1\":{\"91\":1}}],[\"在创建数组时\",{\"1\":{\"25\":1}}],[\"在java中\",{\"1\":{\"17\":1}}],[\"30\",{\"1\":{\"91\":1}}],[\"3000\",{\"1\":{\"17\":1}}],[\"3\",{\"0\":{\"25\":1,\"29\":1},\"1\":{\"69\":14,\"97\":1,\"111\":9,\"113\":2}}],[\"修改等操作\",{\"1\":{\"24\":1}}],[\"删除\",{\"1\":{\"24\":1}}],[\"灵活操作\",{\"0\":{\"24\":1}}],[\"20\",{\"1\":{\"91\":1}}],[\"2015\",{\"1\":{\"1\":1}}],[\"2\",{\"0\":{\"24\":1,\"28\":1},\"1\":{\"82\":4,\"97\":1,\"111\":8,\"113\":2}}],[\"拒绝执行策略\",{\"1\":{\"18\":1}}],[\"用于存储同一类型的数据元素\",{\"1\":{\"21\":1}}],[\"用于创建新线程\",{\"1\":{\"18\":1}}],[\"用于保存等待线程执行的任务\",{\"1\":{\"18\":1}}],[\"任务队列\",{\"1\":{\"18\":1}}],[\"任务执行管理\",{\"1\":{\"16\":1}}],[\"时间复杂度\",{\"0\":{\"95\":1,\"112\":1}}],[\"时间复杂度为o\",{\"1\":{\"23\":1,\"28\":1,\"29\":1,\"70\":3}}],[\"时间单位\",{\"1\":{\"18\":1}}],[\"时间\",{\"1\":{\"18\":1}}],[\"+f\",{\"1\":{\"100\":1}}],[\"+=\",{\"1\":{\"78\":1}}],[\"++\",{\"1\":{\"78\":1}}],[\"+\",{\"1\":{\"17\":3,\"82\":3,\"97\":2}}],[\"o\",{\"1\":{\"112\":1}}],[\"output\",{\"1\":{\"78\":3}}],[\"out\",{\"1\":{\"17\":5,\"82\":2,\"91\":6,\"113\":1}}],[\"okr\",{\"1\":{\"2\":1}}],[\"void\",{\"1\":{\"17\":1,\"70\":1,\"78\":2,\"82\":4,\"91\":2,\"97\":1,\"113\":2}}],[\"vuepress\",{\"1\":{\"116\":1},\"2\":{\"118\":1}}],[\"vue\",{\"1\":{\"2\":1}}],[\"posts\",{\"0\":{\"120\":1}}],[\"pointers\",{\"1\":{\"73\":1}}],[\"pivot\",{\"1\":{\"91\":1}}],[\"placevalue\",{\"1\":{\"78\":5}}],[\"printf\",{\"1\":{\"91\":6}}],[\"print\",{\"1\":{\"82\":1}}],[\"println\",{\"1\":{\"17\":5,\"82\":1,\"113\":1}}],[\"private\",{\"1\":{\"78\":1}}],[\"prometheus\",{\"1\":{\"2\":1}}],[\"public\",{\"1\":{\"17\":2,\"70\":2,\"78\":2,\"82\":3,\"91\":3,\"97\":2,\"113\":3}}],[\"unit\",{\"1\":{\"18\":1}}],[\"util\",{\"1\":{\"17\":1}}],[\"uml\",{\"1\":{\"2\":1}}],[\"处理中断逻辑\",{\"1\":{\"17\":2}}],[\"处理任务的异常等\",{\"1\":{\"16\":1}}],[\"中断标志位为true表示被中断\",{\"1\":{\"17\":2}}],[\"停止某个线程\",{\"1\":{\"17\":3}}],[\"执行任务\",{\"1\":{\"17\":3}}],[\"i<a\",{\"1\":{\"91\":2}}],[\"i=0\",{\"1\":{\"91\":2}}],[\"i+1\",{\"1\":{\"91\":1,\"113\":1}}],[\"i++\",{\"1\":{\"70\":1,\"78\":3,\"91\":4,\"97\":1,\"113\":1}}],[\"insertionsort\",{\"1\":{\"97\":1}}],[\"insertion\",{\"1\":{\"97\":1}}],[\"index\",{\"1\":{\"78\":2}}],[\"int\",{\"1\":{\"70\":5,\"78\":17,\"82\":16,\"91\":6,\"97\":5,\"113\":7}}],[\"interrupt\",{\"1\":{\"17\":2}}],[\"interruptedexception\",{\"1\":{\"17\":1}}],[\"interrupted\",{\"1\":{\"17\":2}}],[\"i\",{\"1\":{\"70\":3,\"78\":16,\"82\":18,\"91\":15,\"97\":4,\"113\":5}}],[\"iscancelled\",{\"1\":{\"17\":1}}],[\"isdone\",{\"1\":{\"17\":1}}],[\"isinterrupted\",{\"1\":{\"17\":4}}],[\"import\",{\"1\":{\"17\":1}}],[\"if\",{\"1\":{\"17\":2,\"70\":1,\"78\":2,\"82\":3,\"91\":3,\"113\":1}}],[\"io\",{\"1\":{\"2\":1,\"49\":1}}],[\"workqueue\",{\"1\":{\"18\":1}}],[\"working\",{\"1\":{\"17\":1}}],[\"while\",{\"1\":{\"17\":4,\"78\":1,\"91\":3,\"97\":1}}],[\"waiting\",{\"1\":{\"12\":2}}],[\">=\",{\"1\":{\"78\":1,\"82\":2,\"97\":1}}],[\">\",{\"1\":{\"17\":4,\"70\":1,\"78\":2,\"82\":2,\"91\":1,\"97\":1}}],[\"f\",{\"1\":{\"100\":1}}],[\"for\",{\"1\":{\"70\":2,\"78\":4,\"82\":3,\"91\":2,\"97\":1,\"113\":2}}],[\"future<string>\",{\"1\":{\"17\":1}}],[\"future\",{\"1\":{\"17\":16}}],[\"flink\",{\"1\":{\"2\":1}}],[\"50\",{\"1\":{\"91\":1}}],[\"5000\",{\"1\":{\"17\":1}}],[\"5\",{\"1\":{\"17\":3,\"69\":12,\"82\":1,\"97\":1,\"111\":9,\"113\":2}}],[\"=⎩⎨⎧​01f\",{\"1\":{\"100\":1}}],[\"==\",{\"1\":{\"78\":1}}],[\"=\",{\"1\":{\"17\":8,\"70\":6,\"78\":15,\"82\":13,\"91\":7,\"97\":6,\"113\":9}}],[\"end\",{\"1\":{\"49\":1}}],[\"e\",{\"0\":{\"119\":1},\"1\":{\"17\":1}}],[\"exception\",{\"1\":{\"17\":1}}],[\"executors\",{\"1\":{\"17\":4}}],[\"executorservice\",{\"1\":{\"17\":4}}],[\"executor\",{\"1\":{\"17\":12}}],[\"es数据同步方案\",{\"0\":{\"46\":1}}],[\"es数据映射\",{\"0\":{\"45\":1}}],[\"es需要对以下数据做映射\",{\"1\":{\"45\":1}}],[\"es\",{\"1\":{\"6\":1},\"2\":{\"10\":1,\"11\":1}}],[\"但在最坏情况下时间复杂度为o\",{\"1\":{\"91\":1}}],[\"但是不适用于需要动态增加或删除元素的场景\",{\"1\":{\"30\":1}}],[\"但是可以通过以下几种方式中断线程的执行\",{\"1\":{\"17\":1}}],[\"但还没有调用start\",{\"1\":{\"12\":1}}],[\"通常有以下几种选取方法\",{\"1\":{\"91\":1}}],[\"通常用于解决数组或链表相关的问题\",{\"1\":{\"73\":1}}],[\"通过构建有序序列\",{\"1\":{\"97\":1}}],[\"通过上面文章的方案比较\",{\"1\":{\"46\":1}}],[\"通过工作线程来执行任务\",{\"1\":{\"16\":1}}],[\"通知或中断\",{\"1\":{\"12\":1}}],[\"消费者模式\",{\"1\":{\"16\":1}}],[\"以上代码实现了选择排序的排序算法和排序结果的输出\",{\"1\":{\"113\":1}}],[\"以下是堆排序的示例代码\",{\"1\":{\"81\":1}}],[\"以满足不同业务场景的需求\",{\"1\":{\"56\":1}}],[\"以便用户和商家进行订单管理\",{\"1\":{\"56\":1}}],[\"以达到最佳的性能和效果\",{\"1\":{\"16\":1}}],[\"以及降低资源消耗和线程管理的复杂度\",{\"1\":{\"16\":1}}],[\"可以采用随机选取基准\",{\"1\":{\"91\":1}}],[\"可以将时间复杂度从o\",{\"1\":{\"73\":1}}],[\"可以有效利用内存空间\",{\"1\":{\"25\":1}}],[\"可以通过索引对数组中的元素进行增加\",{\"1\":{\"24\":1}}],[\"可以通过索引直接访问数组中的元素\",{\"1\":{\"23\":1}}],[\"可以根据实际需要来配置线程池的参数\",{\"1\":{\"16\":1}}],[\"可以避免过多的线程同时占用资源\",{\"1\":{\"16\":1}}],[\"并递归调整堆\",{\"1\":{\"82\":1}}],[\"并有公司内部记录和管理\",{\"1\":{\"40\":1}}],[\"并由公司内部记录和管理\",{\"1\":{\"40\":1}}],[\"并且不能动态改变\",{\"1\":{\"27\":1}}],[\"并提供了丰富的配置选项\",{\"1\":{\"16\":1}}],[\"并提高程序的可靠性\",{\"1\":{\"16\":1}}],[\"并发\",{\"2\":{\"14\":1,\"20\":1}}],[\"限制任务的执行时间\",{\"1\":{\"16\":1}}],[\"而不用等待新的线程创建和就绪\",{\"1\":{\"16\":1}}],[\"而不是为每个任务创建一个新的线程\",{\"1\":{\"16\":1}}],[\"当前位的权值\",{\"1\":{\"78\":1}}],[\"当数组是逆序排列时\",{\"1\":{\"70\":1}}],[\"当数组已经按照排序需求排好时\",{\"1\":{\"70\":1}}],[\"当版本一致的时候更新数据\",{\"1\":{\"61\":1}}],[\"当任务队列和线程池都达到最大容量时\",{\"1\":{\"18\":1}}],[\"当有新的任务提交时\",{\"1\":{\"16\":1}}],[\"当线程数量过多时\",{\"1\":{\"16\":1}}],[\"导致资源浪费和系统负载过高\",{\"1\":{\"16\":1}}],[\"这种数据结构进行选择排序的一种算法\",{\"1\":{\"81\":1}}],[\"这种算法通常用于解决一些排序或统计的问题\",{\"1\":{\"73\":1}}],[\"这种算法通常用于解决一些查找或筛选的问题\",{\"1\":{\"73\":1}}],[\"这种情况下\",{\"1\":{\"73\":2}}],[\"这样可以保证任务的执行质量\",{\"1\":{\"16\":1}}],[\"这样可以避免线程的创建和销毁带来的开销\",{\"1\":{\"16\":1}}],[\"这是我的个人简历\",{\"1\":{\"0\":1}}],[\"表示该线程已经执行完毕\",{\"1\":{\"12\":1}}],[\"表示线程阻塞于锁\",{\"1\":{\"12\":1}}],[\"终止\",{\"1\":{\"12\":1}}],[\"它的基本思想是\",{\"1\":{\"109\":1}}],[\"它的基本思想是通过构建有序序列\",{\"1\":{\"94\":1}}],[\"它的基本步骤如下\",{\"1\":{\"91\":1}}],[\"它重复地走访过要排序的数列\",{\"1\":{\"67\":1}}],[\"它由一组连续的内存空间组成\",{\"1\":{\"21\":1}}],[\"它可以在指定的时间后自行返回\",{\"1\":{\"12\":1}}],[\"它包含线程的控制方法和线程的生命周期方法\",{\"1\":{\"12\":1}}],[\"超时等待\",{\"1\":{\"12\":1}}],[\"等待\",{\"1\":{\"12\":1}}],[\"等待被线程调度选中\",{\"1\":{\"12\":1}}],[\"阻塞\",{\"1\":{\"12\":1}}],[\"就绪状态的线程在获得cpu时间片后变为运行中状态\",{\"1\":{\"12\":1}}],[\"该元素可以认为已经被排序\",{\"1\":{\"97\":1}}],[\"该基准就处于数列的中间位置\",{\"1\":{\"91\":1}}],[\"该算法通过使用两个指针\",{\"1\":{\"73\":1}}],[\"该类提供了可重用的线程池\",{\"1\":{\"16\":1}}],[\"该状态不同于waiting\",{\"1\":{\"12\":1}}],[\"该状态的线程位于可运行线程池中\",{\"1\":{\"12\":1}}],[\"该方法包含线程要执行的代码\",{\"1\":{\"12\":1}}],[\"两种状态笼统的称为\",{\"1\":{\"12\":1}}],[\"运行\",{\"1\":{\"12\":2}}],[\"新创建了一个线程对象\",{\"1\":{\"12\":1}}],[\"初始化largest为当前节点\",{\"1\":{\"82\":1}}],[\"初始\",{\"1\":{\"12\":1}}],[\"r\",{\"1\":{\"91\":5}}],[\"right\",{\"1\":{\"82\":4}}],[\"radix\",{\"1\":{\"78\":3}}],[\"radixsort\",{\"1\":{\"78\":2}}],[\"running\",{\"1\":{\"12\":2}}],[\"runnable\",{\"1\":{\"12\":1}}],[\"runnable接口定义了一个run\",{\"1\":{\"12\":1}}],[\"result\",{\"1\":{\"17\":1}}],[\"return\",{\"1\":{\"17\":1,\"78\":1}}],[\"ready\",{\"1\":{\"12\":2}}],[\"react\",{\"1\":{\"2\":1}}],[\"redis\",{\"1\":{\"2\":1}}],[\"two\",{\"1\":{\"73\":1}}],[\"temp\",{\"1\":{\"70\":2,\"82\":2,\"113\":2}}],[\"terminated\",{\"1\":{\"12\":1}}],[\"timeout\",{\"1\":{\"18\":2}}],[\"timed\",{\"1\":{\"12\":1}}],[\"tostring\",{\"1\":{\"113\":1}}],[\"to\",{\"1\":{\"17\":1}}],[\"try\",{\"1\":{\"17\":2}}],[\"true\",{\"1\":{\"17\":2}}],[\"throws\",{\"1\":{\"17\":1}}],[\"threadfactory\",{\"1\":{\"18\":1}}],[\"thread\",{\"1\":{\"17\":10}}],[\"thread类是一个实现了runnable接口的类\",{\"1\":{\"12\":1}}],[\"tcc\",{\"1\":{\"2\":1}}],[\"线程工厂\",{\"1\":{\"18\":1}}],[\"线程空闲\",{\"1\":{\"18\":1}}],[\"线程池的核心参数如下\",{\"1\":{\"18\":1}}],[\"线程池的核心参数\",{\"0\":{\"18\":1}}],[\"线程池中的线程是并发执行的\",{\"1\":{\"17\":1}}],[\"线程池可以立即分配线程执行任务\",{\"1\":{\"16\":1}}],[\"线程池设计思想\",{\"0\":{\"16\":1}}],[\"线程池\",{\"0\":{\"15\":1}}],[\"线程对象创建后\",{\"1\":{\"12\":1}}],[\"线程\",{\"0\":{\"12\":1}}],[\"存放在序列的起始位置\",{\"1\":{\"109\":1}}],[\"存在分布式事务问题\",{\"1\":{\"6\":1}}],[\"存储系统\",{\"1\":{\"2\":1}}],[\"和arr\",{\"1\":{\"70\":1}}],[\"和运行中\",{\"1\":{\"12\":1}}],[\"和\",{\"1\":{\"6\":1}}],[\"还需要改动商品代码\",{\"1\":{\"6\":1}}],[\"扩展性差\",{\"1\":{\"6\":1}}],[\"缺点\",{\"1\":{\"6\":1}}],[\"优点\",{\"1\":{\"6\":1}}],[\"数学公式如下\",{\"1\":{\"100\":1}}],[\"数列还是\",{\"1\":{\"69\":5}}],[\"数列变成\",{\"1\":{\"69\":5}}],[\"数据结构\",{\"0\":{\"122\":1},\"2\":{\"31\":1,\"32\":1}}],[\"数据订阅\",{\"0\":{\"9\":1},\"1\":{\"5\":1}}],[\"数组保持不变\",{\"1\":{\"111\":2}}],[\"数组变为\",{\"1\":{\"111\":3}}],[\"数组适用于元素数量固定且需要直接访问的场景\",{\"1\":{\"30\":1}}],[\"数组的右边界\",{\"1\":{\"91\":1}}],[\"数组的左边界\",{\"1\":{\"91\":1}}],[\"数组的大小在创建时就需要确定\",{\"1\":{\"27\":1}}],[\"数组的主要缺点包括\",{\"0\":{\"26\":1}}],[\"数组的主要优点包括\",{\"0\":{\"22\":1}}],[\"数组是一种线性数据结构\",{\"1\":{\"21\":1}}],[\"数组\",{\"0\":{\"21\":1},\"2\":{\"32\":1,\"75\":1}}],[\"数仓\",{\"1\":{\"2\":1}}],[\"定时任务\",{\"0\":{\"8\":1},\"1\":{\"5\":1}}],[\"异步双写\",{\"0\":{\"7\":1},\"1\":{\"5\":1}}],[\"同步双写\",{\"0\":{\"6\":1},\"1\":{\"5\":1}}],[\"编写过数据大屏以及后台管理界面\",{\"1\":{\"2\":1}}],[\"框架\",{\"1\":{\"2\":1}}],[\"实现选择排序的示例代码\",{\"1\":{\"113\":1}}],[\"实现步骤\",{\"0\":{\"78\":1}}],[\"实现原理\",{\"1\":{\"2\":2}}],[\"实时计算任务\",{\"1\":{\"2\":1}}],[\"离线计算任务\",{\"1\":{\"2\":1}}],[\"c2b\",{\"1\":{\"40\":1}}],[\"catch\",{\"1\":{\"17\":1}}],[\"cancel\",{\"1\":{\"17\":3}}],[\"class\",{\"1\":{\"17\":1,\"70\":1,\"78\":1,\"82\":1,\"91\":1,\"97\":1,\"113\":1}}],[\"clickhouse\",{\"1\":{\"2\":1}}],[\"conquer\",{\"1\":{\"91\":1}}],[\"concurrent\",{\"1\":{\"17\":1}}],[\"count\",{\"1\":{\"78\":7}}],[\"countingsort\",{\"1\":{\"78\":2}}],[\"corepoolsize\",{\"1\":{\"18\":1}}],[\"com\",{\"1\":{\"1\":1}}],[\"currentthread\",{\"1\":{\"17\":6}}],[\"架构\",{\"1\":{\"2\":1}}],[\"策略\",{\"1\":{\"2\":1}}],[\"x\",{\"1\":{\"91\":5}}],[\"xxl\",{\"1\":{\"2\":1}}],[\"xa\",{\"1\":{\"2\":1}}],[\"heapify\",{\"1\":{\"82\":4}}],[\"heapsort\",{\"1\":{\"82\":1}}],[\"heap\",{\"1\":{\"81\":4}}],[\"https\",{\"1\":{\"49\":1}}],[\"hbase\",{\"1\":{\"2\":1}}],[\"handler\",{\"1\":{\"18\":1}}],[\"hadoop\",{\"1\":{\"2\":1}}],[\"ha\",{\"1\":{\"2\":1}}],[\"掌握常见监控告警设计\",{\"1\":{\"2\":1}}],[\"掌握常见分布式事务设计\",{\"1\":{\"2\":1}}],[\"掌握数据仓库设计\",{\"1\":{\"2\":1}}],[\"掌握基于\",{\"1\":{\"2\":1}}],[\"掌握分布式调度设计\",{\"1\":{\"2\":1}}],[\"掌握分布式缓存设计\",{\"1\":{\"2\":1}}],[\"掌握分布式存储设计\",{\"1\":{\"2\":1}}],[\"掌握复杂\",{\"1\":{\"2\":1}}],[\"脚手架\",{\"1\":{\"2\":1}}],[\"脚本\",{\"1\":{\"2\":1}}],[\"微服务分布式架构实现\",{\"1\":{\"2\":1}}],[\"全家桶\",{\"1\":{\"2\":1}}],[\"全日制统招本科\",{\"1\":{\"1\":1}}],[\"系统生态\",{\"1\":{\"2\":1}}],[\"系统\",{\"1\":{\"2\":1}}],[\"分别从数组或链表的两端向中间移动\",{\"1\":{\"73\":1}}],[\"分布式事务管理\",{\"1\":{\"2\":1}}],[\"分库分表\",{\"1\":{\"2\":1}}],[\"minindex\",{\"1\":{\"113\":5}}],[\"md\",{\"1\":{\"36\":1,\"39\":1,\"46\":1,\"49\":1,\"52\":1,\"55\":1,\"64\":1}}],[\"max\",{\"1\":{\"81\":1}}],[\"maxnum\",{\"1\":{\"78\":4}}],[\"maximumpoolsize\",{\"1\":{\"18\":1}}],[\"main\",{\"1\":{\"17\":2,\"82\":1,\"91\":1,\"113\":1}}],[\"mvcc\",{\"1\":{\"2\":1}}],[\"mysql同步数据es\",{\"0\":{\"5\":1},\"1\":{\"46\":1}}],[\"mysql\",{\"1\":{\"2\":3,\"6\":1}}],[\"after\",{\"1\":{\"91\":1}}],[\"a\",{\"1\":{\"91\":17}}],[\"and\",{\"1\":{\"91\":1}}],[\"algorithm\",{\"1\":{\"73\":1}}],[\"arrays\",{\"1\":{\"113\":1}}],[\"array\",{\"1\":{\"97\":7}}],[\"arraycopy\",{\"1\":{\"78\":1}}],[\"arr\",{\"1\":{\"70\":8,\"78\":17,\"82\":20,\"113\":11}}],[\"args\",{\"1\":{\"17\":1,\"82\":1,\"91\":1,\"113\":1}}],[\"api接口调用等方式\",{\"1\":{\"56\":1}}],[\"acid\",{\"1\":{\"2\":1}}],[\"agent\",{\"1\":{\"2\":1}}],[\"了解索引实现机制\",{\"1\":{\"2\":1}}],[\"了解\",{\"1\":{\"2\":4}}],[\"对应的序列是逆序的\",{\"1\":{\"97\":1}}],[\"对应的序列是已排序的\",{\"1\":{\"97\":1}}],[\"对未排序数据\",{\"1\":{\"94\":1,\"97\":1}}],[\"对基准的左右两个分区重复步骤1和步骤2\",{\"1\":{\"91\":1}}],[\"对交换后的元素进行调整\",{\"1\":{\"82\":1}}],[\"对堆进行调整\",{\"1\":{\"81\":1}}],[\"对最末位进行排序\",{\"1\":{\"78\":1}}],[\"对数列\",{\"1\":{\"69\":1}}],[\"对\",{\"1\":{\"2\":1}}],[\"熟练编写\",{\"1\":{\"2\":1}}],[\"熟练\",{\"1\":{\"2\":1}}],[\"熟练使用常见的分布式调度平台\",{\"1\":{\"2\":1}}],[\"熟练使用\",{\"1\":{\"2\":2}}],[\"熟悉线上运维命令\",{\"1\":{\"2\":1}}],[\"熟悉常见\",{\"1\":{\"2\":1}}],[\"熟悉读写分离策略\",{\"1\":{\"2\":1}}],[\"熟悉\",{\"1\":{\"2\":6}}],[\"主从复制策略\",{\"1\":{\"2\":1}}],[\"工作法\",{\"1\":{\"2\":1}}],[\"精通\",{\"1\":{\"2\":2}}],[\"精通业务关系建模\",{\"1\":{\"2\":1}}],[\"设计图\",{\"1\":{\"2\":1}}],[\"绘制系统架构图\",{\"1\":{\"2\":1}}],[\"能够独立设计大型复杂系统\",{\"1\":{\"2\":1}}],[\"j+1\",{\"1\":{\"70\":4}}],[\"j++\",{\"1\":{\"70\":1,\"113\":1}}],[\"j\",{\"1\":{\"70\":6,\"82\":3,\"91\":11,\"97\":7,\"113\":4}}],[\"job\",{\"1\":{\"2\":1}}],[\"jvm\",{\"1\":{\"2\":1}}],[\"java代码实现\",{\"0\":{\"97\":1}}],[\"java实现\",{\"0\":{\"82\":1}}],[\"java线程池的设计思想是基于生产者\",{\"1\":{\"16\":1}}],[\"java线程池的设计思想是为了提高线程的使用效率和响应能力\",{\"1\":{\"16\":1}}],[\"java线程池通过threadpoolexecutor类来实现\",{\"1\":{\"16\":1}}],[\"java线程池可以对任务的执行进行管理\",{\"1\":{\"16\":1}}],[\"java线程池可以快速响应任务的提交和执行\",{\"1\":{\"16\":1}}],[\"java线程池可以控制线程的数量\",{\"1\":{\"16\":1}}],[\"java线程池中的线程可以被重复使用\",{\"1\":{\"16\":1}}],[\"java线程池主要具有以下设计思想\",{\"1\":{\"16\":1}}],[\"java线程中将就绪\",{\"1\":{\"12\":1}}],[\"java中的线程有以下几种状态\",{\"1\":{\"12\":1}}],[\"java中的线程由thread类和runnable接口实现\",{\"1\":{\"12\":1}}],[\"java的线程是程序执行的最小单位\",{\"1\":{\"12\":1}}],[\"java\",{\"0\":{\"121\":1},\"1\":{\"2\":2,\"17\":1,\"113\":1},\"2\":{\"11\":1,\"13\":1,\"14\":1,\"19\":1,\"20\":1}}],[\"s\",{\"0\":{\"119\":1}}],[\"selectionsort\",{\"1\":{\"113\":3}}],[\"seata\",{\"1\":{\"2\":1}}],[\"swap\",{\"1\":{\"82\":3}}],[\"sort\",{\"1\":{\"67\":1,\"81\":2,\"82\":2,\"91\":2,\"97\":2}}],[\"sleep\",{\"1\":{\"17\":2}}],[\"system\",{\"1\":{\"17\":5,\"78\":1,\"82\":2,\"91\":6,\"113\":1}}],[\"storage\",{\"1\":{\"49\":1}}],[\"status\",{\"1\":{\"17\":2}}],[\"static\",{\"1\":{\"17\":1,\"70\":1,\"78\":2,\"82\":4,\"91\":2,\"97\":1,\"113\":2}}],[\"string\",{\"1\":{\"17\":1,\"82\":1,\"91\":1,\"113\":1}}],[\"submit\",{\"1\":{\"17\":4}}],[\"suveng\",{\"1\":{\"1\":1}}],[\"schedulex\",{\"1\":{\"2\":1}}],[\"shutdown\",{\"1\":{\"17\":1}}],[\"shutdownnow\",{\"1\":{\"17\":3}}],[\"shell\",{\"1\":{\"2\":1}}],[\"sharding\",{\"1\":{\"2\":1}}],[\"springblade\",{\"1\":{\"2\":1}}],[\"springcloud\",{\"1\":{\"2\":1}}],[\"spring\",{\"1\":{\"2\":1}}],[\"sphere\",{\"1\":{\"2\":1}}],[\"spi\",{\"1\":{\"2\":1}}],[\"sql\",{\"1\":{\"2\":3}}],[\"反射\",{\"1\":{\"2\":1}}],[\"语言\",{\"1\":{\"2\":1}}],[\"开发技能\",{\"0\":{\"2\":1}}],[\"邮箱\",{\"1\":{\"1\":1}}],[\"手机号\",{\"1\":{\"1\":1}}],[\"60\",{\"1\":{\"91\":1}}],[\"6\",{\"1\":{\"1\":1,\"69\":9,\"82\":1,\"97\":1}}],[\"9~2019\",{\"1\":{\"1\":1}}],[\"软件工程专业\",{\"1\":{\"1\":1}}],[\"韩山师范学院\",{\"1\":{\"1\":1}}],[\"13\",{\"1\":{\"82\":1}}],[\"11\",{\"1\":{\"82\":1}}],[\"10\",{\"1\":{\"78\":5,\"91\":1}}],[\"1次遍历\",{\"1\":{\"70\":2}}],[\"1\",{\"0\":{\"23\":1,\"27\":1},\"1\":{\"23\":1,\"70\":2,\"78\":7,\"81\":1,\"82\":3,\"91\":3,\"95\":1,\"96\":1,\"97\":5,\"111\":8,\"113\":3}}],[\"163\",{\"1\":{\"1\":1}}],[\"18320664028\",{\"1\":{\"1\":1}}],[\"12\",{\"1\":{\"1\":1,\"82\":1}}],[\"1996\",{\"1\":{\"1\":1}}],[\"出生年月\",{\"1\":{\"1\":1}}],[\"男\",{\"1\":{\"1\":1}}],[\"性别\",{\"1\":{\"1\":1}}],[\"苏文广\",{\"1\":{\"1\":1}}],[\"姓名\",{\"1\":{\"1\":1}}],[\"个人信息\",{\"0\":{\"1\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
