const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":200,\"nextId\":200,\"documentIds\":{\"0\":\"v-858cfdd6\",\"1\":\"v-858cfdd6#个人信息\",\"2\":\"v-858cfdd6#开发技能\",\"3\":\"v-858cfdd6@0\",\"4\":\"v-858cfdd6@1\",\"5\":\"v-3ea5b5a5\",\"6\":\"v-3ea5b5a5#同步双写\",\"7\":\"v-3ea5b5a5#优点\",\"8\":\"v-3ea5b5a5#缺点\",\"9\":\"v-3ea5b5a5#异步双写\",\"10\":\"v-3ea5b5a5#优点-1\",\"11\":\"v-3ea5b5a5#缺点-1\",\"12\":\"v-3ea5b5a5#定时任务\",\"13\":\"v-3ea5b5a5#优点-2\",\"14\":\"v-3ea5b5a5#缺点-2\",\"15\":\"v-3ea5b5a5#数据订阅\",\"16\":\"v-3ea5b5a5#优点-3\",\"17\":\"v-3ea5b5a5@0\",\"18\":\"v-3ea5b5a5@1\",\"19\":\"v-6347236c\",\"20\":\"v-6347236c@0\",\"21\":\"v-6347236c@1\",\"22\":\"v-4d829fab\",\"23\":\"v-4d829fab@0\",\"24\":\"v-4d829fab@1\",\"25\":\"v-787d25bf\",\"26\":\"v-787d25bf@0\",\"27\":\"v-787d25bf@1\",\"28\":\"v-09671a78\",\"29\":\"v-09671a78#优化原则\",\"30\":\"v-09671a78#排查慢查询过程\",\"31\":\"v-09671a78@0\",\"32\":\"v-09671a78@1\",\"33\":\"v-2b68b366\",\"34\":\"v-2b68b366@0\",\"35\":\"v-2b68b366@1\",\"36\":\"v-042d9c5f\",\"37\":\"v-042d9c5f#语法解析器应用场景\",\"38\":\"v-042d9c5f#语法解析原理\",\"39\":\"v-042d9c5f@0\",\"40\":\"v-042d9c5f@1\",\"41\":\"v-7276c2e1\",\"42\":\"v-7276c2e1#例子计算\",\"43\":\"v-7276c2e1@0\",\"44\":\"v-7276c2e1@1\",\"45\":\"v-966f2e04\",\"46\":\"v-966f2e04#数组的主要优点包括\",\"47\":\"v-966f2e04#_1-直接访问\",\"48\":\"v-966f2e04#_2-灵活操作\",\"49\":\"v-966f2e04#_3-空间有效利用\",\"50\":\"v-966f2e04#数组的主要缺点包括\",\"51\":\"v-966f2e04#_1-大小固定\",\"52\":\"v-966f2e04#_2-无法插入中间元素\",\"53\":\"v-966f2e04#_3-无法删除中间元素\",\"54\":\"v-966f2e04#总结\",\"55\":\"v-966f2e04@0\",\"56\":\"v-966f2e04@1\",\"57\":\"v-68c6cd2b\",\"58\":\"v-68c6cd2b#高并发定义\",\"59\":\"v-68c6cd2b#衡量高并发的指标\",\"60\":\"v-68c6cd2b#影响并发的因素\",\"61\":\"v-68c6cd2b#高并发设计-1\",\"62\":\"v-68c6cd2b#测试无缓存\",\"63\":\"v-68c6cd2b#测试2级缓存\",\"64\":\"v-68c6cd2b#测试3级缓存\",\"65\":\"v-68c6cd2b@0\",\"66\":\"v-68c6cd2b@1\",\"67\":\"v-6e83e7f2\",\"68\":\"v-6e83e7f2@0\",\"69\":\"v-6e83e7f2@1\",\"70\":\"v-07deb444\",\"71\":\"v-07deb444@0\",\"72\":\"v-07deb444@1\",\"73\":\"v-7f3bcc24\",\"74\":\"v-7f3bcc24#商品的职责有哪些\",\"75\":\"v-7f3bcc24#商品上下游模块依赖\",\"76\":\"v-7f3bcc24#商品核心功能\",\"77\":\"v-7f3bcc24#商品模型\",\"78\":\"v-7f3bcc24#搜索商品列表高性能低延时方案\",\"79\":\"v-7f3bcc24#es数据映射\",\"80\":\"v-7f3bcc24#es数据同步方案\",\"81\":\"v-7f3bcc24@0\",\"82\":\"v-7f3bcc24@1\",\"83\":\"v-ad1c3c84\",\"84\":\"v-ad1c3c84@0\",\"85\":\"v-ad1c3c84@1\",\"86\":\"v-15048e98\",\"87\":\"v-15048e98@0\",\"88\":\"v-15048e98@1\",\"89\":\"v-39f55f6b\",\"90\":\"v-39f55f6b#电商订单的职责\",\"91\":\"v-39f55f6b#核心api\",\"92\":\"v-39f55f6b#订单状态机设计\",\"93\":\"v-39f55f6b#注意的场景\",\"94\":\"v-39f55f6b#如何避免重复下单\",\"95\":\"v-39f55f6b#如何解决aba问题-网络异常情况下-请求顺序不一致导致数据错乱\",\"96\":\"v-39f55f6b@0\",\"97\":\"v-39f55f6b@1\",\"98\":\"v-3b3d9a8a\",\"99\":\"v-3b3d9a8a@0\",\"100\":\"v-3b3d9a8a@1\",\"101\":\"v-64eca334\",\"102\":\"v-64eca334@0\",\"103\":\"v-64eca334@1\",\"104\":\"v-62166cba\",\"105\":\"v-62166cba@0\",\"106\":\"v-62166cba@1\",\"107\":\"v-5b0e557c\",\"108\":\"v-5b0e557c@0\",\"109\":\"v-5b0e557c@1\",\"110\":\"v-1f90216c\",\"111\":\"v-1f90216c@0\",\"112\":\"v-1f90216c@1\",\"113\":\"v-61d2c517\",\"114\":\"v-61d2c517#算法描述\",\"115\":\"v-61d2c517#示例\",\"116\":\"v-61d2c517#复杂度分析\",\"117\":\"v-61d2c517@0\",\"118\":\"v-61d2c517@1\",\"119\":\"v-1465db28\",\"120\":\"v-1465db28@0\",\"121\":\"v-1465db28@1\",\"122\":\"v-7ab0b60a\",\"123\":\"v-7ab0b60a#基本原理\",\"124\":\"v-7ab0b60a#实现步骤\",\"125\":\"v-7ab0b60a@0\",\"126\":\"v-7ab0b60a@1\",\"127\":\"v-c5881fe4\",\"128\":\"v-c5881fe4#java实现\",\"129\":\"v-c5881fe4@0\",\"130\":\"v-c5881fe4@1\",\"131\":\"v-52f59784\",\"132\":\"v-52f59784@0\",\"133\":\"v-52f59784@1\",\"134\":\"v-4947ed96\",\"135\":\"v-4947ed96@0\",\"136\":\"v-4947ed96@1\",\"137\":\"v-ad557380\",\"138\":\"v-ad557380@0\",\"139\":\"v-ad557380@1\",\"140\":\"v-6898a9f1\",\"141\":\"v-6898a9f1#时间复杂度\",\"142\":\"v-6898a9f1#空间复杂度\",\"143\":\"v-6898a9f1#java代码实现\",\"144\":\"v-6898a9f1@0\",\"145\":\"v-6898a9f1@1\",\"146\":\"v-b8452806\",\"147\":\"v-b8452806@0\",\"148\":\"v-b8452806@1\",\"149\":\"v-011cae78\",\"150\":\"v-011cae78@0\",\"151\":\"v-011cae78@1\",\"152\":\"v-2c0e6a38\",\"153\":\"v-2c0e6a38@0\",\"154\":\"v-2c0e6a38@1\",\"155\":\"v-58784f4c\",\"156\":\"v-58784f4c#步骤\",\"157\":\"v-58784f4c#示例\",\"158\":\"v-58784f4c#时间复杂度\",\"159\":\"v-58784f4c#代码实现\",\"160\":\"v-58784f4c@0\",\"161\":\"v-58784f4c@1\",\"162\":\"v-6d027e4e\",\"163\":\"v-6d027e4e@0\",\"164\":\"v-6d027e4e@1\",\"165\":\"v-1efa0bee\",\"166\":\"v-1efa0bee@0\",\"167\":\"v-1efa0bee@1\",\"168\":\"v-486affa7\",\"169\":\"v-486affa7@0\",\"170\":\"v-486affa7@1\",\"171\":\"v-3a8a2c5c\",\"172\":\"v-3a8a2c5c@0\",\"173\":\"v-3a8a2c5c@1\",\"174\":\"v-03fa5ba6\",\"175\":\"v-03fa5ba6@0\",\"176\":\"v-03fa5ba6@1\",\"177\":\"v-fb60badc\",\"178\":\"v-fb60badc@0\",\"179\":\"v-fb60badc@1\",\"180\":\"v-3ba9eaaa\",\"181\":\"v-3ba9eaaa#线程池设计思想\",\"182\":\"v-3ba9eaaa#如何停止线程池中的线程\",\"183\":\"v-3ba9eaaa#线程池的核心参数\",\"184\":\"v-3ba9eaaa@0\",\"185\":\"v-3ba9eaaa@1\",\"186\":\"v-f5756414\",\"187\":\"v-564155e4\",\"188\":\"v-0b20da1e\",\"189\":\"v-2d9b4560\",\"190\":\"v-a8417f7a\",\"191\":\"v-01b1397a\",\"192\":\"v-d0fc7660\",\"193\":\"v-29684d1b\",\"194\":\"v-461e7ade\",\"195\":\"v-595ecdf7\",\"196\":\"v-00c53a6e\",\"197\":\"v-0ef3f779\",\"198\":\"v-e7a82ed0\",\"199\":\"v-5b89fbea\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[1,20],\"2\":[1,84],\"3\":[null,null,1],\"4\":[null,null,1],\"5\":[1,4],\"6\":[1],\"7\":[1,3],\"8\":[1,11],\"9\":[1,1],\"10\":[1,2],\"11\":[1,5],\"12\":[1],\"13\":[1,1],\"14\":[1,2],\"15\":[1],\"16\":[1,12],\"17\":[null,null,1],\"18\":[null,null,4],\"19\":[1],\"20\":[null,null,1],\"21\":[null,null,2],\"22\":[1],\"23\":[null,null,1],\"24\":[null,null,2],\"25\":[1],\"26\":[null,null,1],\"27\":[null,null,2],\"28\":[1],\"29\":[1,4],\"30\":[1,7],\"31\":[null,null,1],\"32\":[null,null,2],\"33\":[1,31],\"34\":[null,null,1],\"35\":[null,null,2],\"36\":[1,19],\"37\":[1,1],\"38\":[1,1],\"39\":[null,null,1],\"40\":[null,null,2],\"41\":[1,28],\"42\":[1,21],\"43\":[null,null,1],\"44\":[null,null,2],\"45\":[1,4],\"46\":[2],\"47\":[2,4],\"48\":[2,4],\"49\":[2,4],\"50\":[2],\"51\":[2,5],\"52\":[2,5],\"53\":[2,5],\"54\":[1,4],\"55\":[null,null,1],\"56\":[null,null,2],\"57\":[1],\"58\":[1,9],\"59\":[1,13],\"60\":[1,15],\"61\":[1,34],\"62\":[1],\"63\":[1],\"64\":[1],\"65\":[null,null,1],\"66\":[null,null,2],\"67\":[1],\"68\":[null,null,1],\"69\":[null,null,1],\"70\":[1,2],\"71\":[null,null,1],\"72\":[null,null,3],\"73\":[1,2],\"74\":[2,16],\"75\":[1,7],\"76\":[1,4],\"77\":[1],\"78\":[1,9],\"79\":[1,6],\"80\":[1,5],\"81\":[null,null,1],\"82\":[null,null,3],\"83\":[1,12],\"84\":[null,null,1],\"85\":[null,null,3],\"86\":[1,2],\"87\":[null,null,1],\"88\":[null,null,3],\"89\":[1,2],\"90\":[1,31],\"91\":[1,9],\"92\":[1],\"93\":[1],\"94\":[2,5],\"95\":[4,6],\"96\":[null,null,1],\"97\":[null,null,3],\"98\":[1,2],\"99\":[null,null,1],\"100\":[null,null,3],\"101\":[1],\"102\":[null,null,1],\"103\":[null,null,2],\"104\":[1],\"105\":[null,null,1],\"106\":[null,null,2],\"107\":[1],\"108\":[null,null,1],\"109\":[null,null,2],\"110\":[1],\"111\":[null,null,1],\"112\":[null,null,2],\"113\":[1,10],\"114\":[1,9],\"115\":[1,46],\"116\":[1,36],\"117\":[null,null,1],\"118\":[null,null,2],\"119\":[1,31],\"120\":[null,null,1],\"121\":[null,null,4],\"122\":[1],\"123\":[1,11],\"124\":[1,52],\"125\":[null,null,1],\"126\":[null,null,2],\"127\":[1,36],\"128\":[1,63],\"129\":[null,null,1],\"130\":[null,null,2],\"131\":[1],\"132\":[null,null,1],\"133\":[null,null,2],\"134\":[1],\"135\":[null,null,1],\"136\":[null,null,2],\"137\":[1,88],\"138\":[null,null,1],\"139\":[null,null,2],\"140\":[1,6],\"141\":[1,7],\"142\":[1,7],\"143\":[1,58],\"144\":[null,null,1],\"145\":[null,null,2],\"146\":[1,8],\"147\":[null,null,1],\"148\":[null,null,2],\"149\":[1],\"150\":[null,null,1],\"151\":[null,null,2],\"152\":[1],\"153\":[null,null,1],\"154\":[null,null,2],\"155\":[1,8],\"156\":[1,11],\"157\":[1,28],\"158\":[1,7],\"159\":[1,44],\"160\":[null,null,1],\"161\":[null,null,2],\"162\":[1,1],\"163\":[null,null,1],\"164\":[null,null,2],\"165\":[1],\"166\":[null,null,1],\"167\":[null,null,2],\"168\":[1],\"169\":[null,null,1],\"170\":[null,null,2],\"171\":[1],\"172\":[null,null,1],\"173\":[null,null,2],\"174\":[1],\"175\":[null,null,1],\"176\":[null,null,2],\"177\":[1,44],\"178\":[null,null,1],\"179\":[null,null,2],\"180\":[1],\"181\":[1,37],\"182\":[1,70],\"183\":[1,25],\"184\":[null,null,1],\"185\":[null,null,2],\"186\":[2],\"187\":[1],\"188\":[4],\"189\":[1],\"190\":[1],\"191\":[1],\"192\":[1],\"193\":[1],\"194\":[1],\"195\":[1],\"196\":[1],\"197\":[1],\"198\":[1],\"199\":[1]},\"averageFieldLength\":[1.1270761211731002,15.940428107887323,1.2377409852015382],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"这是我的个人简历\"]},\"1\":{\"h\":\"个人信息\",\"t\":[\"姓名: 苏文广 性别: 男 出生年月: 1996-12 大学: 韩山师范学院-软件工程专业(2015.9~2019.6/全日制统招本科) 手机号: 18320664028 邮箱: suveng@163.com\"]},\"2\":{\"h\":\"开发技能\",\"t\":[\"4年工作经验\",\"熟悉 Java 语言, IO,反射,SPI,jvm, java agent\",\"精通业务关系建模;能够独立设计大型复杂系统, 绘制系统架构图, UML 设计图, 精通 OKR 工作法\",\"精通 MySQL,掌握复杂 SQL 查询, 熟悉读写分离策略,主从复制策略, 熟悉常见 MySQL HA 代理方案, 熟练使用 sharding-sphere 对 MySQL 分库分表, 了解 ACID 实现原理,了解 MVCC 实现原理, 了解索引实现机制, 了解 XA 分布式事务管理\",\"熟悉 Linux 系统, 熟悉线上运维命令, 熟练 shell 脚本\",\"熟悉 Spring 全家桶, 熟悉 SpringCloud 微服务分布式架构实现,SpringBlade 脚手架\",\"掌握分布式存储设计; 熟悉 Hadoop 存储系统, 熟悉 HBase 数仓\",\"掌握分布式缓存设计; 掌握基于 Redis 的分布式缓存策略;\",\"掌握分布式调度设计; 熟练使用常见的分布式调度平台, xxl-job, schedulex\",\"掌握常见分布式事务设计, TCC 策略, Seata 架构\",\"掌握数据仓库设计, 熟练编写 Clickhouse sql 离线计算任务, Flink sql 实时计算任务\",\"掌握常见监控告警设计,熟练使用 Prometheus 系统生态\",\"了解 Vue,React 框架, 编写过数据大屏以及后台管理界面\"]},\"3\":{\"c\":[\"博主\"]},\"4\":{\"c\":[\"博主\"]},\"5\":{\"h\":\"MySQL同步数据ES\",\"t\":[\"同步双写\",\"异步双写\",\"定时任务\",\"数据订阅\"]},\"6\":{\"h\":\"同步双写\"},\"7\":{\"h\":\"优点\",\"t\":[\"简单\",\"仅需要在需要同步数据的逻辑上增加往ElasticSearch写\",\"保证实时性\"]},\"8\":{\"h\":\"缺点\",\"t\":[\"商品业务和搜索业务强耦合\",\"扩展性差\",\"需要定制搜索需求需求时, 还需要改动商品代码\",\"ElasticSearch 和 MySQL 需要额外保证一致性\",\"MySQL事务提交之后, 写入ElasticSearch出现网络异常, 那么ElasticSearch和MySQL的数据无法保证一致\"]},\"9\":{\"h\":\"异步双写\",\"t\":[\"与同步双写相比分析优缺点\"]},\"10\":{\"h\":\"优点\",\"t\":[\"解耦合; 商品本身无需关注同步ElasticSearch的逻辑\"]},\"11\":{\"h\":\"缺点\",\"t\":[\"准实时, 存在MQ延迟\",\"需要考虑额外组件的可靠性, Kafka, 搜索服务\"]},\"12\":{\"h\":\"定时任务\"},\"13\":{\"h\":\"优点\",\"t\":[\"简单\"]},\"14\":{\"h\":\"缺点\",\"t\":[\"无法保证实时性\",\"保证实时性主要依赖于搜索服务的定时间隔\"]},\"15\":{\"h\":\"数据订阅\"},\"16\":{\"h\":\"优点\",\"t\":[\"解耦合\",\"利用canal订阅MySQL的binlog做到解耦合\",\"无业务侵入\",\"利用canal组件即可无需在商品代码上做改动\",\"准实时\",\"只存在binlog和业务回查的延迟\",\"良好的扩展行\",\"canal组件还支持各种数据库/客户端的写入适配器, 可以实现不同的数据写入需求, 例如 HBase\"]},\"17\":{\"c\":[\"ElasticSearch\"]},\"18\":{\"c\":[\"ElasticSearch\",\"MySQL\",\"Java\",\"方案\"]},\"19\":{\"h\":\"MySQL主从复制\"},\"20\":{\"c\":[\"MySQL\"]},\"21\":{\"c\":[\"MySQL\",\"Java\"]},\"22\":{\"h\":\"MySQL事务\"},\"23\":{\"c\":[\"MySQL\"]},\"24\":{\"c\":[\"MySQL\",\"Java\"]},\"25\":{\"h\":\"MySQL分库分表\"},\"26\":{\"c\":[\"MySQL\"]},\"27\":{\"c\":[\"MySQL\",\"Java\"]},\"28\":{\"h\":\"MySQL慢查询优化\"},\"29\":{\"h\":\"优化原则\",\"t\":[\"最左前缀匹配原则\",\"选择区分度高的列作为索引\",\"索引列不参与计算\",\"尽量扩展索引\"]},\"30\":{\"h\":\"排查慢查询过程\",\"t\":[\"找到耗时较长的SQL语句\",\"使用explain语句解析SQL执行计划\",\"排查执行计划中是否有全表扫描的情况\",\"排查执行计划中扫描行数较多的查询语句\",\"制定方案优化SQL\",\"如果实在无法优化, 看看是否折中的方案实现业务\"]},\"31\":{\"c\":[\"MySQL\"]},\"32\":{\"c\":[\"MySQL\",\"Java\"]},\"33\":{\"h\":\"MySQL的SQL执行过程\",\"t\":[\"这是MySQL架构组件执行流程, 最后交给存储引擎执行SQL;\",\"InnoDB存储引擎执行过程\",\"这是InnoDB的写入操作流程 其中 redo log 时 InnoDB 特有的组件 binlog 时 MySQL 本身的组件\",\"redo log 的 作用\",\"实现持久性和一致性\",\"由于数据的更新操作都是在内存发生的, 那么如果断电后, 如何保证内存的数据和磁盘的数据一致性, 那么redo log 的作用就是用来保证磁盘和内存数据的一致性;\\n假设数据在提交事务后, redo log 只存在内存, 还没有落入磁盘中, 这个时候发生了断电, 磁盘的数据是落后于内存的数据的, 那么断电恢复后, InnoDB会从redo log 中恢复BufferPool的环境, 这个时候再将差异的数据写入磁盘中, 保证了持久性和一致性\"]},\"34\":{\"c\":[\"MySQL\"]},\"35\":{\"c\":[\"MySQL\",\"Java\"]},\"36\":{\"h\":\"MySQL的语法解析器\",\"t\":[\"SQL本身是一种程序语言, 语言最终会被编译成指令在程序中运行;\",\"那么语言本身是可以被解析, 对应的解析器有哪些实现\",\"MySQL源码的解析器\",\"由专门的公司维护 SQL Parser, https://www.sqlparser.com/\",\"开源的SQL解析器\",\"美团开源的SQL Advisor https://github.com/Meituan-Dianping/SQLAdvisor\"]},\"37\":{\"h\":\"语法解析器应用场景\",\"t\":[\"SQL分析监控\"]},\"38\":{\"h\":\"语法解析原理\",\"t\":[\"构建语法树\"]},\"39\":{\"c\":[\"MySQL\"]},\"40\":{\"c\":[\"MySQL\",\"Java\"]},\"41\":{\"h\":\"MySQL索引B+树高度计算\",\"t\":[\"总记录数 N\",\"记录大小 k Byte\",\"索引大小 x Byte\",\"数据库指针大小 6 Byte\",\"数据库页大小 16KB\",\"从底往上计算高度\",\"叶子节点存放数据\",\"一个叶子节点存放数据量 c = 16 * 1024 / k\",\"一个非叶子节点存放叶子节点数量 b = 16 * 1024 / (x + 6)\",\"总页数 p = N / c\",\"索引的高度 h = log(p,b)\",\"树高 = h + 1\"]},\"42\":{\"h\":\"例子计算\",\"t\":[\"总记录N = 20,000,000\",\"记录大小k = 1024\",\"索引大小x = 8\",\"总页数p = 1250000\",\"索引数b = 1170\",\"索引树高log(p,b) = 2\",\"树高 = 3\",\"总结, 2千万的数据,B+树的高度为3\"]},\"43\":{\"c\":[\"MySQL\"]},\"44\":{\"c\":[\"MySQL\",\"Java\"]},\"45\":{\"h\":\"数组\",\"t\":[\"数组是一种线性数据结构，它由一组连续的内存空间组成，用于存储同一类型的数据元素。\"]},\"46\":{\"h\":\"数组的主要优点包括：\"},\"47\":{\"h\":\"1. 直接访问\",\"t\":[\"可以通过索引直接访问数组中的元素，时间复杂度为O(1)。\"]},\"48\":{\"h\":\"2. 灵活操作\",\"t\":[\"可以通过索引对数组中的元素进行增加、删除、修改等操作。\"]},\"49\":{\"h\":\"3. 空间有效利用\",\"t\":[\"在创建数组时，会预分配足够的内存空间用于存储元素，可以有效利用内存空间。\"]},\"50\":{\"h\":\"数组的主要缺点包括：\"},\"51\":{\"h\":\"1. 大小固定\",\"t\":[\"数组的大小在创建时就需要确定，并且不能动态改变，如果需要存储更多的元素，需要重新创建一个更大的数组。\"]},\"52\":{\"h\":\"2. 无法插入中间元素\",\"t\":[\"如果需要在数组的中间插入元素，需要将后面的元素都向后移动一位，时间复杂度为O(n)。\"]},\"53\":{\"h\":\"3. 无法删除中间元素\",\"t\":[\"如果需要删除数组中的中间元素，需要将后面的元素都向前移动一位，时间复杂度为O(n)。\"]},\"54\":{\"h\":\"总结\",\"t\":[\"综上所述，数组适用于元素数量固定且需要直接访问的场景，但是不适用于需要动态增加或删除元素的场景。\"]},\"55\":{\"c\":[\"数据结构\"]},\"56\":{\"c\":[\"数据结构\",\"数组\"]},\"57\":{\"h\":\"高并发设计\"},\"58\":{\"h\":\"高并发定义\",\"t\":[\"高并发是指在一定时间内，大量的请求同时访问应用程序或系统，导致系统出现性能瓶颈，如响应时间变慢、服务不可用等问题。\",\"高并发通常出现在促销活动、秒杀场景、网站流量高峰期等情况下。\"]},\"59\":{\"h\":\"衡量高并发的指标\",\"t\":[\"响应时间(RT)\",\"并发数(QPS)\",\"请求成功率(成功数/总数)\",\"资源利用率 \",\"CPU\",\"内存\",\"IO\",\"JVM GC\"]},\"60\":{\"h\":\"影响并发的因素\",\"t\":[\"硬件 \",\"CPU\",\"内存\",\"磁盘\",\"软件架构 \",\"单体架构\",\"分布式架构\",\"数据库 \",\"MySQL\",\"Redis\",\"网络 \",\"带宽, 上行速率/下行速率\",\"程序代码\"]},\"61\":{\"h\":\"高并发设计\",\"t\":[\"如果设计一个高并发的系统, 考虑的因素比较多, 这里用控制变量法去控制其他因素保持不变, 只看程序代码的方式, 设计一个高并发的程序\",\"硬件固定\",\"4c8G的硬件\",\"软件架构固定\",\"使用单体架构, 测试单体的并发性能可以粗略估算水平扩容的分布式架构的性能; 当然, 具体分布式架构下的并发性能还是需要测试, 但是这里为了测试方便才使用单体架构\",\"数据库固定\",\"固定使用MySQL和Redis\",\"网络固定\",\"本地网络, 家庭网络的路由大概是千兆网, 这里网络不会成为卡点\",\"编程语言固定\",\"Java\",\"改变程序代码(库存接口)\",\"仅使用MySQL 无缓存 (MySQL的缓存忽略不计)\",\"MySQL + Redis 2级缓存\",\"MySQL + Redis + 内存 3级缓存\",\"以上三种迭代的方式, 测试并发性能\"]},\"62\":{\"h\":\"测试无缓存\"},\"63\":{\"h\":\"测试2级缓存\"},\"64\":{\"h\":\"测试3级缓存\"},\"65\":{\"c\":[\"架构\"]},\"66\":{\"c\":[\"架构\",\"并发\"]},\"67\":{\"h\":\"电商业务流程时序\"},\"68\":{\"c\":[\"电商\"]},\"69\":{\"c\":[\"电商\"]},\"70\":{\"h\":\"电商售后设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"71\":{\"c\":[\"电商\"]},\"72\":{\"c\":[\"电商\",\"方案\",\"Java\"]},\"73\":{\"h\":\"电商商品设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"74\":{\"h\":\"商品的职责有哪些?\",\"t\":[\"商品来源 \",\"企业生产(自产自销) : 一般是有自己的供应链,公司内部记录和管理\",\"企业采购(B2B) : 从外部企业渠道采购到公司内部, 并由公司内部记录和管理\",\"企业回收(C2B) : 从个人手中回收商品, 并有公司内部记录和管理\",\"商品规格\",\"商品描述\",\"商品定价\"]},\"75\":{\"h\":\"商品上下游模块依赖\",\"t\":[\"供应链模块(商品来源)\",\"订单模块(商品售卖)\",\"物流模块(商品物流)\"]},\"76\":{\"h\":\"商品核心功能\",\"t\":[\"录入商品\",\"搜索商品列表\",\"查询商品详情\",\"更新库存\"]},\"77\":{\"h\":\"商品模型\"},\"78\":{\"h\":\"搜索商品列表高性能低延时方案\",\"t\":[\"使用ElasticSearch作为搜索引擎\",\"搜索相关度排序\",\"商品类目\",\"商品标签\",\"商品标题\",\"商品副标题\",\"商品描述\",\"规格描述\",\"热卖商品\"]},\"79\":{\"h\":\"ES数据映射\",\"t\":[\"ES需要对以下数据做映射\",\"商品 \",\"商品类目\",\"商品标签\",\"商品规格\",\"订单\"]},\"80\":{\"h\":\"ES数据同步方案\",\"t\":[\"MySQL同步数据ES.md\",\"通过上面文章的方案比较, 最终选用数据订阅方式,进行ES数据同步\"]},\"81\":{\"c\":[\"电商\"]},\"82\":{\"c\":[\"电商\",\"Java\",\"方案\"]},\"83\":{\"h\":\"电商搜索设计方案\",\"t\":[\"电商业务流程时序.md\",\"https://zq99299.github.io/note-book/back-end-storage/\"]},\"84\":{\"c\":[\"电商\"]},\"85\":{\"c\":[\"电商\",\"Java\",\"方案\"]},\"86\":{\"h\":\"电商支付设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"87\":{\"c\":[\"电商\"]},\"88\":{\"c\":[\"电商\",\"Java\",\"方案\"]},\"89\":{\"h\":\"电商订单设计方案\",\"t\":[\"电商业务流程时序.md\"]},\"90\":{\"h\":\"电商订单的职责\",\"t\":[\"电商订单是记录电商平台上的交易信息的重要数据实体，包括订单号、商品信息、收货地址、支付信息等。\",\"电商订单具有以下职责： \",\"记录并管理交易信息：电商订单负责记录和管理商品信息、支付信息、物流信息等交易相关数据。\",\"控制交易流程：电商订单可以根据订单状态控制交易流程，如待支付、已支付、待发货、已发货、已完成等。\",\"支持订单查询和统计：电商订单可以提供订单查询和统计功能，以便用户和商家进行订单管理、交易分析等操作。\",\"支持订单修改和取消：电商订单可以支持用户和商家对订单进行修改和取消操作，以满足不同业务场景的需求。\",\"保证订单安全和隐私：电商订单需要采取相应的安全措施，确保订单信息的安全性和隐私性。\",\"电商订单的实现可以采用数据库存储、API接口调用等方式，具体的实现方式根据业务需求和系统架构进行选择。\"]},\"91\":{\"h\":\"核心API\",\"t\":[\"生成订单id();\",\"创建订单();\",\"取消订单();\",\"支付订单();\",\"发货();\",\"签收();\",\"评价();\",\"完成();\"]},\"92\":{\"h\":\"订单状态机设计\"},\"93\":{\"h\":\"注意的场景\"},\"94\":{\"h\":\"如何避免重复下单?\",\"t\":[\"首先,生成订单ID; 然后,使用订单ID作为幂等标识下单;\"]},\"95\":{\"h\":\"如何解决ABA问题? (网络异常情况下, 请求顺序不一致导致数据错乱)\",\"t\":[\"版本号的乐观锁机制\",\"查询接口将版本返回给调用方\",\"调用方将版本号作为参数给接口, 当版本一致的时候更新数据, 不一致不更新, 提示用户刷新页面\"]},\"96\":{\"c\":[\"电商\"]},\"97\":{\"c\":[\"电商\",\"Java\",\"方案\"]},\"98\":{\"h\":\"电商购物车方案\",\"t\":[\"电商业务流程时序.md\"]},\"99\":{\"c\":[\"电商\"]},\"100\":{\"c\":[\"电商\",\"Java\",\"方案\"]},\"101\":{\"h\":\"Gossip一致性算法\"},\"102\":{\"c\":[\"算法\"]},\"103\":{\"c\":[\"算法\",\"一致性\"]},\"104\":{\"h\":\"Paxos一致性算法\"},\"105\":{\"c\":[\"算法\"]},\"106\":{\"c\":[\"算法\",\"一致性\"]},\"107\":{\"h\":\"Raft一致性算法\"},\"108\":{\"c\":[\"算法\"]},\"109\":{\"c\":[\"算法\",\"一致性\"]},\"110\":{\"h\":\"ZAB一致性算法\"},\"111\":{\"c\":[\"算法\"]},\"112\":{\"c\":[\"算法\",\"一致性\"]},\"113\":{\"h\":\"冒泡排序\",\"t\":[\"冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\"]},\"114\":{\"h\":\"算法描述\",\"t\":[\"从数列中挑出最小（大）元素，依次放到数列的起始位置；\",\"再从剩下的元素中挑出最小（大）元素，放到已排序序列的末尾；\",\"重复步骤2，直到所有元素排序完成。\"]},\"115\":{\"h\":\"示例\",\"t\":[\"对数列 {5, 3, 8, 6, 4} 进行冒泡排序：\",\"第一轮：\",\"比较5和3，发现5>3，交换位置，数列变成 {3, 5, 8, 6, 4}；\",\"比较5和8，发现5<8，位置不变，数列还是 {3, 5, 8, 6, 4}；\",\"比较8和6，发现8>6，交换位置，数列变成 {3, 5, 6, 8, 4}；\",\"比较8和4，发现8>4，交换位置，数列变成 {3, 5, 6, 4, 8}； 第一轮结束，此时最大元素8已经排好序，接下来对剩下的数列 {3, 5, 6, 4} 进行冒泡排序。\",\"第二轮：\",\"比较3和5，发现3<5，位置不变，数列还是 {3, 5, 6, 4}；\",\"比较5和6，发现5<6，位置不变，数列还是 {3, 5, 6, 4}；\",\"比较6和4，发现6>4，交换位置，数列变成 {3, 5, 4, 6}； 第二轮结束，此时次大元素6已经排好序，剩下的数列 {3, 5, 4} 继续冒泡排序。\",\"第三轮：\",\"比较3和5，发现3<5，位置不变，数列还是 {3, 5, 4}；\",\"比较5和4，发现5>4，交换位置，数列变成 {3, 4, 5}； 第三轮结束，此时第三大元素5已经排好序，剩下的数列 {3, 4} 继续冒泡排序。\",\"第四轮：\",\"比较3和4，发现3<4，位置不变，数列还是 {3, 4}； 第四轮结束，此时最小元素3已经排好序，整个数列排序完成。\"]},\"116\":{\"h\":\"复杂度分析\",\"t\":[\"最好情况：当数组已经按照排序需求排好时，只需进行一次遍历，时间复杂度为O(n)；\",\"最坏情况：当数组是逆序排列时，需要进行n-1次遍历，时间复杂度为O(n^2)；\",\"平均情况：需要进行n-1次遍历，时间复杂度为O(n^2)。\",\"冒泡排序是一种稳定的排序算法。\",\"public class bubbleSort { public static void bubbleSort(int[] arr) { int n = arr.length; for (int i = 0; i < n-1; i++) { for (int j = 0; j < n-i-1; j++) { if (arr[j] > arr[j+1]) { // 交换arr[j]和arr[j+1] int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } } } \"]},\"117\":{\"c\":[\"算法\"]},\"118\":{\"c\":[\"算法\",\"排序\"]},\"119\":{\"h\":\"双指针\",\"t\":[\"双指针算法（Two-Pointers Algorithm）是一种常见的算法思想，通常用于解决数组或链表相关的问题。该算法通过使用两个指针，分别从数组或链表的两端向中间移动，从而解决问题。 双指针算法通常可以分为两种情况：\",\"从数组的两端向中间移动的双指针算法： 这种情况下，我们通常使用两个指针从数组的两端同时开始遍历，然后根据具体的问题来决定两个指针的移动方式。这种算法通常用于解决一些查找或筛选的问题，例如查找两个数的和等于目标值、查找数组中的环形子数组等。\",\"从数组的一端向另一端移动的双指针算法： 这种情况下，我们通常使用两个指针，一个指向数组的起始位置，另一个从起始位置开始向后遍历。这种算法通常用于解决一些排序或统计的问题，例如验证只包含相同字符的最长子串、统计数组中元素出现次数等。\",\"使用双指针算法可以有效地提高解决数组或链表相关问题的效率，因为双指针同时进行遍历，可以将时间复杂度从O(n^2)降低到O(n)。\"]},\"120\":{\"c\":[\"算法\"]},\"121\":{\"c\":[\"算法\",\"双指针\",\"数组\",\"链表\"]},\"122\":{\"h\":\"基数排序\"},\"123\":{\"h\":\"基本原理\",\"t\":[\"基数排序是一种非比较性的排序算法。基数排序的基本思想是：将整数按位数划分为不同的桶，然后按每个位数分别对桶中的元素进行排序，最终将所有位数上的排序结果合并在一起，得到最终的排序结果。\",\"基数排序的时间复杂度为O(dn)，其中d是数字的最大位数，n是待排序元素个数。\"]},\"124\":{\"h\":\"实现步骤\",\"t\":[\"基数排序的实现步骤如下：\",\"获取待排序数组中的最大值，确定最大位数d。\",\"对最末位进行排序，使用计数排序算法对每个数字出现的次数进行统计。\",\"基于计数排序的结果，依次确定每个数字在有序数组中的位置。\",\"将有序数组重新赋值给原数组。\",\"依次对每一位进行排序，直到最高位。\",\"public class radixSort { public static void radixSort(int[] arr) { if (arr == null || arr.length <= 1) { return; } // 获取最大值的位数 int maxNum = arr[0]; for (int i = 1; i < arr.length; i++) { if (arr[i] > maxNum) { maxNum = arr[i]; } } int placeValue = 1; // 当前位的权值 while (maxNum / placeValue > 0) { countingSort(arr, placeValue); placeValue *= 10; } } private static void countingSort(int[] arr, int placeValue) { int[] count = new int[10]; int radix = 10; for (int i = 0; i < arr.length; i++) { int digit = (arr[i] / radix) % 10; count[digit]++; } for (int i = 1; i < count.length; i++) { count[i] += count[i - 1]; } int[] output = new int[arr.length]; for (int i = arr.length - 1; i >= 0; i--) { int digit = (arr[i] / radix) % 10; int index = count[digit] - 1; output[index] = arr[i]; count[digit]--; } System.arraycopy(output, 0, arr, 0, arr.length); } } \"]},\"125\":{\"c\":[\"算法\"]},\"126\":{\"c\":[\"算法\",\"排序\"]},\"127\":{\"h\":\"堆排序\",\"t\":[\"堆排序（Heap Sort）是利用堆（Heap）这种数据结构进行选择排序的一种算法。堆是一个可以推导具有最大或最小值的树形结构，堆排序利用堆的特性进行排序。\",\"堆排序分为两个步骤：\",\"建堆（Build Heap）：将一个无序的数组构建成一个大顶堆（Max Heap）。大顶堆的特点是父节点的值大于或等于其子节点的值。建堆的过程从数组的最后一个非叶子节点开始，依次向上调整每个节点，使其满足大顶堆的特性。\",\"排序（Sort）：重复执行以下步骤，直到堆的大小为1：\",\"将堆中的最大元素（根节点）与堆的最后一个元素交换。\",\"将堆的大小减1。\",\"对堆进行调整，使其重新成为一个大顶堆。\",\"重复上述步骤，每次取出的都是当前堆中的最大元素，最终得到的数组就是一个有序的数组。\",\"堆排序的时间复杂度为O(nlogn)，空间复杂度为O(1)。由于堆排序是一种不稳定的排序算法，因此在需要保持相同元素的原始顺序时应谨慎使用。\",\"以下是堆排序的示例代码：\"]},\"128\":{\"h\":\"Java实现\",\"t\":[\"public class HeapSort { public static void sort(int[] arr) { int n = arr.length; // 构建大顶堆 for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i); // 排序 for (int i = n - 1; i >= 0; i--) { // 将当前堆中的最大元素与堆的最后一个元素交换 swap(arr, 0, i); // 对交换后的元素进行调整，重新成为一个大顶堆 heapify(arr, i, 0); } } // 调整堆，使其重新成为一个大顶堆 static void heapify(int[] arr, int n, int i) { int largest = i; // 初始化largest为当前节点 int left = 2 * i + 1; // 左子节点 int right = 2 * i + 2; // 右子节点 // 如果左子节点比当前节点大，则更新largest为左子节点 if (left < n && arr[left] > arr[largest]) largest = left; // 如果右子节点比当前节点大，则更新largest为右子节点 if (right < n && arr[right] > arr[largest]) largest = right; // 如果largest不是当前节点，则将largest与当前节点交换，并递归调整堆 if (largest != i) { swap(arr, i, largest); heapify(arr, n, largest); } } // 交换数组中的两个元素 static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } // 测试 public static void main(String[] args) { int[] arr = { 12, 11, 13, 5, 6, 7 }; sort(arr); System.out.println(\\\"排序后的数组：\\\"); for (int num : arr) System.out.print(num + \\\" \\\"); } } \"]},\"129\":{\"c\":[\"算法\"]},\"130\":{\"c\":[\"算法\",\"排序\"]},\"131\":{\"h\":\"希尔排序\"},\"132\":{\"c\":[\"算法\"]},\"133\":{\"c\":[\"算法\",\"排序\"]},\"134\":{\"h\":\"归并排序\"},\"135\":{\"c\":[\"算法\"]},\"136\":{\"c\":[\"算法\",\"排序\"]},\"137\":{\"h\":\"快速排序\",\"t\":[\"快速排序是一种常用的排序算法，采用分治法（Divide and Conquer）的思想。它的基本步骤如下：\",\"从数列中挑出一个元素，称为“基准”（pivot）。\",\"将所有比基准值小的元素都放在基准前面，比基准值大的元素都放在基准的后面（相同的数可以放在任一边）。在这个分区退出之后，该基准就处于数列的中间位置。\",\"对基准的左右两个分区重复步骤1和步骤2。 快速排序的关键步骤是基准的选取，不同的选取方法会影响排序的效率。通常有以下几种选取方法： \",\"选取第一个元素作为基准\",\"选取最后一个元素作为基准\",\"选取中间元素作为基准\",\"从数列中随机选取一个元素作为基准\",\"快速排序的时间复杂度为O(nlogn)，但在最坏情况下时间复杂度为O(n^2)。为了避免最坏情况的发生，可以采用随机选取基准、三数中值法选取基准等优化方法。\",\"public class QuickSort { /* * 快速排序 * * 参数说明： * a -- 待排序的数组 * l -- 数组的左边界(例如，从起始位置开始排序，则l=0) * r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1) */ public static void quickSort(int[] a, int l, int r) { if (l < r) { int i,j,x; i = l; j = r; x = a[i]; while (i < j) { while(i < j && a[j] > x) j--; // 从右向左找第一个小于x的数 if(i < j) a[i++] = a[j]; while(i < j && a[i] < x) i++; // 从左向右找第一个大于x的数 if(i < j) a[j--] = a[i]; } a[i] = x; quickSort(a, l, i-1); /* 递归调用 */ quickSort(a, i+1, r); /* 递归调用 */ } } public static void main(String[] args) { int i; int a[] = {30,40,60,10,20,50}; System.out.printf(\\\"before sort:\\\"); for (i=0; i<a.length; i++) System.out.printf(\\\"%d \\\", a[i]); System.out.printf(\\\"\\\\n\\\"); quickSort(a, 0, a.length-1); System.out.printf(\\\"after sort:\\\"); for (i=0; i<a.length; i++) System.out.printf(\\\"%d \\\", a[i]); System.out.printf(\\\"\\\\n\\\"); } } \"]},\"138\":{\"c\":[\"算法\"]},\"139\":{\"c\":[\"算法\",\"排序\"]},\"140\":{\"h\":\"插入排序\",\"t\":[\"插入排序是一种简单直观的排序算法。它的基本思想是通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\"]},\"141\":{\"h\":\"时间复杂度\",\"t\":[\"在最坏的情况下，插入排序需要O(n^2)的时间复杂度和O(1)的空间复杂度。\"]},\"142\":{\"h\":\"空间复杂度\",\"t\":[\"在最好情况下，插入排序需要O(n)的时间复杂度和O(1)的空间复杂度。\"]},\"143\":{\"h\":\"Java代码实现\",\"t\":[\"/** * 插入排序(Insertion Sort)是一种简单直观的排序算法。 * 插入排序的工作原理是：通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 * * 在最好情况下，插入排序的效率为O(n)，对应的序列是已排序的； * 在最坏情况下，插入排序的时间复杂度为O(n^2)，对应的序列是逆序的。 * * 代码的执行步骤： * 1. 从第一个元素开始，该元素可以认为已经被排序； * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描； * 3. 如果该元素（已排序）大于新元素，将该元素移动到下一位置； * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； * 5. 将新元素插入到该位置后； * 6. 重复步骤2~5。 */ public class InsertionSort { public static void sort(int[] array) { int n = array.length; for (int i = 1; i < n; i++) { int key = array[i]; int j = i - 1; while (j >= 0 && array[j] > key) { array[j + 1] = array[j]; j--; } array[j + 1] = key; } } } \"]},\"144\":{\"c\":[\"算法\"]},\"145\":{\"c\":[\"算法\",\"排序\"]},\"146\":{\"h\":\"斐波那契数列问题\",\"t\":[\"数学公式如下:\",\"f(n)=⎩⎨⎧​01f(n−1)+f(n−2)​n=0n=1n>=1​​​\"]},\"147\":{\"c\":[\"算法\"]},\"148\":{\"c\":[\"算法\",\"斐波那契数列\"]},\"149\":{\"h\":\"桶排序\"},\"150\":{\"c\":[\"算法\"]},\"151\":{\"c\":[\"算法\",\"排序\"]},\"152\":{\"h\":\"计数排序\"},\"153\":{\"c\":[\"算法\"]},\"154\":{\"c\":[\"算法\",\"排序\"]},\"155\":{\"h\":\"选择排序\",\"t\":[\"选择排序是一种简单直观的排序算法。它的基本思想是：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\"]},\"156\":{\"h\":\"步骤\",\"t\":[\"选择排序的算法步骤如下：\",\"在待排序的元素中，找到最小（大）的元素，将其与第一个元素交换位置。\",\"在剩下的元素中，找到最小（大）的元素，将其与第二个元素交换位置。\",\"重复上述步骤，直到所有元素均排序完毕。\"]},\"157\":{\"h\":\"示例\",\"t\":[\"给定数组 [3, 4, 2, 1, 5]，按升序排序。\",\"第一次遍历，找到最小元素 1，与第一个元素 3 交换位置，数组变为 [1, 4, 2, 3, 5]。\",\"第二次遍历，忽略第一个元素，找到最小元素 2，与第二个元素 4 交换位置，数组变为 [1, 2, 4, 3, 5]。\",\"第三次遍历，忽略前两个元素，找到最小元素 3，与第三个元素 4 交换位置，数组变为 [1, 2, 3, 4, 5]。\",\"第四次遍历，忽略前三个元素，找到最小元素 4，与第四个元素 4 交换位置，数组保持不变 [1, 2, 3, 4, 5]。\",\"第五次遍历，忽略前四个元素，找到最小元素 5，与第五个元素 5 交换位置，数组保持不变 [1, 2, 3, 4, 5]。\",\"最终得到的数组为 [1, 2, 3, 4, 5]，即为按升序排序后的结果。\"]},\"158\":{\"h\":\"时间复杂度\",\"t\":[\"选择排序的时间复杂度为 O(n^2)，其中 n 是待排序数组的长度。\"]},\"159\":{\"h\":\"代码实现\",\"t\":[\"下面是使用 Java 实现选择排序的示例代码：\",\"public class SelectionSort { public static void main(String[] args) { int[] arr = {3, 4, 2, 1, 5}; selectionSort(arr); System.out.println(Arrays.toString(arr)); // 输出：[1, 2, 3, 4, 5] } public static void selectionSort(int[] arr) { int n = arr.length; // 遍历数组 for (int i = 0; i < n-1; i++) { int minIndex = i; // 寻找最小元素的索引 for (int j = i+1; j < n; j++) { if (arr[j] < arr[minIndex]) { minIndex = j; } } // 交换最小元素与当前元素的位置 int temp = arr[minIndex]; arr[minIndex] = arr[i]; arr[i] = temp; } } } \",\"以上代码实现了选择排序的排序算法和排序结果的输出。\"]},\"160\":{\"c\":[\"算法\"]},\"161\":{\"c\":[\"算法\",\"排序\"]},\"162\":{\"h\":\"记录搭建VuePress博客\",\"t\":[\"VuePress\"]},\"163\":{\"c\":[\"博客\"]},\"164\":{\"c\":[\"VuePress\",\"博客\"]},\"165\":{\"h\":\"\"},\"166\":{\"c\":[\"Java\"]},\"167\":{\"c\":[\"Java\",\"锁\"]},\"168\":{\"h\":\"\"},\"169\":{\"c\":[\"Java\"]},\"170\":{\"c\":[\"Java\",\"锁\"]},\"171\":{\"h\":\"\"},\"172\":{\"c\":[\"Java\"]},\"173\":{\"c\":[\"Java\",\"锁\"]},\"174\":{\"h\":\"\"},\"175\":{\"c\":[\"Java\"]},\"176\":{\"c\":[\"Java\",\"锁\"]},\"177\":{\"h\":\"线程\",\"t\":[\"Java的线程是程序执行的最小单位，是操作系统进行调度的基本单元。Java中的线程由Thread类和Runnable接口实现。Thread类是一个实现了Runnable接口的类，它包含线程的控制方法和线程的生命周期方法。Runnable接口定义了一个run()方法，该方法包含线程要执行的代码。\",\"Java中的线程有以下几种状态：\",\"初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。\",\"运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。\",\"阻塞(BLOCKED)：表示线程阻塞于锁。\",\"等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。\",\"超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。\",\"终止(TERMINATED)：表示该线程已经执行完毕。\"]},\"178\":{\"c\":[\"Java\"]},\"179\":{\"c\":[\"Java\",\"并发\"]},\"180\":{\"h\":\"线程池\"},\"181\":{\"h\":\"线程池设计思想\",\"t\":[\"Java线程池的设计思想是为了提高线程的使用效率和响应能力，以及降低资源消耗和线程管理的复杂度。 Java线程池主要具有以下设计思想：\",\"重复使用线程：Java线程池中的线程可以被重复使用，而不是为每个任务创建一个新的线程。这样可以避免线程的创建和销毁带来的开销，提高程序的性能。\",\"控制资源消耗：Java线程池可以控制线程的数量，从而控制程序对系统资源的消耗。当线程数量过多时，可以避免过多的线程同时占用资源，导致资源浪费和系统负载过高。\",\"提高响应能力：Java线程池可以快速响应任务的提交和执行，从而提高程序的响应能力。当有新的任务提交时，线程池可以立即分配线程执行任务，而不用等待新的线程创建和就绪。\",\"任务执行管理：Java线程池可以对任务的执行进行管理，例如控制任务的执行顺序、限制任务的执行时间、处理任务的异常等。这样可以保证任务的执行质量，并提高程序的可靠性。\",\"Java线程池通过ThreadPoolExecutor类来实现，该类提供了可重用的线程池，并提供了丰富的配置选项，可以根据实际需要来配置线程池的参数，以达到最佳的性能和效果。 Java线程池的设计思想是基于生产者-消费者模式，通过工作线程来执行任务，从而实现高效的并发处理。\"]},\"182\":{\"h\":\"如何停止线程池中的线程\",\"t\":[\"在Java中，线程池中的线程是并发执行的，不支持直接停止某一个线程。但是可以通过以下几种方式中断线程的执行：\",\"使用线程的interrupt方法中断线程\",\"ExecutorService executor = Executors.newFixedThreadPool(5); Future future = executor.submit(() -> { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } }); // 停止某个线程 executor.shutdownNow(); future.cancel(true); \",\"使用线程的interrupted方法检查中断标志位\",\"ExecutorService executor = Executors.newFixedThreadPool(5); Future future = executor.submit(() -> { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } }); // 停止某个线程 executor.shutdownNow(); if (Thread.interrupted()) { // 中断标志位为true表示被中断 // 处理中断逻辑 } \",\"使用线程的isInterrupted方法检查中断状态\",\"ExecutorService executor = Executors.newFixedThreadPool(5); Future future = executor.submit(() -> { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } }); // 停止某个线程 executor.shutdownNow(); if (Thread.interrupted()) { // 中断标志位为true表示被中断 // 处理中断逻辑 Thread.currentThread().interrupt(); } \",\"import java.util.concurrent.*; public class Main { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future<String> future = executor.submit(() -> { try { while (!Thread.currentThread().isInterrupted()) { System.out.println(\\\"Working...\\\"); Thread.sleep(5000); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } return \\\"Done\\\"; }); System.out.println(\\\"Future status: \\\" + future.isDone()); Thread.sleep(3000); System.out.println(\\\"Try to cancel future...\\\"); future.cancel(true); System.out.println(\\\"Future status: \\\" + future.isCancelled()); System.out.println(\\\"Future result: \\\" + future.get()); executor.shutdown(); } } \"]},\"183\":{\"h\":\"线程池的核心参数\",\"t\":[\"线程池的核心参数如下：\",\"corePoolSize：核心线程数，即线程池维护的最低线程数。\",\"maximumPoolSize：最大线程数，即线程池维护的最大线程数。\",\"keepAliveTime：线程空闲 timeout，即线程空闲 timeout 时间。\",\"unit：时间单位。\",\"workQueue：任务队列，用于保存等待线程执行的任务。\",\"threadFactory：线程工厂，用于创建新线程。\",\"handler：拒绝执行策略，当任务队列和线程池都达到最大容量时，将执行任务的续行策略。\"]},\"184\":{\"c\":[\"Java\"]},\"185\":{\"c\":[\"Java\",\"并发\"]},\"186\":{\"h\":\"Elastic Search\"},\"187\":{\"h\":\"Posts\"},\"188\":{\"h\":\"My S Q L\"},\"189\":{\"h\":\"数据结构\"},\"190\":{\"h\":\"架构\"},\"191\":{\"h\":\"电商\"},\"192\":{\"h\":\"简历\"},\"193\":{\"h\":\"算法\"},\"194\":{\"h\":\"记录\"},\"195\":{\"h\":\"Jvm\"},\"196\":{\"h\":\"Java\"},\"197\":{\"h\":\"并发\"},\"198\":{\"h\":\"Spring\"},\"199\":{\"h\":\"Java框架\"}},\"dirtCount\":0,\"index\":[[\"简历\",{\"0\":{\"192\":1}}],[\"简单\",{\"1\":{\"7\":1,\"13\":1}}],[\"拒绝执行策略\",{\"1\":{\"183\":1}}],[\"用于创建新线程\",{\"1\":{\"183\":1}}],[\"用于保存等待线程执行的任务\",{\"1\":{\"183\":1}}],[\"用于存储同一类型的数据元素\",{\"1\":{\"45\":1}}],[\"任务队列\",{\"1\":{\"183\":1}}],[\"任务执行管理\",{\"1\":{\"181\":1}}],[\"即线程空闲\",{\"1\":{\"183\":1}}],[\"即线程池维护的最大线程数\",{\"1\":{\"183\":1}}],[\"即线程池维护的最低线程数\",{\"1\":{\"183\":1}}],[\"即为按升序排序后的结果\",{\"1\":{\"157\":1}}],[\"核心线程数\",{\"1\":{\"183\":1}}],[\"核心api\",{\"0\":{\"91\":1}}],[\"unit\",{\"1\":{\"183\":1}}],[\"util\",{\"1\":{\"182\":1}}],[\"uml\",{\"1\":{\"2\":1}}],[\"处理中断逻辑\",{\"1\":{\"182\":2}}],[\"处理任务的异常等\",{\"1\":{\"181\":1}}],[\"中断标志位为true表示被中断\",{\"1\":{\"182\":2}}],[\"中恢复bufferpool的环境\",{\"1\":{\"33\":1}}],[\"停止某个线程\",{\"1\":{\"182\":3}}],[\"执行任务\",{\"1\":{\"182\":3}}],[\"消费者模式\",{\"1\":{\"181\":1}}],[\"限制任务的执行时间\",{\"1\":{\"181\":1}}],[\"而不用等待新的线程创建和就绪\",{\"1\":{\"181\":1}}],[\"而不是为每个任务创建一个新的线程\",{\"1\":{\"181\":1}}],[\"导致资源浪费和系统负载过高\",{\"1\":{\"181\":1}}],[\"导致系统出现性能瓶颈\",{\"1\":{\"58\":1}}],[\"控制资源消耗\",{\"1\":{\"181\":1}}],[\"控制交易流程\",{\"1\":{\"90\":1}}],[\"提高响应能力\",{\"1\":{\"181\":1}}],[\"提高程序的性能\",{\"1\":{\"181\":1}}],[\"提示用户刷新页面\",{\"1\":{\"95\":1}}],[\"表示该线程已经执行完毕\",{\"1\":{\"177\":1}}],[\"表示线程阻塞于锁\",{\"1\":{\"177\":1}}],[\"终止\",{\"1\":{\"177\":1}}],[\"超时等待\",{\"1\":{\"177\":1}}],[\"进入该状态的线程需要等待其他线程做出一些特定动作\",{\"1\":{\"177\":1}}],[\"进行冒泡排序\",{\"1\":{\"115\":2}}],[\"进行es数据同步\",{\"1\":{\"80\":1}}],[\"等待\",{\"1\":{\"177\":1}}],[\"等待被线程调度选中\",{\"1\":{\"177\":1}}],[\"阻塞\",{\"1\":{\"177\":1}}],[\"就绪状态的线程在获得cpu时间片后变为运行中状态\",{\"1\":{\"177\":1}}],[\"其他线程\",{\"1\":{\"177\":1}}],[\"其中d是数字的最大位数\",{\"1\":{\"123\":1}}],[\"其中\",{\"1\":{\"33\":1,\"158\":1}}],[\"两种状态笼统的称为\",{\"1\":{\"177\":1}}],[\"运行\",{\"1\":{\"177\":2}}],[\"新创建了一个线程对象\",{\"1\":{\"177\":1}}],[\"初始\",{\"1\":{\"177\":1}}],[\"初始化largest为当前节点\",{\"1\":{\"128\":1}}],[\"方法\",{\"1\":{\"177\":3}}],[\"方案\",{\"2\":{\"18\":1,\"72\":1,\"82\":1,\"85\":1,\"88\":1,\"97\":1,\"100\":1}}],[\"线程工厂\",{\"1\":{\"183\":1}}],[\"线程空闲\",{\"1\":{\"183\":1}}],[\"线程池的核心参数如下\",{\"1\":{\"183\":1}}],[\"线程池的核心参数\",{\"0\":{\"183\":1}}],[\"线程池中的线程是并发执行的\",{\"1\":{\"182\":1}}],[\"线程池可以立即分配线程执行任务\",{\"1\":{\"181\":1}}],[\"线程池设计思想\",{\"0\":{\"181\":1}}],[\"线程池\",{\"0\":{\"180\":1}}],[\"线程对象创建后\",{\"1\":{\"177\":1}}],[\"线程\",{\"0\":{\"177\":1}}],[\"锁\",{\"2\":{\"167\":1,\"170\":1,\"173\":1,\"176\":1}}],[\"博客\",{\"2\":{\"163\":1,\"164\":1}}],[\"博主\",{\"2\":{\"3\":1,\"4\":1}}],[\"寻找最小元素的索引\",{\"1\":{\"159\":1}}],[\"遍历数组\",{\"1\":{\"159\":1}}],[\"输出\",{\"1\":{\"159\":1}}],[\"下面是使用\",{\"1\":{\"159\":1}}],[\"下行速率\",{\"1\":{\"60\":1}}],[\"忽略前四个元素\",{\"1\":{\"157\":1}}],[\"忽略前三个元素\",{\"1\":{\"157\":1}}],[\"忽略前两个元素\",{\"1\":{\"157\":1}}],[\"忽略第一个元素\",{\"1\":{\"157\":1}}],[\"按升序排序\",{\"1\":{\"157\":1}}],[\"给定数组\",{\"1\":{\"157\":1}}],[\"步骤\",{\"0\":{\"156\":1}}],[\"或最大\",{\"1\":{\"155\":1}}],[\"每次从待排序的数据元素中选出最小\",{\"1\":{\"155\":1}}],[\"每次取出的都是当前堆中的最大元素\",{\"1\":{\"127\":1}}],[\"计数排序\",{\"0\":{\"152\":1}}],[\"桶排序\",{\"0\":{\"149\":1}}],[\"斐波那契数列\",{\"2\":{\"148\":1}}],[\"斐波那契数列问题\",{\"0\":{\"146\":1}}],[\"​n=0n=1n>=1​​​\",{\"1\":{\"146\":1}}],[\"取出下一个元素\",{\"1\":{\"143\":1}}],[\"取消订单\",{\"1\":{\"91\":1}}],[\"代码实现\",{\"0\":{\"159\":1}}],[\"代码的执行步骤\",{\"1\":{\"143\":1}}],[\"代理方案\",{\"1\":{\"2\":1}}],[\"找到最小元素\",{\"1\":{\"157\":5}}],[\"找到最小\",{\"1\":{\"156\":2}}],[\"找到相应位置并插入\",{\"1\":{\"140\":1,\"143\":1}}],[\"找到耗时较长的sql语句\",{\"1\":{\"30\":1}}],[\"插入排序的时间复杂度为o\",{\"1\":{\"143\":1}}],[\"插入排序的效率为o\",{\"1\":{\"143\":1}}],[\"插入排序的工作原理是\",{\"1\":{\"143\":1}}],[\"插入排序需要o\",{\"1\":{\"141\":1,\"142\":1}}],[\"插入排序是一种简单直观的排序算法\",{\"1\":{\"140\":1}}],[\"插入排序\",{\"0\":{\"140\":1},\"1\":{\"143\":1}}],[\"递归调用\",{\"1\":{\"137\":2}}],[\"待排序的数组\",{\"1\":{\"137\":1}}],[\"待发货\",{\"1\":{\"90\":1}}],[\"参数说明\",{\"1\":{\"137\":1}}],[\"q\",{\"0\":{\"188\":1}}],[\"quicksort\",{\"1\":{\"137\":5}}],[\"qps\",{\"1\":{\"59\":1}}],[\"三数中值法选取基准等优化方法\",{\"1\":{\"137\":1}}],[\"为了避免最坏情况的发生\",{\"1\":{\"137\":1}}],[\"但还没有调用start\",{\"1\":{\"177\":1}}],[\"但在最坏情况下时间复杂度为o\",{\"1\":{\"137\":1}}],[\"但是可以通过以下几种方式中断线程的执行\",{\"1\":{\"182\":1}}],[\"但是这里为了测试方便才使用单体架构\",{\"1\":{\"61\":1}}],[\"但是不适用于需要动态增加或删除元素的场景\",{\"1\":{\"54\":1}}],[\"选择排序的时间复杂度为\",{\"1\":{\"158\":1}}],[\"选择排序的算法步骤如下\",{\"1\":{\"156\":1}}],[\"选择排序是一种简单直观的排序算法\",{\"1\":{\"155\":1}}],[\"选择排序\",{\"0\":{\"155\":1}}],[\"选择区分度高的列作为索引\",{\"1\":{\"29\":1}}],[\"选取中间元素作为基准\",{\"1\":{\"137\":1}}],[\"选取最后一个元素作为基准\",{\"1\":{\"137\":1}}],[\"选取第一个元素作为基准\",{\"1\":{\"137\":1}}],[\"不支持直接停止某一个线程\",{\"1\":{\"182\":1}}],[\"不同的选取方法会影响排序的效率\",{\"1\":{\"137\":1}}],[\"不一致不更新\",{\"1\":{\"95\":1}}],[\"该类提供了可重用的线程池\",{\"1\":{\"181\":1}}],[\"该状态不同于waiting\",{\"1\":{\"177\":1}}],[\"该状态的线程位于可运行线程池中\",{\"1\":{\"177\":1}}],[\"该方法包含线程要执行的代码\",{\"1\":{\"177\":1}}],[\"该元素可以认为已经被排序\",{\"1\":{\"143\":1}}],[\"该基准就处于数列的中间位置\",{\"1\":{\"137\":1}}],[\"该算法通过使用两个指针\",{\"1\":{\"119\":1}}],[\"在java中\",{\"1\":{\"182\":1}}],[\"在剩下的元素中\",{\"1\":{\"156\":1}}],[\"在待排序的元素中\",{\"1\":{\"156\":1}}],[\"在已经排序的元素序列中从后向前扫描\",{\"1\":{\"143\":1}}],[\"在已排序序列中从后向前扫描\",{\"1\":{\"140\":1,\"143\":1}}],[\"在最坏情况下\",{\"1\":{\"143\":1}}],[\"在最坏的情况下\",{\"1\":{\"141\":1}}],[\"在最好情况下\",{\"1\":{\"142\":1,\"143\":1}}],[\"在这个分区退出之后\",{\"1\":{\"137\":1}}],[\"在创建数组时\",{\"1\":{\"49\":1}}],[\"相同的数可以放在任一边\",{\"1\":{\"137\":1}}],[\"比如main线程\",{\"1\":{\"177\":1}}],[\"比基准值大的元素都放在基准的后面\",{\"1\":{\"137\":1}}],[\"比较3和4\",{\"1\":{\"115\":1}}],[\"比较3和5\",{\"1\":{\"115\":2}}],[\"比较6和4\",{\"1\":{\"115\":1}}],[\"比较8和4\",{\"1\":{\"115\":1}}],[\"比较8和6\",{\"1\":{\"115\":1}}],[\"比较5和4\",{\"1\":{\"115\":1}}],[\"比较5和6\",{\"1\":{\"115\":1}}],[\"比较5和8\",{\"1\":{\"115\":1}}],[\"比较5和3\",{\"1\":{\"115\":1}}],[\"称为\",{\"1\":{\"137\":1}}],[\"采用分治法\",{\"1\":{\"137\":1}}],[\"快速排序的时间复杂度为o\",{\"1\":{\"137\":1}}],[\"快速排序的关键步骤是基准的选取\",{\"1\":{\"137\":1}}],[\"快速排序是一种常用的排序算法\",{\"1\":{\"137\":1}}],[\"快速排序\",{\"0\":{\"137\":1},\"1\":{\"137\":1}}],[\"归并排序\",{\"0\":{\"134\":1}}],[\"希尔排序\",{\"0\":{\"131\":1}}],[\"7\",{\"1\":{\"128\":1}}],[\"则r=a\",{\"1\":{\"137\":1}}],[\"则l=0\",{\"1\":{\"137\":1}}],[\"则将largest与当前节点交换\",{\"1\":{\"128\":1}}],[\"则更新largest为右子节点\",{\"1\":{\"128\":1}}],[\"则更新largest为左子节点\",{\"1\":{\"128\":1}}],[\"右子节点\",{\"1\":{\"128\":1}}],[\"左子节点\",{\"1\":{\"128\":1}}],[\"调用了该对象的start\",{\"1\":{\"177\":1}}],[\"调用方将版本号作为参数给接口\",{\"1\":{\"95\":1}}],[\"调整堆\",{\"1\":{\"128\":1}}],[\"重新成为一个大顶堆\",{\"1\":{\"128\":1}}],[\"重复使用线程\",{\"1\":{\"181\":1}}],[\"重复步骤3\",{\"1\":{\"143\":1}}],[\"重复步骤2~5\",{\"1\":{\"143\":1}}],[\"重复步骤2\",{\"1\":{\"114\":1}}],[\"重复上述步骤\",{\"1\":{\"127\":1,\"156\":1}}],[\"重复执行以下步骤\",{\"1\":{\"127\":1}}],[\"构建大顶堆\",{\"1\":{\"128\":1}}],[\"构建语法树\",{\"1\":{\"38\":1}}],[\"因此在需要保持相同元素的原始顺序时应谨慎使用\",{\"1\":{\"127\":1}}],[\"因为双指针同时进行遍历\",{\"1\":{\"119\":1}}],[\"空间复杂度\",{\"0\":{\"142\":1}}],[\"空间复杂度为o\",{\"1\":{\"127\":1}}],[\"空间有效利用\",{\"0\":{\"49\":1}}],[\"与第五个元素\",{\"1\":{\"157\":1}}],[\"与第四个元素\",{\"1\":{\"157\":1}}],[\"与第三个元素\",{\"1\":{\"157\":1}}],[\"与第二个元素\",{\"1\":{\"157\":1}}],[\"与第一个元素\",{\"1\":{\"157\":1}}],[\"与堆的最后一个元素交换\",{\"1\":{\"127\":1}}],[\"与同步双写相比分析优缺点\",{\"1\":{\"9\":1}}],[\"根节点\",{\"1\":{\"127\":1}}],[\"使其重新成为一个大顶堆\",{\"1\":{\"127\":1,\"128\":1}}],[\"使其满足大顶堆的特性\",{\"1\":{\"127\":1}}],[\"使用线程的isinterrupted方法检查中断状态\",{\"1\":{\"182\":1}}],[\"使用线程的interrupted方法检查中断标志位\",{\"1\":{\"182\":1}}],[\"使用线程的interrupt方法中断线程\",{\"1\":{\"182\":1}}],[\"使用计数排序算法对每个数字出现的次数进行统计\",{\"1\":{\"124\":1}}],[\"使用双指针算法可以有效地提高解决数组或链表相关问题的效率\",{\"1\":{\"119\":1}}],[\"使用订单id作为幂等标识下单\",{\"1\":{\"94\":1}}],[\"使用elasticsearch作为搜索引擎\",{\"1\":{\"78\":1}}],[\"使用explain语句解析sql执行计划\",{\"1\":{\"30\":1}}],[\"使用单体架构\",{\"1\":{\"61\":1}}],[\"建堆的过程从数组的最后一个非叶子节点开始\",{\"1\":{\"127\":1}}],[\"建堆\",{\"1\":{\"127\":1}}],[\"堆是一个可以推导具有最大或最小值的树形结构\",{\"1\":{\"127\":1}}],[\"堆排序的时间复杂度为o\",{\"1\":{\"127\":1}}],[\"堆排序分为两个步骤\",{\"1\":{\"127\":1}}],[\"堆排序利用堆的特性进行排序\",{\"1\":{\"127\":1}}],[\"堆排序\",{\"0\":{\"127\":1},\"1\":{\"127\":1}}],[\"是操作系统进行调度的基本单元\",{\"1\":{\"177\":1}}],[\"是待排序数组的长度\",{\"1\":{\"158\":1}}],[\"是利用堆\",{\"1\":{\"127\":1}}],[\"是一种简单直观的排序算法\",{\"1\":{\"143\":1}}],[\"是一种简单的排序算法\",{\"1\":{\"113\":1}}],[\"是一种常见的算法思想\",{\"1\":{\"119\":1}}],[\"o\",{\"1\":{\"158\":1}}],[\"out\",{\"1\":{\"128\":2,\"137\":6,\"159\":1,\"182\":5}}],[\"output\",{\"1\":{\"124\":3}}],[\"okr\",{\"1\":{\"2\":1}}],[\"workqueue\",{\"1\":{\"183\":1}}],[\"working\",{\"1\":{\"182\":1}}],[\"waiting\",{\"1\":{\"177\":2}}],[\"while\",{\"1\":{\"124\":1,\"137\":3,\"143\":1,\"182\":4}}],[\"www\",{\"1\":{\"36\":1}}],[\"获取cpu的使用权\",{\"1\":{\"177\":1}}],[\"获取最大值的位数\",{\"1\":{\"124\":1}}],[\"获取待排序数组中的最大值\",{\"1\":{\"124\":1}}],[\"||\",{\"1\":{\"124\":1}}],[\"将执行任务的续行策略\",{\"1\":{\"183\":1}}],[\"将其与第二个元素交换位置\",{\"1\":{\"156\":1}}],[\"将其与第一个元素交换位置\",{\"1\":{\"156\":1}}],[\"将新元素插入到该位置后\",{\"1\":{\"143\":1}}],[\"将该元素移动到下一位置\",{\"1\":{\"143\":1}}],[\"将所有比基准值小的元素都放在基准前面\",{\"1\":{\"137\":1}}],[\"将当前堆中的最大元素与堆的最后一个元素交换\",{\"1\":{\"128\":1}}],[\"将堆的大小减1\",{\"1\":{\"127\":1}}],[\"将堆中的最大元素\",{\"1\":{\"127\":1}}],[\"将一个无序的数组构建成一个大顶堆\",{\"1\":{\"127\":1}}],[\"将有序数组重新赋值给原数组\",{\"1\":{\"124\":1}}],[\"将整数按位数划分为不同的桶\",{\"1\":{\"123\":1}}],[\"依次向上调整每个节点\",{\"1\":{\"127\":1}}],[\"依次对每一位进行排序\",{\"1\":{\"124\":1}}],[\"依次确定每个数字在有序数组中的位置\",{\"1\":{\"124\":1}}],[\"依次放到数列的起始位置\",{\"1\":{\"114\":1}}],[\"确定最大位数d\",{\"1\":{\"124\":1}}],[\"确保订单信息的安全性和隐私性\",{\"1\":{\"90\":1}}],[\"done\",{\"1\":{\"182\":1}}],[\"d\",{\"1\":{\"137\":2}}],[\"divide\",{\"1\":{\"137\":1}}],[\"digit\",{\"1\":{\"124\":5}}],[\"dianping\",{\"1\":{\"36\":1}}],[\"dn\",{\"1\":{\"123\":1}}],[\"得到最终的排序结果\",{\"1\":{\"123\":1}}],[\"基准\",{\"1\":{\"137\":1}}],[\"基于计数排序的结果\",{\"1\":{\"124\":1}}],[\"基本原理\",{\"0\":{\"123\":1}}],[\"基数排序的实现步骤如下\",{\"1\":{\"124\":1}}],[\"基数排序的时间复杂度为o\",{\"1\":{\"123\":1}}],[\"基数排序的基本思想是\",{\"1\":{\"123\":1}}],[\"基数排序是一种非比较性的排序算法\",{\"1\":{\"123\":1}}],[\"基数排序\",{\"0\":{\"122\":1}}],[\"链表\",{\"2\":{\"121\":1}}],[\"降低到o\",{\"1\":{\"119\":1}}],[\"统计数组中元素出现次数等\",{\"1\":{\"119\":1}}],[\"另一个从起始位置开始向后遍历\",{\"1\":{\"119\":1}}],[\"我们通常使用两个指针\",{\"1\":{\"119\":1}}],[\"我们通常使用两个指针从数组的两端同时开始遍历\",{\"1\":{\"119\":1}}],[\"查找数组中的环形子数组等\",{\"1\":{\"119\":1}}],[\"查询接口将版本返回给调用方\",{\"1\":{\"95\":1}}],[\"查询商品详情\",{\"1\":{\"76\":1}}],[\"查询\",{\"1\":{\"2\":1}}],[\"通知或中断\",{\"1\":{\"177\":1}}],[\"通过工作线程来执行任务\",{\"1\":{\"181\":1}}],[\"通过构建有序序列\",{\"1\":{\"143\":1}}],[\"通过上面文章的方案比较\",{\"1\":{\"80\":1}}],[\"通常有以下几种选取方法\",{\"1\":{\"137\":1}}],[\"通常用于解决数组或链表相关的问题\",{\"1\":{\"119\":1}}],[\"双指针算法通常可以分为两种情况\",{\"1\":{\"119\":1}}],[\"双指针算法\",{\"1\":{\"119\":1}}],[\"双指针\",{\"0\":{\"119\":1},\"2\":{\"121\":1}}],[\"排序截至到数组末尾\",{\"1\":{\"137\":1}}],[\"排序后的数组\",{\"1\":{\"128\":1}}],[\"排序\",{\"1\":{\"127\":1,\"128\":1},\"2\":{\"118\":1,\"126\":1,\"130\":1,\"133\":1,\"136\":1,\"139\":1,\"145\":1,\"151\":1,\"154\":1,\"161\":1}}],[\"排查执行计划中扫描行数较多的查询语句\",{\"1\":{\"30\":1}}],[\"排查执行计划中是否有全表扫描的情况\",{\"1\":{\"30\":1}}],[\"排查慢查询过程\",{\"0\":{\"30\":1}}],[\"timeout\",{\"1\":{\"183\":2}}],[\"timed\",{\"1\":{\"177\":1}}],[\"to\",{\"1\":{\"182\":1}}],[\"tostring\",{\"1\":{\"159\":1}}],[\"try\",{\"1\":{\"182\":2}}],[\"true\",{\"1\":{\"182\":2}}],[\"throws\",{\"1\":{\"182\":1}}],[\"threadfactory\",{\"1\":{\"183\":1}}],[\"thread\",{\"1\":{\"182\":10}}],[\"thread类是一个实现了runnable接口的类\",{\"1\":{\"177\":1}}],[\"terminated\",{\"1\":{\"177\":1}}],[\"temp\",{\"1\":{\"116\":2,\"128\":2,\"159\":2}}],[\"two\",{\"1\":{\"119\":1}}],[\"tcc\",{\"1\":{\"2\":1}}],[\">=\",{\"1\":{\"124\":1,\"128\":2,\"143\":1}}],[\">\",{\"1\":{\"116\":1,\"124\":2,\"128\":2,\"137\":1,\"143\":1,\"182\":4}}],[\"<=\",{\"1\":{\"124\":1}}],[\"<\",{\"1\":{\"116\":2,\"124\":3,\"128\":2,\"137\":7,\"143\":1,\"159\":3}}],[\"0\",{\"1\":{\"116\":2,\"124\":6,\"128\":4,\"137\":1,\"143\":1,\"159\":1}}],[\"000\",{\"1\":{\"42\":2}}],[\"future<string>\",{\"1\":{\"182\":1}}],[\"future\",{\"1\":{\"182\":16}}],[\"f\",{\"1\":{\"146\":1}}],[\"for\",{\"1\":{\"116\":2,\"124\":4,\"128\":3,\"137\":2,\"143\":1,\"159\":2}}],[\"flink\",{\"1\":{\"2\":1}}],[\"void\",{\"1\":{\"116\":1,\"124\":2,\"128\":4,\"137\":2,\"143\":1,\"159\":2,\"182\":1}}],[\"vuepress\",{\"1\":{\"162\":1},\"2\":{\"164\":1}}],[\"vue\",{\"1\":{\"2\":1}}],[\"平均情况\",{\"1\":{\"116\":1}}],[\"复杂度分析\",{\"0\":{\"116\":1}}],[\"整个数列排序完成\",{\"1\":{\"115\":1}}],[\"继续冒泡排序\",{\"1\":{\"115\":2}}],[\"剩下的数列\",{\"1\":{\"115\":2}}],[\"此时处于就绪状态\",{\"1\":{\"177\":1}}],[\"此时最小元素3已经排好序\",{\"1\":{\"115\":1}}],[\"此时最大元素8已经排好序\",{\"1\":{\"115\":1}}],[\"此时第三大元素5已经排好序\",{\"1\":{\"115\":1}}],[\"此时次大元素6已经排好序\",{\"1\":{\"115\":1}}],[\"第五次遍历\",{\"1\":{\"157\":1}}],[\"第四次遍历\",{\"1\":{\"157\":1}}],[\"第四轮结束\",{\"1\":{\"115\":1}}],[\"第四轮\",{\"1\":{\"115\":1}}],[\"第三次遍历\",{\"1\":{\"157\":1}}],[\"第三轮结束\",{\"1\":{\"115\":1}}],[\"第三轮\",{\"1\":{\"115\":1}}],[\"第二次遍历\",{\"1\":{\"157\":1}}],[\"第二轮结束\",{\"1\":{\"115\":1}}],[\"第二轮\",{\"1\":{\"115\":1}}],[\"第一次遍历\",{\"1\":{\"157\":1}}],[\"第一轮结束\",{\"1\":{\"115\":1}}],[\"第一轮\",{\"1\":{\"115\":1}}],[\"接下来对剩下的数列\",{\"1\":{\"115\":1}}],[\"位置不变\",{\"1\":{\"115\":5}}],[\"交换最小元素与当前元素的位置\",{\"1\":{\"159\":1}}],[\"交换数组中的两个元素\",{\"1\":{\"128\":1}}],[\"交换arr\",{\"1\":{\"116\":1}}],[\"交换位置\",{\"1\":{\"115\":5,\"157\":5}}],[\"交易分析等操作\",{\"1\":{\"90\":1}}],[\"发现3<4\",{\"1\":{\"115\":1}}],[\"发现3<5\",{\"1\":{\"115\":2}}],[\"发现6>4\",{\"1\":{\"115\":1}}],[\"发现8>4\",{\"1\":{\"115\":1}}],[\"发现8>6\",{\"1\":{\"115\":1}}],[\"发现5>4\",{\"1\":{\"115\":1}}],[\"发现5>3\",{\"1\":{\"115\":1}}],[\"发现5<6\",{\"1\":{\"115\":1}}],[\"发现5<8\",{\"1\":{\"115\":1}}],[\"发货\",{\"1\":{\"91\":1}}],[\"5000\",{\"1\":{\"182\":1}}],[\"50\",{\"1\":{\"137\":1}}],[\"5\",{\"1\":{\"115\":12,\"128\":1,\"143\":1,\"157\":9,\"159\":2,\"182\":3}}],[\"示例\",{\"0\":{\"115\":1,\"157\":1}}],[\"直到所有元素均排序完毕\",{\"1\":{\"156\":1}}],[\"直到所有元素排序完成\",{\"1\":{\"114\":1}}],[\"直到全部待排序的数据元素排完\",{\"1\":{\"155\":1}}],[\"直到找到已排序的元素小于或者等于新元素的位置\",{\"1\":{\"143\":1}}],[\"直到堆的大小为1\",{\"1\":{\"127\":1}}],[\"直到最高位\",{\"1\":{\"124\":1}}],[\"直接访问\",{\"0\":{\"47\":1}}],[\"放到已排序序列的末尾\",{\"1\":{\"114\":1}}],[\"再从剩下的元素中挑出最小\",{\"1\":{\"114\":1}}],[\"元素\",{\"1\":{\"114\":2}}],[\"也就是说该数列已经排序完成\",{\"1\":{\"113\":1}}],[\"走访数列的工作是重复地进行直到没有再需要交换\",{\"1\":{\"113\":1}}],[\"它可以在指定的时间后自行返回\",{\"1\":{\"177\":1}}],[\"它包含线程的控制方法和线程的生命周期方法\",{\"1\":{\"177\":1}}],[\"它的基本思想是\",{\"1\":{\"155\":1}}],[\"它的基本思想是通过构建有序序列\",{\"1\":{\"140\":1}}],[\"它的基本步骤如下\",{\"1\":{\"137\":1}}],[\"它重复地走访过要排序的数列\",{\"1\":{\"113\":1}}],[\"它由一组连续的内存空间组成\",{\"1\":{\"45\":1}}],[\"冒泡排序是一种稳定的排序算法\",{\"1\":{\"116\":1}}],[\"冒泡排序\",{\"0\":{\"113\":1},\"1\":{\"113\":1}}],[\"zab一致性算法\",{\"0\":{\"110\":1}}],[\"zq99299\",{\"1\":{\"83\":1}}],[\"算法描述\",{\"0\":{\"114\":1}}],[\"算法\",{\"0\":{\"193\":1},\"2\":{\"102\":1,\"103\":1,\"105\":1,\"106\":1,\"108\":1,\"109\":1,\"111\":1,\"112\":1,\"117\":1,\"118\":1,\"120\":1,\"121\":1,\"125\":1,\"126\":1,\"129\":1,\"130\":1,\"132\":1,\"133\":1,\"135\":1,\"136\":1,\"138\":1,\"139\":1,\"144\":1,\"145\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":1,\"154\":1,\"160\":1,\"161\":1}}],[\"当任务队列和线程池都达到最大容量时\",{\"1\":{\"183\":1}}],[\"当有新的任务提交时\",{\"1\":{\"181\":1}}],[\"当线程数量过多时\",{\"1\":{\"181\":1}}],[\"当前位的权值\",{\"1\":{\"124\":1}}],[\"当数组是逆序排列时\",{\"1\":{\"116\":1}}],[\"当数组已经按照排序需求排好时\",{\"1\":{\"116\":1}}],[\"当版本一致的时候更新数据\",{\"1\":{\"95\":1}}],[\"当然\",{\"1\":{\"61\":1}}],[\"版本号的乐观锁机制\",{\"1\":{\"95\":1}}],[\"请求顺序不一致导致数据错乱\",{\"0\":{\"95\":1}}],[\"请求成功率\",{\"1\":{\"59\":1}}],[\"然后按每个位数分别对桶中的元素进行排序\",{\"1\":{\"123\":1}}],[\"然后根据具体的问题来决定两个指针的移动方式\",{\"1\":{\"119\":1}}],[\"然后\",{\"1\":{\"94\":1}}],[\"首先\",{\"1\":{\"94\":1}}],[\"注意的场景\",{\"0\":{\"93\":1}}],[\"完成\",{\"1\":{\"91\":1}}],[\"评价\",{\"1\":{\"91\":1}}],[\"签收\",{\"1\":{\"91\":1}}],[\"创建订单\",{\"1\":{\"91\":1}}],[\"生成订单id\",{\"1\":{\"91\":1,\"94\":1}}],[\"具体的实现方式根据业务需求和系统架构进行选择\",{\"1\":{\"90\":1}}],[\"具体分布式架构下的并发性能还是需要测试\",{\"1\":{\"61\":1}}],[\"以达到最佳的性能和效果\",{\"1\":{\"181\":1}}],[\"以及降低资源消耗和线程管理的复杂度\",{\"1\":{\"181\":1}}],[\"以上代码实现了选择排序的排序算法和排序结果的输出\",{\"1\":{\"159\":1}}],[\"以上三种迭代的方式\",{\"1\":{\"61\":1}}],[\"以下是堆排序的示例代码\",{\"1\":{\"127\":1}}],[\"以满足不同业务场景的需求\",{\"1\":{\"90\":1}}],[\"以便用户和商家进行订单管理\",{\"1\":{\"90\":1}}],[\"支付订单\",{\"1\":{\"91\":1}}],[\"支付信息\",{\"1\":{\"90\":1}}],[\"支付信息等\",{\"1\":{\"90\":1}}],[\"支持订单修改和取消\",{\"1\":{\"90\":1}}],[\"支持订单查询和统计\",{\"1\":{\"90\":1}}],[\"已排序\",{\"1\":{\"143\":1}}],[\"已完成等\",{\"1\":{\"90\":1}}],[\"已发货\",{\"1\":{\"90\":1}}],[\"已支付\",{\"1\":{\"90\":1}}],[\"物流信息等交易相关数据\",{\"1\":{\"90\":1}}],[\"物流模块\",{\"1\":{\"75\":1}}],[\"记录\",{\"0\":{\"194\":1}}],[\"记录搭建vuepress博客\",{\"0\":{\"162\":1}}],[\"记录并管理交易信息\",{\"1\":{\"90\":1}}],[\"记录大小k\",{\"1\":{\"42\":1}}],[\"记录大小\",{\"1\":{\"41\":1}}],[\"收货地址\",{\"1\":{\"90\":1}}],[\"包括订单号\",{\"1\":{\"90\":1}}],[\"订单状态机设计\",{\"0\":{\"92\":1}}],[\"订单\",{\"1\":{\"79\":1}}],[\"订单模块\",{\"1\":{\"75\":1}}],[\"elastic\",{\"0\":{\"186\":1}}],[\"elasticsearch\",{\"1\":{\"8\":1},\"2\":{\"17\":1,\"18\":1}}],[\"e\",{\"1\":{\"182\":1}}],[\"exception\",{\"1\":{\"182\":1}}],[\"executors\",{\"1\":{\"182\":4}}],[\"executorservice\",{\"1\":{\"182\":4}}],[\"executor\",{\"1\":{\"182\":12}}],[\"end\",{\"1\":{\"83\":1}}],[\"es数据同步方案\",{\"0\":{\"80\":1}}],[\"es数据映射\",{\"0\":{\"79\":1}}],[\"es需要对以下数据做映射\",{\"1\":{\"79\":1}}],[\"热卖商品\",{\"1\":{\"78\":1}}],[\"规格描述\",{\"1\":{\"78\":1}}],[\"更新库存\",{\"1\":{\"76\":1}}],[\"搜索相关度排序\",{\"1\":{\"78\":1}}],[\"搜索商品列表高性能低延时方案\",{\"0\":{\"78\":1}}],[\"搜索商品列表\",{\"1\":{\"76\":1}}],[\"搜索服务\",{\"1\":{\"11\":1}}],[\"录入商品\",{\"1\":{\"76\":1}}],[\"供应链模块\",{\"1\":{\"75\":1}}],[\"从而实现高效的并发处理\",{\"1\":{\"181\":1}}],[\"从而提高程序的响应能力\",{\"1\":{\"181\":1}}],[\"从而控制程序对系统资源的消耗\",{\"1\":{\"181\":1}}],[\"从而解决问题\",{\"1\":{\"119\":1}}],[\"从第一个元素开始\",{\"1\":{\"143\":1}}],[\"从左向右找第一个大于x的数\",{\"1\":{\"137\":1}}],[\"从右向左找第一个小于x的数\",{\"1\":{\"137\":1}}],[\"从起始位置开始排序\",{\"1\":{\"137\":1}}],[\"从数列中随机选取一个元素作为基准\",{\"1\":{\"137\":1}}],[\"从数列中挑出一个元素\",{\"1\":{\"137\":1}}],[\"从数列中挑出最小\",{\"1\":{\"114\":1}}],[\"从数组的一端向另一端移动的双指针算法\",{\"1\":{\"119\":1}}],[\"从数组的两端向中间移动的双指针算法\",{\"1\":{\"119\":1}}],[\"从个人手中回收商品\",{\"1\":{\"74\":1}}],[\"从外部企业渠道采购到公司内部\",{\"1\":{\"74\":1}}],[\"从底往上计算高度\",{\"1\":{\"41\":1}}],[\"企业回收\",{\"1\":{\"74\":1}}],[\"企业采购\",{\"1\":{\"74\":1}}],[\"企业生产\",{\"1\":{\"74\":1}}],[\"公司内部记录和管理\",{\"1\":{\"74\":1}}],[\"一次比较两个元素\",{\"1\":{\"113\":1}}],[\"一致性\",{\"2\":{\"103\":1,\"106\":1,\"109\":1,\"112\":1}}],[\"一般是有自己的供应链\",{\"1\":{\"74\":1}}],[\"一个指向数组的起始位置\",{\"1\":{\"119\":1}}],[\"一个非叶子节点存放叶子节点数量\",{\"1\":{\"41\":1}}],[\"一个叶子节点存放数据量\",{\"1\":{\"41\":1}}],[\"自产自销\",{\"1\":{\"74\":1}}],[\"电商购物车方案\",{\"0\":{\"98\":1}}],[\"电商订单的实现可以采用数据库存储\",{\"1\":{\"90\":1}}],[\"电商订单的职责\",{\"0\":{\"90\":1}}],[\"电商订单需要采取相应的安全措施\",{\"1\":{\"90\":1}}],[\"电商订单可以支持用户和商家对订单进行修改和取消操作\",{\"1\":{\"90\":1}}],[\"电商订单可以提供订单查询和统计功能\",{\"1\":{\"90\":1}}],[\"电商订单可以根据订单状态控制交易流程\",{\"1\":{\"90\":1}}],[\"电商订单负责记录和管理商品信息\",{\"1\":{\"90\":1}}],[\"电商订单具有以下职责\",{\"1\":{\"90\":1}}],[\"电商订单是记录电商平台上的交易信息的重要数据实体\",{\"1\":{\"90\":1}}],[\"电商订单设计方案\",{\"0\":{\"89\":1}}],[\"电商支付设计方案\",{\"0\":{\"86\":1}}],[\"电商搜索设计方案\",{\"0\":{\"83\":1}}],[\"电商商品设计方案\",{\"0\":{\"73\":1}}],[\"电商售后设计方案\",{\"0\":{\"70\":1}}],[\"电商\",{\"0\":{\"191\":1},\"2\":{\"68\":1,\"69\":1,\"71\":1,\"72\":1,\"81\":1,\"82\":1,\"84\":1,\"85\":1,\"87\":1,\"88\":1,\"96\":1,\"97\":1,\"99\":1,\"100\":1}}],[\"电商业务流程时序\",{\"0\":{\"67\":1},\"1\":{\"70\":1,\"73\":1,\"83\":1,\"86\":1,\"89\":1,\"98\":1}}],[\"测试\",{\"1\":{\"128\":1}}],[\"测试3级缓存\",{\"0\":{\"64\":1}}],[\"测试2级缓存\",{\"0\":{\"63\":1}}],[\"测试无缓存\",{\"0\":{\"62\":1}}],[\"测试并发性能\",{\"1\":{\"61\":1}}],[\"测试单体的并发性能可以粗略估算水平扩容的分布式架构的性能\",{\"1\":{\"61\":1}}],[\"仅使用mysql\",{\"1\":{\"61\":1}}],[\"仅需要在需要同步数据的逻辑上增加往elasticsearch写\",{\"1\":{\"7\":1}}],[\"库存接口\",{\"1\":{\"61\":1}}],[\"改变程序代码\",{\"1\":{\"61\":1}}],[\"编程语言固定\",{\"1\":{\"61\":1}}],[\"编写过数据大屏以及后台管理界面\",{\"1\":{\"2\":1}}],[\"家庭网络的路由大概是千兆网\",{\"1\":{\"61\":1}}],[\"本地网络\",{\"1\":{\"61\":1}}],[\"本身的组件\",{\"1\":{\"33\":1}}],[\"固定使用mysql和redis\",{\"1\":{\"61\":1}}],[\"40\",{\"1\":{\"137\":1}}],[\"4\",{\"1\":{\"115\":14,\"143\":1,\"157\":11,\"159\":2}}],[\"4c8g的硬件\",{\"1\":{\"61\":1}}],[\"4年工作经验\",{\"1\":{\"2\":1}}],[\"设计一个高并发的程序\",{\"1\":{\"61\":1}}],[\"设计图\",{\"1\":{\"2\":1}}],[\"只需进行一次遍历\",{\"1\":{\"116\":1}}],[\"只看程序代码的方式\",{\"1\":{\"61\":1}}],[\"只存在内存\",{\"1\":{\"33\":1}}],[\"只存在binlog和业务回查的延迟\",{\"1\":{\"16\":1}}],[\"考虑的因素比较多\",{\"1\":{\"61\":1}}],[\"程序代码\",{\"1\":{\"60\":1}}],[\"上行速率\",{\"1\":{\"60\":1}}],[\"带宽\",{\"1\":{\"60\":1}}],[\"网络异常情况下\",{\"0\":{\"95\":1}}],[\"网络固定\",{\"1\":{\"61\":1}}],[\"网络\",{\"1\":{\"60\":1}}],[\"网站流量高峰期等情况下\",{\"1\":{\"58\":1}}],[\"单体架构\",{\"1\":{\"60\":1}}],[\"软件架构固定\",{\"1\":{\"61\":1}}],[\"软件架构\",{\"1\":{\"60\":1}}],[\"软件工程专业\",{\"1\":{\"1\":1}}],[\"磁盘\",{\"1\":{\"60\":1}}],[\"磁盘的数据是落后于内存的数据的\",{\"1\":{\"33\":1}}],[\"硬件固定\",{\"1\":{\"61\":1}}],[\"硬件\",{\"1\":{\"60\":1}}],[\"影响并发的因素\",{\"0\":{\"60\":1}}],[\"get\",{\"1\":{\"182\":1}}],[\"gossip一致性算法\",{\"0\":{\"101\":1}}],[\"gc\",{\"1\":{\"59\":1}}],[\"github\",{\"1\":{\"36\":1,\"83\":1}}],[\"内存\",{\"1\":{\"59\":1,\"60\":1,\"61\":1}}],[\"资源利用率\",{\"1\":{\"59\":1}}],[\"成功数\",{\"1\":{\"59\":1}}],[\"并提供了丰富的配置选项\",{\"1\":{\"181\":1}}],[\"并提高程序的可靠性\",{\"1\":{\"181\":1}}],[\"并递归调整堆\",{\"1\":{\"128\":1}}],[\"并有公司内部记录和管理\",{\"1\":{\"74\":1}}],[\"并由公司内部记录和管理\",{\"1\":{\"74\":1}}],[\"并发\",{\"0\":{\"197\":1},\"2\":{\"66\":1,\"179\":1,\"185\":1}}],[\"并发数\",{\"1\":{\"59\":1}}],[\"并且不能动态改变\",{\"1\":{\"51\":1}}],[\"running\",{\"1\":{\"177\":2}}],[\"runnable\",{\"1\":{\"177\":1}}],[\"runnable接口定义了一个run\",{\"1\":{\"177\":1}}],[\"r\",{\"1\":{\"137\":5}}],[\"right\",{\"1\":{\"128\":4}}],[\"radix\",{\"1\":{\"124\":3}}],[\"radixsort\",{\"1\":{\"124\":2}}],[\"raft一致性算法\",{\"0\":{\"107\":1}}],[\"rt\",{\"1\":{\"59\":1}}],[\"result\",{\"1\":{\"182\":1}}],[\"ready\",{\"1\":{\"177\":2}}],[\"react\",{\"1\":{\"2\":1}}],[\"return\",{\"1\":{\"124\":1,\"182\":1}}],[\"redo\",{\"1\":{\"33\":3}}],[\"redis\",{\"1\":{\"2\":1,\"60\":1,\"61\":2}}],[\"响应时间\",{\"1\":{\"59\":1}}],[\"衡量高并发的指标\",{\"0\":{\"59\":1}}],[\"秒杀场景\",{\"1\":{\"58\":1}}],[\"服务不可用等问题\",{\"1\":{\"58\":1}}],[\"高并发通常出现在促销活动\",{\"1\":{\"58\":1}}],[\"高并发是指在一定时间内\",{\"1\":{\"58\":1}}],[\"高并发定义\",{\"0\":{\"58\":1}}],[\"高并发设计\",{\"0\":{\"57\":1,\"61\":1}}],[\"综上所述\",{\"1\":{\"54\":1}}],[\"大于新元素\",{\"1\":{\"143\":1}}],[\"大顶堆的特点是父节点的值大于或等于其子节点的值\",{\"1\":{\"127\":1}}],[\"大\",{\"1\":{\"114\":2,\"156\":2}}],[\"大量的请求同时访问应用程序或系统\",{\"1\":{\"58\":1}}],[\"大小固定\",{\"0\":{\"51\":1}}],[\"大学\",{\"1\":{\"1\":1}}],[\"会预分配足够的内存空间用于存储元素\",{\"1\":{\"49\":1}}],[\"修改等操作\",{\"1\":{\"48\":1}}],[\"删除\",{\"1\":{\"48\":1}}],[\"灵活操作\",{\"0\":{\"48\":1}}],[\"可以根据实际需要来配置线程池的参数\",{\"1\":{\"181\":1}}],[\"可以避免过多的线程同时占用资源\",{\"1\":{\"181\":1}}],[\"可以采用随机选取基准\",{\"1\":{\"137\":1}}],[\"可以将时间复杂度从o\",{\"1\":{\"119\":1}}],[\"可以有效利用内存空间\",{\"1\":{\"49\":1}}],[\"可以通过索引对数组中的元素进行增加\",{\"1\":{\"48\":1}}],[\"可以通过索引直接访问数组中的元素\",{\"1\":{\"47\":1}}],[\"可以实现不同的数据写入需求\",{\"1\":{\"16\":1}}],[\"3000\",{\"1\":{\"182\":1}}],[\"30\",{\"1\":{\"137\":1}}],[\"3级缓存\",{\"1\":{\"61\":1}}],[\"3\",{\"0\":{\"49\":1,\"53\":1},\"1\":{\"42\":1,\"115\":14,\"143\":1,\"157\":9,\"159\":2}}],[\"2级缓存\",{\"1\":{\"61\":1}}],[\"2千万的数据\",{\"1\":{\"42\":1}}],[\"2\",{\"0\":{\"48\":1,\"52\":1},\"1\":{\"42\":1,\"128\":4,\"143\":1,\"157\":8,\"159\":2}}],[\"20\",{\"1\":{\"42\":1,\"137\":1}}],[\"2015\",{\"1\":{\"1\":1}}],[\"8\",{\"1\":{\"42\":1,\"115\":5}}],[\"例子计算\",{\"0\":{\"42\":1}}],[\"例如控制任务的执行顺序\",{\"1\":{\"181\":1}}],[\"例如验证只包含相同字符的最长子串\",{\"1\":{\"119\":1}}],[\"例如查找两个数的和等于目标值\",{\"1\":{\"119\":1}}],[\"例如\",{\"1\":{\"16\":1,\"137\":2}}],[\"树高\",{\"1\":{\"41\":1,\"42\":1}}],[\"总数\",{\"1\":{\"59\":1}}],[\"总结\",{\"0\":{\"54\":1},\"1\":{\"42\":1}}],[\"总记录n\",{\"1\":{\"42\":1}}],[\"总记录数\",{\"1\":{\"41\":1}}],[\"总页数p\",{\"1\":{\"42\":1}}],[\"总页数\",{\"1\":{\"41\":1}}],[\"+f\",{\"1\":{\"146\":1}}],[\"+=\",{\"1\":{\"124\":1}}],[\"++\",{\"1\":{\"124\":1}}],[\"+\",{\"1\":{\"41\":2,\"61\":3,\"128\":3,\"143\":2,\"182\":3}}],[\"=⎩⎨⎧​01f\",{\"1\":{\"146\":1}}],[\"==\",{\"1\":{\"124\":1}}],[\"=\",{\"1\":{\"41\":5,\"42\":7,\"116\":6,\"124\":15,\"128\":13,\"137\":7,\"143\":6,\"159\":9,\"182\":8}}],[\"叶子节点存放数据\",{\"1\":{\"41\":1}}],[\"索引树高log\",{\"1\":{\"42\":1}}],[\"索引数b\",{\"1\":{\"42\":1}}],[\"索引的高度\",{\"1\":{\"41\":1}}],[\"索引大小x\",{\"1\":{\"42\":1}}],[\"索引大小\",{\"1\":{\"41\":1}}],[\"索引列不参与计算\",{\"1\":{\"29\":1}}],[\"blocked\",{\"1\":{\"177\":1}}],[\"before\",{\"1\":{\"137\":1}}],[\"build\",{\"1\":{\"127\":1}}],[\"bubblesort\",{\"1\":{\"116\":2}}],[\"bubble\",{\"1\":{\"113\":1}}],[\"back\",{\"1\":{\"83\":1}}],[\"book\",{\"1\":{\"83\":1}}],[\"b2b\",{\"1\":{\"74\":1}}],[\"b+树的高度为3\",{\"1\":{\"42\":1}}],[\"b\",{\"1\":{\"41\":2,\"42\":1}}],[\"byte\",{\"1\":{\"41\":3}}],[\"binlog\",{\"1\":{\"33\":1}}],[\"keepalivetime\",{\"1\":{\"183\":1}}],[\"key\",{\"1\":{\"143\":3}}],[\"k\",{\"1\":{\"41\":2}}],[\"kafka\",{\"1\":{\"11\":1}}],[\"n−2\",{\"1\":{\"146\":1}}],[\"n−1\",{\"1\":{\"146\":1}}],[\"num\",{\"1\":{\"128\":2}}],[\"null\",{\"1\":{\"124\":1}}],[\"nlogn\",{\"1\":{\"127\":1,\"137\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"182\":1}}],[\"newfixedthreadpool\",{\"1\":{\"182\":3}}],[\"new\",{\"1\":{\"124\":2,\"177\":1}}],[\"n是待排序元素个数\",{\"1\":{\"123\":1}}],[\"n^2\",{\"1\":{\"116\":2,\"119\":1,\"137\":1,\"141\":1,\"143\":1,\"158\":1}}],[\"note\",{\"1\":{\"83\":1}}],[\"n\",{\"1\":{\"41\":2,\"52\":1,\"53\":1,\"116\":4,\"119\":1,\"128\":8,\"137\":2,\"142\":1,\"143\":3,\"146\":1,\"158\":1,\"159\":3}}],[\"语法解析原理\",{\"0\":{\"38\":1}}],[\"语法解析器应用场景\",{\"0\":{\"37\":1}}],[\"语言最终会被编译成指令在程序中运行\",{\"1\":{\"36\":1}}],[\"语言\",{\"1\":{\"2\":1}}],[\"美团开源的sql\",{\"1\":{\"36\":1}}],[\"开源的sql解析器\",{\"1\":{\"36\":1}}],[\"开发技能\",{\"0\":{\"2\":1}}],[\"posts\",{\"0\":{\"187\":1}}],[\"pointers\",{\"1\":{\"119\":1}}],[\"pivot\",{\"1\":{\"137\":1}}],[\"printf\",{\"1\":{\"137\":6}}],[\"print\",{\"1\":{\"128\":1}}],[\"println\",{\"1\":{\"128\":1,\"159\":1,\"182\":5}}],[\"private\",{\"1\":{\"124\":1}}],[\"prometheus\",{\"1\":{\"2\":1}}],[\"placevalue\",{\"1\":{\"124\":5}}],[\"public\",{\"1\":{\"116\":2,\"124\":2,\"128\":3,\"137\":3,\"143\":2,\"159\":3,\"182\":2}}],[\"paxos一致性算法\",{\"0\":{\"104\":1}}],[\"parser\",{\"1\":{\"36\":1}}],[\"p\",{\"1\":{\"41\":2,\"42\":1}}],[\"由于堆排序是一种不稳定的排序算法\",{\"1\":{\"127\":1}}],[\"由于数据的更新操作都是在内存发生的\",{\"1\":{\"33\":1}}],[\"由专门的公司维护\",{\"1\":{\"36\":1}}],[\"保证订单安全和隐私\",{\"1\":{\"90\":1}}],[\"保证了持久性和一致性\",{\"1\":{\"33\":1}}],[\"保证实时性主要依赖于搜索服务的定时间隔\",{\"1\":{\"14\":1}}],[\"保证实时性\",{\"1\":{\"7\":1}}],[\"这样可以保证任务的执行质量\",{\"1\":{\"181\":1}}],[\"这样可以避免线程的创建和销毁带来的开销\",{\"1\":{\"181\":1}}],[\"这种数据结构进行选择排序的一种算法\",{\"1\":{\"127\":1}}],[\"这种算法通常用于解决一些排序或统计的问题\",{\"1\":{\"119\":1}}],[\"这种算法通常用于解决一些查找或筛选的问题\",{\"1\":{\"119\":1}}],[\"这种情况下\",{\"1\":{\"119\":2}}],[\"这里网络不会成为卡点\",{\"1\":{\"61\":1}}],[\"这里用控制变量法去控制其他因素保持不变\",{\"1\":{\"61\":1}}],[\"这个时候再将差异的数据写入磁盘中\",{\"1\":{\"33\":1}}],[\"这个时候发生了断电\",{\"1\":{\"33\":1}}],[\"这是innodb的写入操作流程\",{\"1\":{\"33\":1}}],[\"这是mysql架构组件执行流程\",{\"1\":{\"33\":1}}],[\"这是我的个人简历\",{\"1\":{\"0\":1}}],[\"还没有落入磁盘中\",{\"1\":{\"33\":1}}],[\"还需要改动商品代码\",{\"1\":{\"8\":1}}],[\"假设数据在提交事务后\",{\"1\":{\"33\":1}}],[\"如何停止线程池中的线程\",{\"0\":{\"182\":1}}],[\"如何解决aba问题\",{\"0\":{\"95\":1}}],[\"如何避免重复下单\",{\"0\":{\"94\":1}}],[\"如何保证内存的数据和磁盘的数据一致性\",{\"1\":{\"33\":1}}],[\"如待支付\",{\"1\":{\"90\":1}}],[\"如响应时间变慢\",{\"1\":{\"58\":1}}],[\"如果该元素\",{\"1\":{\"143\":1}}],[\"如果largest不是当前节点\",{\"1\":{\"128\":1}}],[\"如果右子节点比当前节点大\",{\"1\":{\"128\":1}}],[\"如果左子节点比当前节点大\",{\"1\":{\"128\":1}}],[\"如果他们的顺序错误就把他们交换过来\",{\"1\":{\"113\":1}}],[\"如果设计一个高并发的系统\",{\"1\":{\"61\":1}}],[\"如果需要删除数组中的中间元素\",{\"1\":{\"53\":1}}],[\"如果需要在数组的中间插入元素\",{\"1\":{\"52\":1}}],[\"如果需要存储更多的元素\",{\"1\":{\"51\":1}}],[\"如果实在无法优化\",{\"1\":{\"30\":1}}],[\"那么语言本身是可以被解析\",{\"1\":{\"36\":1}}],[\"那么断电恢复后\",{\"1\":{\"33\":1}}],[\"那么redo\",{\"1\":{\"33\":1}}],[\"那么如果断电后\",{\"1\":{\"33\":1}}],[\"那么elasticsearch和mysql的数据无法保证一致\",{\"1\":{\"8\":1}}],[\"作用\",{\"1\":{\"33\":1}}],[\"的元素\",{\"1\":{\"156\":2}}],[\"的一个元素\",{\"1\":{\"155\":1}}],[\"的空间复杂度\",{\"1\":{\"141\":1,\"142\":1}}],[\"的时间复杂度和o\",{\"1\":{\"141\":1,\"142\":1}}],[\"的思想\",{\"1\":{\"137\":1}}],[\"的作用就是用来保证磁盘和内存数据的一致性\",{\"1\":{\"33\":1}}],[\"的\",{\"1\":{\"33\":1}}],[\"的分布式缓存策略\",{\"1\":{\"2\":1}}],[\"特有的组件\",{\"1\":{\"33\":1}}],[\"时间单位\",{\"1\":{\"183\":1}}],[\"时间\",{\"1\":{\"183\":1}}],[\"时间复杂度\",{\"0\":{\"141\":1,\"158\":1}}],[\"时间复杂度为o\",{\"1\":{\"47\":1,\"52\":1,\"53\":1,\"116\":3}}],[\"时\",{\"1\":{\"33\":2}}],[\"l\",{\"0\":{\"188\":1},\"1\":{\"137\":5}}],[\"left\",{\"1\":{\"128\":4}}],[\"length\",{\"1\":{\"116\":1,\"124\":7,\"128\":1,\"137\":4,\"143\":1,\"159\":1}}],[\"largest\",{\"1\":{\"128\":8}}],[\"log\",{\"1\":{\"33\":5,\"41\":1}}],[\"linux\",{\"1\":{\"2\":1}}],[\"iscancelled\",{\"1\":{\"182\":1}}],[\"isdone\",{\"1\":{\"182\":1}}],[\"isinterrupted\",{\"1\":{\"182\":4}}],[\"import\",{\"1\":{\"182\":1}}],[\"i<a\",{\"1\":{\"137\":2}}],[\"i=0\",{\"1\":{\"137\":2}}],[\"i+1\",{\"1\":{\"137\":1,\"159\":1}}],[\"i++\",{\"1\":{\"116\":1,\"124\":3,\"137\":4,\"143\":1,\"159\":1}}],[\"if\",{\"1\":{\"116\":1,\"124\":2,\"128\":3,\"137\":3,\"159\":1,\"182\":2}}],[\"i\",{\"1\":{\"116\":3,\"124\":16,\"128\":18,\"137\":15,\"143\":4,\"159\":5}}],[\"insertionsort\",{\"1\":{\"143\":1}}],[\"insertion\",{\"1\":{\"143\":1}}],[\"index\",{\"1\":{\"124\":2}}],[\"interrupt\",{\"1\":{\"182\":2}}],[\"interruptedexception\",{\"1\":{\"182\":1}}],[\"interrupted\",{\"1\":{\"182\":2}}],[\"int\",{\"1\":{\"116\":5,\"124\":17,\"128\":16,\"137\":6,\"143\":5,\"159\":7}}],[\"innodb会从redo\",{\"1\":{\"33\":1}}],[\"innodb\",{\"1\":{\"33\":1}}],[\"innodb存储引擎执行过程\",{\"1\":{\"33\":1}}],[\"io\",{\"1\":{\"2\":1,\"59\":1,\"83\":1}}],[\"最大线程数\",{\"1\":{\"183\":1}}],[\"最终得到的数组为\",{\"1\":{\"157\":1}}],[\"最终得到的数组就是一个有序的数组\",{\"1\":{\"127\":1}}],[\"最终将所有位数上的排序结果合并在一起\",{\"1\":{\"123\":1}}],[\"最终选用数据订阅方式\",{\"1\":{\"80\":1}}],[\"最坏情况\",{\"1\":{\"116\":1}}],[\"最好情况\",{\"1\":{\"116\":1}}],[\"最后交给存储引擎执行sql\",{\"1\":{\"33\":1}}],[\"最左前缀匹配原则\",{\"1\":{\"29\":1}}],[\"看看是否折中的方案实现业务\",{\"1\":{\"30\":1}}],[\"制定方案优化sql\",{\"1\":{\"30\":1}}],[\"尽量扩展索引\",{\"1\":{\"29\":1}}],[\"优化原则\",{\"0\":{\"29\":1}}],[\"优点\",{\"0\":{\"7\":1,\"10\":1,\"13\":1,\"16\":1}}],[\"客户端的写入适配器\",{\"1\":{\"16\":1}}],[\"良好的扩展行\",{\"1\":{\"16\":1}}],[\"利用canal组件即可无需在商品代码上做改动\",{\"1\":{\"16\":1}}],[\"利用canal订阅mysql的binlog做到解耦合\",{\"1\":{\"16\":1}}],[\"无缓存\",{\"1\":{\"61\":1}}],[\"无法删除中间元素\",{\"0\":{\"53\":1}}],[\"无法插入中间元素\",{\"0\":{\"52\":1}}],[\"无法保证实时性\",{\"1\":{\"14\":1}}],[\"无业务侵入\",{\"1\":{\"16\":1}}],[\"存放在序列的起始位置\",{\"1\":{\"155\":1}}],[\"存在mq延迟\",{\"1\":{\"11\":1}}],[\"存储系统\",{\"1\":{\"2\":1}}],[\"准实时\",{\"1\":{\"11\":1,\"16\":1}}],[\"商品信息\",{\"1\":{\"90\":1}}],[\"商品\",{\"1\":{\"79\":1}}],[\"商品副标题\",{\"1\":{\"78\":1}}],[\"商品标题\",{\"1\":{\"78\":1}}],[\"商品标签\",{\"1\":{\"78\":1,\"79\":1}}],[\"商品类目\",{\"1\":{\"78\":1,\"79\":1}}],[\"商品模型\",{\"0\":{\"77\":1}}],[\"商品核心功能\",{\"0\":{\"76\":1}}],[\"商品物流\",{\"1\":{\"75\":1}}],[\"商品售卖\",{\"1\":{\"75\":1}}],[\"商品上下游模块依赖\",{\"0\":{\"75\":1}}],[\"商品定价\",{\"1\":{\"74\":1}}],[\"商品描述\",{\"1\":{\"74\":1,\"78\":1}}],[\"商品规格\",{\"1\":{\"74\":1,\"79\":1}}],[\"商品来源\",{\"1\":{\"74\":1,\"75\":1}}],[\"商品的职责有哪些\",{\"0\":{\"74\":1}}],[\"商品本身无需关注同步elasticsearch的逻辑\",{\"1\":{\"10\":1}}],[\"商品业务和搜索业务强耦合\",{\"1\":{\"8\":1}}],[\"解耦合\",{\"1\":{\"10\":1,\"16\":1}}],[\"写入elasticsearch出现网络异常\",{\"1\":{\"8\":1}}],[\"需要进行n\",{\"1\":{\"116\":2}}],[\"需要将后面的元素都向前移动一位\",{\"1\":{\"53\":1}}],[\"需要将后面的元素都向后移动一位\",{\"1\":{\"52\":1}}],[\"需要重新创建一个更大的数组\",{\"1\":{\"51\":1}}],[\"需要考虑额外组件的可靠性\",{\"1\":{\"11\":1}}],[\"需要额外保证一致性\",{\"1\":{\"8\":1}}],[\"需要定制搜索需求需求时\",{\"1\":{\"8\":1}}],[\"和运行中\",{\"1\":{\"177\":1}}],[\"和arr\",{\"1\":{\"116\":1}}],[\"和\",{\"1\":{\"8\":1}}],[\"扩展性差\",{\"1\":{\"8\":1}}],[\"缺点\",{\"0\":{\"8\":1,\"11\":1,\"14\":1}}],[\"数学公式如下\",{\"1\":{\"146\":1}}],[\"数列还是\",{\"1\":{\"115\":5}}],[\"数列变成\",{\"1\":{\"115\":5}}],[\"数组保持不变\",{\"1\":{\"157\":2}}],[\"数组变为\",{\"1\":{\"157\":3}}],[\"数组适用于元素数量固定且需要直接访问的场景\",{\"1\":{\"54\":1}}],[\"数组的右边界\",{\"1\":{\"137\":1}}],[\"数组的左边界\",{\"1\":{\"137\":1}}],[\"数组的大小在创建时就需要确定\",{\"1\":{\"51\":1}}],[\"数组的主要缺点包括\",{\"0\":{\"50\":1}}],[\"数组的主要优点包括\",{\"0\":{\"46\":1}}],[\"数组是一种线性数据结构\",{\"1\":{\"45\":1}}],[\"数组\",{\"0\":{\"45\":1},\"2\":{\"56\":1,\"121\":1}}],[\"数据结构\",{\"0\":{\"189\":1},\"2\":{\"55\":1,\"56\":1}}],[\"数据库固定\",{\"1\":{\"61\":1}}],[\"数据库\",{\"1\":{\"60\":1}}],[\"数据库页大小\",{\"1\":{\"41\":1}}],[\"数据库指针大小\",{\"1\":{\"41\":1}}],[\"数据订阅\",{\"0\":{\"15\":1},\"1\":{\"5\":1}}],[\"数仓\",{\"1\":{\"2\":1}}],[\"定时任务\",{\"0\":{\"12\":1},\"1\":{\"5\":1}}],[\"异步双写\",{\"0\":{\"9\":1},\"1\":{\"5\":1}}],[\"同步双写\",{\"0\":{\"6\":1},\"1\":{\"5\":1}}],[\"框架\",{\"1\":{\"2\":1}}],[\"实现选择排序的示例代码\",{\"1\":{\"159\":1}}],[\"实现步骤\",{\"0\":{\"124\":1}}],[\"实现持久性和一致性\",{\"1\":{\"33\":1}}],[\"实现原理\",{\"1\":{\"2\":2}}],[\"实时计算任务\",{\"1\":{\"2\":1}}],[\"离线计算任务\",{\"1\":{\"2\":1}}],[\"catch\",{\"1\":{\"182\":1}}],[\"cancel\",{\"1\":{\"182\":3}}],[\"canal组件还支持各种数据库\",{\"1\":{\"16\":1}}],[\"currentthread\",{\"1\":{\"182\":6}}],[\"corepoolsize\",{\"1\":{\"183\":1}}],[\"concurrent\",{\"1\":{\"182\":1}}],[\"conquer\",{\"1\":{\"137\":1}}],[\"count\",{\"1\":{\"124\":7}}],[\"countingsort\",{\"1\":{\"124\":2}}],[\"com\",{\"1\":{\"1\":1,\"36\":2}}],[\"class\",{\"1\":{\"116\":1,\"124\":1,\"128\":1,\"137\":1,\"143\":1,\"159\":1,\"182\":1}}],[\"clickhouse\",{\"1\":{\"2\":1}}],[\"c2b\",{\"1\":{\"74\":1}}],[\"cpu\",{\"1\":{\"59\":1,\"60\":1}}],[\"c\",{\"1\":{\"41\":2}}],[\"架构\",{\"0\":{\"190\":1},\"1\":{\"2\":1},\"2\":{\"65\":1,\"66\":1}}],[\"策略\",{\"1\":{\"2\":1}}],[\"x\",{\"1\":{\"41\":2,\"137\":5}}],[\"xxl\",{\"1\":{\"2\":1}}],[\"xa\",{\"1\":{\"2\":1}}],[\"heapify\",{\"1\":{\"128\":4}}],[\"heapsort\",{\"1\":{\"128\":1}}],[\"heap\",{\"1\":{\"127\":4}}],[\"h\",{\"1\":{\"41\":2}}],[\"https\",{\"1\":{\"36\":2,\"83\":1}}],[\"hbase\",{\"1\":{\"2\":1,\"16\":1}}],[\"handler\",{\"1\":{\"183\":1}}],[\"hadoop\",{\"1\":{\"2\":1}}],[\"ha\",{\"1\":{\"2\":1}}],[\"掌握常见监控告警设计\",{\"1\":{\"2\":1}}],[\"掌握常见分布式事务设计\",{\"1\":{\"2\":1}}],[\"掌握数据仓库设计\",{\"1\":{\"2\":1}}],[\"掌握基于\",{\"1\":{\"2\":1}}],[\"掌握分布式调度设计\",{\"1\":{\"2\":1}}],[\"掌握分布式缓存设计\",{\"1\":{\"2\":1}}],[\"掌握分布式存储设计\",{\"1\":{\"2\":1}}],[\"掌握复杂\",{\"1\":{\"2\":1}}],[\"脚手架\",{\"1\":{\"2\":1}}],[\"脚本\",{\"1\":{\"2\":1}}],[\"微服务分布式架构实现\",{\"1\":{\"2\":1}}],[\"全家桶\",{\"1\":{\"2\":1}}],[\"全日制统招本科\",{\"1\":{\"1\":1}}],[\"系统生态\",{\"1\":{\"2\":1}}],[\"系统\",{\"1\":{\"2\":1}}],[\"分别从数组或链表的两端向中间移动\",{\"1\":{\"119\":1}}],[\"分布式架构\",{\"1\":{\"60\":1}}],[\"分布式事务管理\",{\"1\":{\"2\":1}}],[\"分库分表\",{\"1\":{\"2\":1}}],[\"my\",{\"0\":{\"188\":1}}],[\"mysql索引b+树高度计算\",{\"0\":{\"41\":1}}],[\"mysql源码的解析器\",{\"1\":{\"36\":1}}],[\"mysql的缓存忽略不计\",{\"1\":{\"61\":1}}],[\"mysql的语法解析器\",{\"0\":{\"36\":1}}],[\"mysql的sql执行过程\",{\"0\":{\"33\":1}}],[\"mysql慢查询优化\",{\"0\":{\"28\":1}}],[\"mysql分库分表\",{\"0\":{\"25\":1}}],[\"mysql事务\",{\"0\":{\"22\":1}}],[\"mysql事务提交之后\",{\"1\":{\"8\":1}}],[\"mysql主从复制\",{\"0\":{\"19\":1}}],[\"mysql同步数据es\",{\"0\":{\"5\":1},\"1\":{\"80\":1}}],[\"mysql\",{\"1\":{\"2\":3,\"8\":1,\"33\":1,\"60\":1,\"61\":2},\"2\":{\"18\":1,\"20\":1,\"21\":1,\"23\":1,\"24\":1,\"26\":1,\"27\":1,\"31\":1,\"32\":1,\"34\":1,\"35\":1,\"39\":1,\"40\":1,\"43\":1,\"44\":1}}],[\"minindex\",{\"1\":{\"159\":5}}],[\"main\",{\"1\":{\"128\":1,\"137\":1,\"159\":1,\"182\":2}}],[\"maximumpoolsize\",{\"1\":{\"183\":1}}],[\"max\",{\"1\":{\"127\":1}}],[\"maxnum\",{\"1\":{\"124\":4}}],[\"md\",{\"1\":{\"70\":1,\"73\":1,\"80\":1,\"83\":1,\"86\":1,\"89\":1,\"98\":1}}],[\"meituan\",{\"1\":{\"36\":1}}],[\"mvcc\",{\"1\":{\"2\":1}}],[\"after\",{\"1\":{\"137\":1}}],[\"a\",{\"1\":{\"137\":17}}],[\"and\",{\"1\":{\"137\":1}}],[\"args\",{\"1\":{\"128\":1,\"137\":1,\"159\":1,\"182\":1}}],[\"arrays\",{\"1\":{\"159\":1}}],[\"array\",{\"1\":{\"143\":7}}],[\"arraycopy\",{\"1\":{\"124\":1}}],[\"arr\",{\"1\":{\"116\":8,\"124\":17,\"128\":20,\"159\":11}}],[\"algorithm\",{\"1\":{\"119\":1}}],[\"api接口调用等方式\",{\"1\":{\"90\":1}}],[\"advisor\",{\"1\":{\"36\":1}}],[\"acid\",{\"1\":{\"2\":1}}],[\"agent\",{\"1\":{\"2\":1}}],[\"了解索引实现机制\",{\"1\":{\"2\":1}}],[\"了解\",{\"1\":{\"2\":4}}],[\"对应的序列是逆序的\",{\"1\":{\"143\":1}}],[\"对应的序列是已排序的\",{\"1\":{\"143\":1}}],[\"对应的解析器有哪些实现\",{\"1\":{\"36\":1}}],[\"对未排序数据\",{\"1\":{\"140\":1,\"143\":1}}],[\"对基准的左右两个分区重复步骤1和步骤2\",{\"1\":{\"137\":1}}],[\"对交换后的元素进行调整\",{\"1\":{\"128\":1}}],[\"对堆进行调整\",{\"1\":{\"127\":1}}],[\"对最末位进行排序\",{\"1\":{\"124\":1}}],[\"对数列\",{\"1\":{\"115\":1}}],[\"对\",{\"1\":{\"2\":1}}],[\"熟练编写\",{\"1\":{\"2\":1}}],[\"熟练\",{\"1\":{\"2\":1}}],[\"熟练使用常见的分布式调度平台\",{\"1\":{\"2\":1}}],[\"熟练使用\",{\"1\":{\"2\":2}}],[\"熟悉线上运维命令\",{\"1\":{\"2\":1}}],[\"熟悉常见\",{\"1\":{\"2\":1}}],[\"熟悉读写分离策略\",{\"1\":{\"2\":1}}],[\"熟悉\",{\"1\":{\"2\":6}}],[\"主从复制策略\",{\"1\":{\"2\":1}}],[\"工作法\",{\"1\":{\"2\":1}}],[\"精通\",{\"1\":{\"2\":2}}],[\"精通业务关系建模\",{\"1\":{\"2\":1}}],[\"绘制系统架构图\",{\"1\":{\"2\":1}}],[\"能够独立设计大型复杂系统\",{\"1\":{\"2\":1}}],[\"j+1\",{\"1\":{\"116\":4}}],[\"j++\",{\"1\":{\"116\":1,\"159\":1}}],[\"j\",{\"1\":{\"116\":6,\"128\":3,\"137\":11,\"143\":7,\"159\":4}}],[\"job\",{\"1\":{\"2\":1}}],[\"jvm\",{\"0\":{\"195\":1},\"1\":{\"2\":1,\"59\":1}}],[\"java框架\",{\"0\":{\"199\":1}}],[\"java线程池的设计思想是基于生产者\",{\"1\":{\"181\":1}}],[\"java线程池的设计思想是为了提高线程的使用效率和响应能力\",{\"1\":{\"181\":1}}],[\"java线程池通过threadpoolexecutor类来实现\",{\"1\":{\"181\":1}}],[\"java线程池可以对任务的执行进行管理\",{\"1\":{\"181\":1}}],[\"java线程池可以快速响应任务的提交和执行\",{\"1\":{\"181\":1}}],[\"java线程池可以控制线程的数量\",{\"1\":{\"181\":1}}],[\"java线程池中的线程可以被重复使用\",{\"1\":{\"181\":1}}],[\"java线程池主要具有以下设计思想\",{\"1\":{\"181\":1}}],[\"java线程中将就绪\",{\"1\":{\"177\":1}}],[\"java中的线程有以下几种状态\",{\"1\":{\"177\":1}}],[\"java中的线程由thread类和runnable接口实现\",{\"1\":{\"177\":1}}],[\"java的线程是程序执行的最小单位\",{\"1\":{\"177\":1}}],[\"java代码实现\",{\"0\":{\"143\":1}}],[\"java实现\",{\"0\":{\"128\":1}}],[\"java\",{\"0\":{\"196\":1},\"1\":{\"2\":2,\"61\":1,\"159\":1,\"182\":1},\"2\":{\"18\":1,\"21\":1,\"24\":1,\"27\":1,\"32\":1,\"35\":1,\"40\":1,\"44\":1,\"72\":1,\"82\":1,\"85\":1,\"88\":1,\"97\":1,\"100\":1,\"166\":1,\"167\":1,\"169\":1,\"170\":1,\"172\":1,\"173\":1,\"175\":1,\"176\":1,\"178\":1,\"179\":1,\"184\":1,\"185\":1}}],[\"s\",{\"0\":{\"188\":1}}],[\"sleep\",{\"1\":{\"182\":2}}],[\"submit\",{\"1\":{\"182\":4}}],[\"suveng\",{\"1\":{\"1\":1}}],[\"search\",{\"0\":{\"186\":1}}],[\"seata\",{\"1\":{\"2\":1}}],[\"selectionsort\",{\"1\":{\"159\":3}}],[\"swap\",{\"1\":{\"128\":3}}],[\"system\",{\"1\":{\"124\":1,\"128\":2,\"137\":6,\"159\":1,\"182\":5}}],[\"status\",{\"1\":{\"182\":2}}],[\"static\",{\"1\":{\"116\":1,\"124\":2,\"128\":4,\"137\":2,\"143\":1,\"159\":2,\"182\":1}}],[\"string\",{\"1\":{\"128\":1,\"137\":1,\"159\":1,\"182\":1}}],[\"storage\",{\"1\":{\"83\":1}}],[\"sort\",{\"1\":{\"113\":1,\"127\":2,\"128\":2,\"137\":2,\"143\":2}}],[\"schedulex\",{\"1\":{\"2\":1}}],[\"shutdown\",{\"1\":{\"182\":1}}],[\"shutdownnow\",{\"1\":{\"182\":3}}],[\"shell\",{\"1\":{\"2\":1}}],[\"sharding\",{\"1\":{\"2\":1}}],[\"springblade\",{\"1\":{\"2\":1}}],[\"springcloud\",{\"1\":{\"2\":1}}],[\"spring\",{\"0\":{\"198\":1},\"1\":{\"2\":1}}],[\"sphere\",{\"1\":{\"2\":1}}],[\"spi\",{\"1\":{\"2\":1}}],[\"sql分析监控\",{\"1\":{\"37\":1}}],[\"sqladvisor\",{\"1\":{\"36\":1}}],[\"sqlparser\",{\"1\":{\"36\":1}}],[\"sql本身是一种程序语言\",{\"1\":{\"36\":1}}],[\"sql\",{\"1\":{\"2\":3,\"36\":1}}],[\"反射\",{\"1\":{\"2\":1}}],[\"邮箱\",{\"1\":{\"1\":1}}],[\"手机号\",{\"1\":{\"1\":1}}],[\"60\",{\"1\":{\"137\":1}}],[\"6\",{\"1\":{\"1\":1,\"41\":2,\"115\":9,\"128\":1,\"143\":1}}],[\"9~2019\",{\"1\":{\"1\":1}}],[\"韩山师范学院\",{\"1\":{\"1\":1}}],[\"13\",{\"1\":{\"128\":1}}],[\"11\",{\"1\":{\"128\":1}}],[\"1170\",{\"1\":{\"42\":1}}],[\"10\",{\"1\":{\"124\":5,\"137\":1}}],[\"1024\",{\"1\":{\"41\":2,\"42\":1}}],[\"1次遍历\",{\"1\":{\"116\":2}}],[\"1\",{\"0\":{\"47\":1,\"51\":1},\"1\":{\"41\":1,\"47\":1,\"116\":2,\"124\":7,\"127\":1,\"128\":3,\"137\":3,\"141\":1,\"142\":1,\"143\":5,\"157\":8,\"159\":3}}],[\"16\",{\"1\":{\"41\":2}}],[\"16kb\",{\"1\":{\"41\":1}}],[\"163\",{\"1\":{\"1\":1}}],[\"18320664028\",{\"1\":{\"1\":1}}],[\"1250000\",{\"1\":{\"42\":1}}],[\"12\",{\"1\":{\"1\":1,\"128\":1}}],[\"1996\",{\"1\":{\"1\":1}}],[\"出生年月\",{\"1\":{\"1\":1}}],[\"男\",{\"1\":{\"1\":1}}],[\"性别\",{\"1\":{\"1\":1}}],[\"苏文广\",{\"1\":{\"1\":1}}],[\"姓名\",{\"1\":{\"1\":1}}],[\"个人信息\",{\"0\":{\"1\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
