<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://suveng.github.io/suveng_blog/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://suveng.github.io/suveng_blog/</id>
  <title>苏文广的博客</title>
  <subtitle>苏文广的博客</subtitle>
  <updated>2024-01-06T11:14:02.891Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://suveng.github.io/suveng_blog/atom.xml"/>
  <link rel="alternate" href="https://suveng.github.io/suveng_blog/"/>
  <category term="算法"/>
  <category term="数据结构"/>
  <category term="博客"/>
  <category term="博主"/>
  <entry>
    <title type="text">电商搜索方案</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E6%90%9C%E7%B4%A2%E6%96%B9%E6%A1%88.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E7%94%B5%E5%95%86/%E7%94%B5%E5%95%86%E6%90%9C%E7%B4%A2%E6%96%B9%E6%A1%88.html"/>
    <updated>2024-01-06T11:11:12.000Z</updated>
    <summary type="html"><![CDATA[<h1> 电商搜索方案</h1>
<p>https://zq99299.github.io/note-book/back-end-storage/</p>
]]></summary>
    <content type="html"><![CDATA[<h1> 电商搜索方案</h1>
<p>https://zq99299.github.io/note-book/back-end-storage/</p>
]]></content>
    <published>2024-01-06T11:11:12.000Z</published>
  </entry>
  <entry>
    <title type="text">冒泡排序</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html"/>
    <updated>2024-01-06T11:11:12.000Z</updated>
    <summary type="html"><![CDATA[<h1> 冒泡排序</h1>
<p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<h2> 算法描述</h2>
<ol>
<li>从数列中挑出最小（大）元素，依次放到数列的起始位置；</li>
<li>再从剩下的元素中挑出最小（大）元素，放到已排序序列的末尾；</li>
<li>重复步骤2，直到所有元素排序完成。</li>
</ol>
<h2> 示例</h2>
<p>对数列 {5, 3, 8, 6, 4} 进行冒泡排序：</p>]]></summary>
    <content type="html"><![CDATA[<h1> 冒泡排序</h1>
<p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<h2> 算法描述</h2>
<ol>
<li>从数列中挑出最小（大）元素，依次放到数列的起始位置；</li>
<li>再从剩下的元素中挑出最小（大）元素，放到已排序序列的末尾；</li>
<li>重复步骤2，直到所有元素排序完成。</li>
</ol>
<h2> 示例</h2>
<p>对数列 {5, 3, 8, 6, 4} 进行冒泡排序：</p>
<p>第一轮：</p>
<ul>
<li>比较5和3，发现5&gt;3，交换位置，数列变成 {3, 5, 8, 6, 4}；</li>
<li>比较5和8，发现5&lt;8，位置不变，数列还是 {3, 5, 8, 6, 4}；</li>
<li>比较8和6，发现8&gt;6，交换位置，数列变成 {3, 5, 6, 8, 4}；</li>
<li>比较8和4，发现8&gt;4，交换位置，数列变成 {3, 5, 6, 4, 8}；
第一轮结束，此时最大元素8已经排好序，接下来对剩下的数列 {3, 5, 6, 4} 进行冒泡排序。</li>
</ul>
<p>第二轮：</p>
<ul>
<li>比较3和5，发现3&lt;5，位置不变，数列还是 {3, 5, 6, 4}；</li>
<li>比较5和6，发现5&lt;6，位置不变，数列还是 {3, 5, 6, 4}；</li>
<li>比较6和4，发现6&gt;4，交换位置，数列变成 {3, 5, 4, 6}；
第二轮结束，此时次大元素6已经排好序，剩下的数列 {3, 5, 4} 继续冒泡排序。</li>
</ul>
<p>第三轮：</p>
<ul>
<li>比较3和5，发现3&lt;5，位置不变，数列还是 {3, 5, 4}；</li>
<li>比较5和4，发现5&gt;4，交换位置，数列变成 {3, 4, 5}；
第三轮结束，此时第三大元素5已经排好序，剩下的数列 {3, 4} 继续冒泡排序。</li>
</ul>
<p>第四轮：</p>
<ul>
<li>比较3和4，发现3&lt;4，位置不变，数列还是 {3, 4}；
第四轮结束，此时最小元素3已经排好序，整个数列排序完成。</li>
</ul>
<h2> 复杂度分析</h2>
<ul>
<li>最好情况：当数组已经按照排序需求排好时，只需进行一次遍历，时间复杂度为O(n)；</li>
<li>最坏情况：当数组是逆序排列时，需要进行n-1次遍历，时间复杂度为O(n^2)；</li>
<li>平均情况：需要进行n-1次遍历，时间复杂度为O(n^2)。</li>
</ul>
<p>冒泡排序是一种稳定的排序算法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <category term="算法"/>
    <published>2024-01-06T11:11:12.000Z</published>
  </entry>
  <entry>
    <title type="text">双指针</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88.html"/>
    <updated>2024-01-06T11:11:12.000Z</updated>
    <summary type="html"><![CDATA[<h1> 双指针</h1>
<p>双指针算法（Two-Pointers Algorithm）是一种常见的算法思想，通常用于解决数组或链表相关的问题。该算法通过使用两个指针，分别从数组或链表的两端向中间移动，从而解决问题。
双指针算法通常可以分为两种情况：</p>
<ol>
<li>
<p>从数组的两端向中间移动的双指针算法：
这种情况下，我们通常使用两个指针从数组的两端同时开始遍历，然后根据具体的问题来决定两个指针的移动方式。这种算法通常用于解决一些查找或筛选的问题，例如查找两个数的和等于目标值、查找数组中的环形子数组等。</p>
</li>
<li>
<p>从数组的一端向另一端移动的双指针算法：
这种情况下，我们通常使用两个指针，一个指向数组的起始位置，另一个从起始位置开始向后遍历。这种算法通常用于解决一些排序或统计的问题，例如验证只包含相同字符的最长子串、统计数组中元素出现次数等。</p>
</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h1> 双指针</h1>
<p>双指针算法（Two-Pointers Algorithm）是一种常见的算法思想，通常用于解决数组或链表相关的问题。该算法通过使用两个指针，分别从数组或链表的两端向中间移动，从而解决问题。
双指针算法通常可以分为两种情况：</p>
<ol>
<li>
<p>从数组的两端向中间移动的双指针算法：
这种情况下，我们通常使用两个指针从数组的两端同时开始遍历，然后根据具体的问题来决定两个指针的移动方式。这种算法通常用于解决一些查找或筛选的问题，例如查找两个数的和等于目标值、查找数组中的环形子数组等。</p>
</li>
<li>
<p>从数组的一端向另一端移动的双指针算法：
这种情况下，我们通常使用两个指针，一个指向数组的起始位置，另一个从起始位置开始向后遍历。这种算法通常用于解决一些排序或统计的问题，例如验证只包含相同字符的最长子串、统计数组中元素出现次数等。</p>
</li>
</ol>
<p>使用双指针算法可以有效地提高解决数组或链表相关问题的效率，因为双指针同时进行遍历，可以将时间复杂度从O(n^2)降低到O(n)。</p>
]]></content>
    <category term="算法"/>
    <published>2024-01-06T11:11:12.000Z</published>
  </entry>
  <entry>
    <title type="text">基数排序</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html"/>
    <updated>2024-01-06T11:11:12.000Z</updated>
    <summary type="html"><![CDATA[<h1> 基数排序</h1>
<h2> 基本原理</h2>
<p>基数排序是一种非比较性的排序算法。基数排序的基本思想是：将整数按位数划分为不同的桶，然后按每个位数分别对桶中的元素进行排序，最终将所有位数上的排序结果合并在一起，得到最终的排序结果。</p>
<p>基数排序的时间复杂度为O(dn)，其中d是数字的最大位数，n是待排序元素个数。</p>
<h2> 实现步骤</h2>
<p>基数排序的实现步骤如下：</p>
<ol>
<li>获取待排序数组中的最大值，确定最大位数d。</li>
<li>对最末位进行排序，使用计数排序算法对每个数字出现的次数进行统计。</li>
<li>基于计数排序的结果，依次确定每个数字在有序数组中的位置。</li>
<li>将有序数组重新赋值给原数组。</li>
<li>依次对每一位进行排序，直到最高位。</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h1> 基数排序</h1>
<h2> 基本原理</h2>
<p>基数排序是一种非比较性的排序算法。基数排序的基本思想是：将整数按位数划分为不同的桶，然后按每个位数分别对桶中的元素进行排序，最终将所有位数上的排序结果合并在一起，得到最终的排序结果。</p>
<p>基数排序的时间复杂度为O(dn)，其中d是数字的最大位数，n是待排序元素个数。</p>
<h2> 实现步骤</h2>
<p>基数排序的实现步骤如下：</p>
<ol>
<li>获取待排序数组中的最大值，确定最大位数d。</li>
<li>对最末位进行排序，使用计数排序算法对每个数字出现的次数进行统计。</li>
<li>基于计数排序的结果，依次确定每个数字在有序数组中的位置。</li>
<li>将有序数组重新赋值给原数组。</li>
<li>依次对每一位进行排序，直到最高位。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <category term="算法"/>
    <published>2024-01-06T11:11:12.000Z</published>
  </entry>
  <entry>
    <title type="text">堆排序</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A0%86%E6%8E%92%E5%BA%8F.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%A0%86%E6%8E%92%E5%BA%8F.html"/>
    <updated>2024-01-06T11:11:12.000Z</updated>
    <summary type="html"><![CDATA[<h1> 堆排序</h1>
<p>堆排序（Heap Sort）是利用堆（Heap）这种数据结构进行选择排序的一种算法。堆是一个可以推导具有最大或最小值的树形结构，堆排序利用堆的特性进行排序。</p>
<p>堆排序分为两个步骤：</p>
<ol>
<li>
<p>建堆（Build Heap）：将一个无序的数组构建成一个大顶堆（Max Heap）。大顶堆的特点是父节点的值大于或等于其子节点的值。建堆的过程从数组的最后一个非叶子节点开始，依次向上调整每个节点，使其满足大顶堆的特性。</p>
</li>
<li>
<p>排序（Sort）：重复执行以下步骤，直到堆的大小为1：</p>
<ul>
<li>将堆中的最大元素（根节点）与堆的最后一个元素交换。</li>
<li>将堆的大小减1。</li>
<li>对堆进行调整，使其重新成为一个大顶堆。</li>
</ul>
</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h1> 堆排序</h1>
<p>堆排序（Heap Sort）是利用堆（Heap）这种数据结构进行选择排序的一种算法。堆是一个可以推导具有最大或最小值的树形结构，堆排序利用堆的特性进行排序。</p>
<p>堆排序分为两个步骤：</p>
<ol>
<li>
<p>建堆（Build Heap）：将一个无序的数组构建成一个大顶堆（Max Heap）。大顶堆的特点是父节点的值大于或等于其子节点的值。建堆的过程从数组的最后一个非叶子节点开始，依次向上调整每个节点，使其满足大顶堆的特性。</p>
</li>
<li>
<p>排序（Sort）：重复执行以下步骤，直到堆的大小为1：</p>
<ul>
<li>将堆中的最大元素（根节点）与堆的最后一个元素交换。</li>
<li>将堆的大小减1。</li>
<li>对堆进行调整，使其重新成为一个大顶堆。</li>
</ul>
</li>
</ol>
<p>重复上述步骤，每次取出的都是当前堆中的最大元素，最终得到的数组就是一个有序的数组。</p>
<p>堆排序的时间复杂度为O(nlogn)，空间复杂度为O(1)。由于堆排序是一种不稳定的排序算法，因此在需要保持相同元素的原始顺序时应谨慎使用。</p>
<p>以下是堆排序的示例代码：</p>
<h2> Java实现</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <category term="算法"/>
    <published>2024-01-06T11:11:12.000Z</published>
  </entry>
  <entry>
    <title type="text">快速排序</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"/>
    <updated>2024-01-06T11:11:12.000Z</updated>
    <summary type="html"><![CDATA[<h1> 快速排序</h1>
<p>快速排序是一种常用的排序算法，采用分治法（Divide and Conquer）的思想。它的基本步骤如下：</p>
<ol>
<li>从数列中挑出一个元素，称为“基准”（pivot）。</li>
<li>将所有比基准值小的元素都放在基准前面，比基准值大的元素都放在基准的后面（相同的数可以放在任一边）。在这个分区退出之后，该基准就处于数列的中间位置。</li>
<li>对基准的左右两个分区重复步骤1和步骤2。
快速排序的关键步骤是基准的选取，不同的选取方法会影响排序的效率。通常有以下几种选取方法：
<ul>
<li>选取第一个元素作为基准</li>
<li>选取最后一个元素作为基准</li>
<li>选取中间元素作为基准</li>
<li>从数列中随机选取一个元素作为基准</li>
</ul>
</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h1> 快速排序</h1>
<p>快速排序是一种常用的排序算法，采用分治法（Divide and Conquer）的思想。它的基本步骤如下：</p>
<ol>
<li>从数列中挑出一个元素，称为“基准”（pivot）。</li>
<li>将所有比基准值小的元素都放在基准前面，比基准值大的元素都放在基准的后面（相同的数可以放在任一边）。在这个分区退出之后，该基准就处于数列的中间位置。</li>
<li>对基准的左右两个分区重复步骤1和步骤2。
快速排序的关键步骤是基准的选取，不同的选取方法会影响排序的效率。通常有以下几种选取方法：
<ul>
<li>选取第一个元素作为基准</li>
<li>选取最后一个元素作为基准</li>
<li>选取中间元素作为基准</li>
<li>从数列中随机选取一个元素作为基准</li>
</ul>
</li>
</ol>
<p>快速排序的时间复杂度为O(nlogn)，但在最坏情况下时间复杂度为O(n^2)。为了避免最坏情况的发生，可以采用随机选取基准、三数中值法选取基准等优化方法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <category term="算法"/>
    <published>2024-01-06T11:11:12.000Z</published>
  </entry>
  <entry>
    <title type="text">插入排序</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html"/>
    <updated>2024-01-06T11:11:12.000Z</updated>
    <summary type="html"><![CDATA[<h1> 插入排序</h1>
<p>插入排序是一种简单直观的排序算法。它的基本思想是通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h2> 时间复杂度</h2>
<p>在最坏的情况下，插入排序需要O(n^2)的时间复杂度和O(1)的空间复杂度。</p>
<h2> 空间复杂度</h2>
<p>在最好情况下，插入排序需要O(n)的时间复杂度和O(1)的空间复杂度。</p>
<h2> Java代码实现</h2>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 插入排序(Insertion Sort)是一种简单直观的排序算法。
 * 插入排序的工作原理是：通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
 * 
 * 在最好情况下，插入排序的效率为O(n)，对应的序列是已排序的；
 * 在最坏情况下，插入排序的时间复杂度为O(n^2)，对应的序列是逆序的。
 * 
 * 代码的执行步骤：
 * 1. 从第一个元素开始，该元素可以认为已经被排序；
 * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
 * 3. 如果该元素（已排序）大于新元素，将该元素移动到下一位置；
 * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
 * 5. 将新元素插入到该位置后；
 * 6. 重复步骤2~5。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertionSort</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> key <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                j<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<h1> 插入排序</h1>
<p>插入排序是一种简单直观的排序算法。它的基本思想是通过构建有序序列，对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h2> 时间复杂度</h2>
<p>在最坏的情况下，插入排序需要O(n^2)的时间复杂度和O(1)的空间复杂度。</p>
<h2> 空间复杂度</h2>
<p>在最好情况下，插入排序需要O(n)的时间复杂度和O(1)的空间复杂度。</p>
<h2> Java代码实现</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <category term="算法"/>
    <published>2024-01-06T11:11:12.000Z</published>
  </entry>
  <entry>
    <title type="text">选择排序</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html"/>
    <updated>2024-01-06T11:11:12.000Z</updated>
    <summary type="html"><![CDATA[<h1> 选择排序</h1>
<p>选择排序是一种简单直观的排序算法。它的基本思想是：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>
<h2> 步骤</h2>
<p>选择排序的算法步骤如下：</p>
<ol>
<li>在待排序的元素中，找到最小（大）的元素，将其与第一个元素交换位置。</li>
<li>在剩下的元素中，找到最小（大）的元素，将其与第二个元素交换位置。</li>
<li>重复上述步骤，直到所有元素均排序完毕。</li>
</ol>
<h2> 示例</h2>
<p>给定数组 [3, 4, 2, 1, 5]，按升序排序。</p>]]></summary>
    <content type="html"><![CDATA[<h1> 选择排序</h1>
<p>选择排序是一种简单直观的排序算法。它的基本思想是：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>
<h2> 步骤</h2>
<p>选择排序的算法步骤如下：</p>
<ol>
<li>在待排序的元素中，找到最小（大）的元素，将其与第一个元素交换位置。</li>
<li>在剩下的元素中，找到最小（大）的元素，将其与第二个元素交换位置。</li>
<li>重复上述步骤，直到所有元素均排序完毕。</li>
</ol>
<h2> 示例</h2>
<p>给定数组 [3, 4, 2, 1, 5]，按升序排序。</p>
<ol>
<li>第一次遍历，找到最小元素 1，与第一个元素 3 交换位置，数组变为 [1, 4, 2, 3, 5]。</li>
<li>第二次遍历，忽略第一个元素，找到最小元素 2，与第二个元素 4 交换位置，数组变为 [1, 2, 4, 3, 5]。</li>
<li>第三次遍历，忽略前两个元素，找到最小元素 3，与第三个元素 4 交换位置，数组变为 [1, 2, 3, 4, 5]。</li>
<li>第四次遍历，忽略前三个元素，找到最小元素 4，与第四个元素 4 交换位置，数组保持不变 [1, 2, 3, 4, 5]。</li>
<li>第五次遍历，忽略前四个元素，找到最小元素 5，与第五个元素 5 交换位置，数组保持不变 [1, 2, 3, 4, 5]。</li>
</ol>
<p>最终得到的数组为 [1, 2, 3, 4, 5]，即为按升序排序后的结果。</p>
<h2> 时间复杂度</h2>
<p>选择排序的时间复杂度为 O(n^2)，其中 n 是待排序数组的长度。</p>
<h2> 代码实现</h2>
<p>下面是使用 Java 实现选择排序的示例代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码实现了选择排序的排序算法和排序结果的输出。</p>
]]></content>
    <category term="算法"/>
    <published>2024-01-06T11:11:12.000Z</published>
  </entry>
  <entry>
    <title type="text">数组</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84.html"/>
    <updated>2024-01-05T11:18:48.000Z</updated>
    <summary type="html"><![CDATA[<h1> 数组</h1>
<p>数组是一种线性数据结构，它由一组连续的内存空间组成，用于存储同一类型的数据元素。</p>
<h2> 数组的主要优点包括：</h2>
<h3> 1. 直接访问</h3>
<p>可以通过索引直接访问数组中的元素，时间复杂度为O(1)。</p>
<h3> 2. 灵活操作</h3>
<p>可以通过索引对数组中的元素进行增加、删除、修改等操作。</p>
<h3> 3. 空间有效利用</h3>
<p>在创建数组时，会预分配足够的内存空间用于存储元素，可以有效利用内存空间。</p>
<h2> 数组的主要缺点包括：</h2>
<h3> 1. 大小固定</h3>
<p>数组的大小在创建时就需要确定，并且不能动态改变，如果需要存储更多的元素，需要重新创建一个更大的数组。</p>]]></summary>
    <content type="html"><![CDATA[<h1> 数组</h1>
<p>数组是一种线性数据结构，它由一组连续的内存空间组成，用于存储同一类型的数据元素。</p>
<h2> 数组的主要优点包括：</h2>
<h3> 1. 直接访问</h3>
<p>可以通过索引直接访问数组中的元素，时间复杂度为O(1)。</p>
<h3> 2. 灵活操作</h3>
<p>可以通过索引对数组中的元素进行增加、删除、修改等操作。</p>
<h3> 3. 空间有效利用</h3>
<p>在创建数组时，会预分配足够的内存空间用于存储元素，可以有效利用内存空间。</p>
<h2> 数组的主要缺点包括：</h2>
<h3> 1. 大小固定</h3>
<p>数组的大小在创建时就需要确定，并且不能动态改变，如果需要存储更多的元素，需要重新创建一个更大的数组。</p>
<h3> 2. 无法插入中间元素</h3>
<p>如果需要在数组的中间插入元素，需要将后面的元素都向后移动一位，时间复杂度为O(n)。</p>
<h3> 3. 无法删除中间元素</h3>
<p>如果需要删除数组中的中间元素，需要将后面的元素都向前移动一位，时间复杂度为O(n)。</p>
<h2> 总结</h2>
<p>综上所述，数组适用于元素数量固定且需要直接访问的场景，但是不适用于需要动态增加或删除元素的场景。</p>
]]></content>
    <category term="数据结构"/>
    <published>2024-01-05T11:15:57.000Z</published>
  </entry>
  <entry>
    <title type="text">斐波那契数列问题</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98.html"/>
    <updated>2024-01-05T11:18:48.000Z</updated>
    <summary type="html"><![CDATA[<h1> 斐波那契数列问题</h1>
<p>数学公式如下:</p>
<p v-pre="" class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd class="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>&gt;</mo><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd><mtd class="mtr-glue"></mtd><mtd class="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align}
f(n)  = 

\left\{
    \begin{matrix}
        0   &amp; n=0  \\
        1   &amp; n=1  \\  
        f(n-1)+f(n-2)  &amp; n&gt;=1
    \end{matrix}
\right.

\end{align}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.9em;vertical-align:-1.7em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.2em;"><span style="top:-4.2em;"><span class="pstrut" style="height:4.05em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.5em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.492em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.016em" style="width:0.8889em" viewBox="0 0 888.89 16" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V16 H384z M384 0 H504 V16 H384z"></path></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.016em" style="width:0.8889em" viewBox="0 0 888.89 16" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V16 H384z M384 0 H504 V16 H384z"></path></svg></span></span><span style="top:-4.3em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.7em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.2em;"><span style="top:-4.2em;"><span class="pstrut" style="height:4.05em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.7em;"><span></span></span></span></span></span></span></span></span></p>]]></summary>
    <content type="html"><![CDATA[<h1> 斐波那契数列问题</h1>
<p>数学公式如下:</p>
<p v-pre="" class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd class="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>n</mi><mo>&gt;</mo><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd><mtd class="mtr-glue"></mtd><mtd class="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align}
f(n)  = 

\left\{
    \begin{matrix}
        0   &amp; n=0  \\
        1   &amp; n=1  \\  
        f(n-1)+f(n-2)  &amp; n&gt;=1
    \end{matrix}
\right.

\end{align}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.9em;vertical-align:-1.7em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.2em;"><span style="top:-4.2em;"><span class="pstrut" style="height:4.05em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.5em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.492em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.016em" style="width:0.8889em" viewBox="0 0 888.89 16" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V16 H384z M384 0 H504 V16 H384z"></path></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.016em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.016em" style="width:0.8889em" viewBox="0 0 888.89 16" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V16 H384z M384 0 H504 V16 H384z"></path></svg></span></span><span style="top:-4.3em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.7em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.2em;"><span style="top:-4.2em;"><span class="pstrut" style="height:4.05em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.7em;"><span></span></span></span></span></span></span></span></span></p>
<hr>
]]></content>
    <category term="算法"/>
    <published>2024-01-05T10:54:05.000Z</published>
  </entry>
  <entry>
    <title type="text">记录搭建VuePress博客</title>
    <id>https://suveng.github.io/suveng_blog/zh/posts/%E8%AE%B0%E5%BD%95/%E8%AE%B0%E5%BD%95%E6%90%AD%E5%BB%BAVuePress%E5%8D%9A%E5%AE%A2.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/posts/%E8%AE%B0%E5%BD%95/%E8%AE%B0%E5%BD%95%E6%90%AD%E5%BB%BAVuePress%E5%8D%9A%E5%AE%A2.html"/>
    <updated>2024-01-05T02:25:32.000Z</updated>
    <summary type="html"><![CDATA[<h1> 记录搭建VuePress博客</h1>
<p><a href="https://theme-hope.vuejs.press/zh/guide/blog/article.html" target="_blank" rel="noopener noreferrer">VuePress</a></p>
]]></summary>
    <content type="html"><![CDATA[<h1> 记录搭建VuePress博客</h1>
<p><a href="https://theme-hope.vuejs.press/zh/guide/blog/article.html" target="_blank" rel="noopener noreferrer">VuePress</a></p>
]]></content>
    <category term="博客"/>
    <published>2024-01-04T09:45:47.000Z</published>
  </entry>
  <entry>
    <title type="text">介绍页</title>
    <id>https://suveng.github.io/suveng_blog/zh/intro.html</id>
    <link href="https://suveng.github.io/suveng_blog/zh/intro.html"/>
    <updated>2024-01-05T02:25:32.000Z</updated>
    <summary type="html"><![CDATA[<h1> 介绍页</h1>
<p>这是我的个人简历</p>
<h2> 个人信息</h2>
<p>姓名: 苏文广<br>
性别: 男<br>
出生年月: 1996-12<br>
大学: 韩山师范学院-软件工程专业(2015.9~2019.6/全日制统招本科)<br>
手机号: 18320664028<br>
邮箱: suveng@163.com</p>
<h2> 开发技能</h2>
<ul>
<li>4年工作经验</li>
<li>熟悉 Java 语言, IO,反射,SPI,jvm, java agent</li>
<li>精通业务关系建模;能够独立设计大型复杂系统, 绘制系统架构图, UML 设计图, 精通 OKR 工作法</li>
<li>精通 MySQL,掌握复杂 SQL 查询, 熟悉读写分离策略,主从复制策略, 熟悉常见 MySQL HA 代理方案, 熟练使用 sharding-sphere 对 MySQL 分库分表, 了解 ACID 实现原理,了解 MVCC 实现原理, 了解索引实现机制, 了解 XA 分布式事务管理</li>
<li>熟悉 Linux 系统, 熟悉线上运维命令, 熟练 shell 脚本</li>
<li>熟悉 Spring 全家桶, 熟悉 SpringCloud 微服务分布式架构实现,SpringBlade 脚手架</li>
<li>掌握分布式存储设计; 熟悉 Hadoop 存储系统, 熟悉 HBase 数仓</li>
<li>掌握分布式缓存设计; 掌握基于 Redis 的分布式缓存策略;</li>
<li>掌握分布式调度设计; 熟练使用常见的分布式调度平台, xxl-job, schedulex</li>
<li>掌握常见分布式事务设计, TCC 策略, Seata 架构</li>
<li>掌握数据仓库设计, 熟练编写 Clickhouse sql 离线计算任务, Flink sql 实时计算任务</li>
<li>掌握常见监控告警设计,熟练使用 Prometheus 系统生态</li>
<li>了解 Vue,React 框架, 编写过数据大屏以及后台管理界面</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h1> 介绍页</h1>
<p>这是我的个人简历</p>
<h2> 个人信息</h2>
<p>姓名: 苏文广<br>
性别: 男<br>
出生年月: 1996-12<br>
大学: 韩山师范学院-软件工程专业(2015.9~2019.6/全日制统招本科)<br>
手机号: 18320664028<br>
邮箱: suveng@163.com</p>
<h2> 开发技能</h2>
<ul>
<li>4年工作经验</li>
<li>熟悉 Java 语言, IO,反射,SPI,jvm, java agent</li>
<li>精通业务关系建模;能够独立设计大型复杂系统, 绘制系统架构图, UML 设计图, 精通 OKR 工作法</li>
<li>精通 MySQL,掌握复杂 SQL 查询, 熟悉读写分离策略,主从复制策略, 熟悉常见 MySQL HA 代理方案, 熟练使用 sharding-sphere 对 MySQL 分库分表, 了解 ACID 实现原理,了解 MVCC 实现原理, 了解索引实现机制, 了解 XA 分布式事务管理</li>
<li>熟悉 Linux 系统, 熟悉线上运维命令, 熟练 shell 脚本</li>
<li>熟悉 Spring 全家桶, 熟悉 SpringCloud 微服务分布式架构实现,SpringBlade 脚手架</li>
<li>掌握分布式存储设计; 熟悉 Hadoop 存储系统, 熟悉 HBase 数仓</li>
<li>掌握分布式缓存设计; 掌握基于 Redis 的分布式缓存策略;</li>
<li>掌握分布式调度设计; 熟练使用常见的分布式调度平台, xxl-job, schedulex</li>
<li>掌握常见分布式事务设计, TCC 策略, Seata 架构</li>
<li>掌握数据仓库设计, 熟练编写 Clickhouse sql 离线计算任务, Flink sql 实时计算任务</li>
<li>掌握常见监控告警设计,熟练使用 Prometheus 系统生态</li>
<li>了解 Vue,React 框架, 编写过数据大屏以及后台管理界面</li>
</ul>
]]></content>
    <category term="博主"/>
    <published>2024-01-04T08:10:21.000Z</published>
  </entry>
</feed>